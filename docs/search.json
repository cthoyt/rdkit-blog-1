[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "RDKit experiments, tips, and tutorials",
    "section": "",
    "text": "The primary author of this blog is Greg Landrum.\nThe repo with the original Jupyter notebooks and data for this blog is here\nThe hub for information about the RDKit is rdkit.org\nIf you’re an Anaconda Python user, installing the RDKit is as simple as conda install -c conda-forge rdkit\nYou can also install the RDKit from PyPi: pip install rdkit-pypi\n \n  \n   \n  \n    \n     @rdkit_org\n  \n  \n    \n     RDKit group on linkedin\n  \n  \n    \n     Github\n  \n\n\n\nProfessional support and services for the RDKit are provided by T5 Informatics GmbH.\nContact us if you are interested in RDKit support."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "RDKit blog",
    "section": "",
    "text": "Clustering conformers\n\n\n\n\n\n\n\ntutorial\n\n\n3d\n\n\nconformers\n\n\n\n\nTutorial on how to cluster molecular conformers.\n\n\n\n\n\n\nMar 2, 2023\n\n\n\n\n\n\n  \n\n\n\n\nUsing Feature Maps\n\n\n\n\n\n\n\ntutorial\n\n\n3d\n\n\n\n\nA useful tool for working with collections of chemical features.\n\n\n\n\n\n\nFeb 24, 2023\n\n\n\n\n\n\n  \n\n\n\n\nMore on constrained embedding\n\n\n\n\n\n\n\ntutorial\n\n\n3d\n\n\n\n\nGenerating conformers where some atomic coordinates are constrained.\n\n\n\n\n\n\nFeb 10, 2023\n\n\n\n\n\n\n  \n\n\n\n\nWorking with conformers\n\n\n\n\n\n\n\ntutorial\n\n\n3d\n\n\n\n\nTutorial on how atomic coordinates are stored\n\n\n\n\n\n\nFeb 4, 2023\n\n\n\n\n\n\n  \n\n\n\n\nColliding bits III, expanded\n\n\n\n\n\n\n\nreference\n\n\nfingerprints\n\n\n\n\nLooking at numbers of collisions and their impact on similarity\n\n\n\n\n\n\nJan 23, 2023\n\n\n\n\n\n\n  \n\n\n\n\nFingerprintGenerator tutorial\n\n\n\n\n\n\n\ntutorial\n\n\nfingerprints\n\n\n\n\nA better way to generate molecular fingerprints\n\n\n\n\n\n\nJan 18, 2023\n\n\n\n\n\n\n  \n\n\n\n\nR-Group Decomposition Tutorial\n\n\n\n\n\n\n\ntutorial\n\n\nrgd\n\n\n\n\nGetting started with RGD\n\n\n\n\n\n\nJan 9, 2023\n\n\n\n\n\n\n  \n\n\n\n\nR-Group Decomposition: Edge Cases\n\n\n\n\n\n\n\nreference\n\n\nrgd\n\n\n\n\nMore complicated than it seems at first glance.\n\n\n\n\n\n\nJan 5, 2023\n\n\n\n\n\n\n  \n\n\n\n\nColliding bits II, revisited\n\n\n\n\n\n\n\nreference\n\n\nfingerprints\n\n\n\n\nThe impact of bit collisions on machine-learning performance\n\n\n\n\n\n\nDec 25, 2022\n\n\n\n\n\n\n  \n\n\n\n\nDescriptor calculation tutorial\n\n\n\n\n\n\n\ntutorial\n\n\ndescriptors\n\n\n\n\nThis will eventually be in the docs\n\n\n\n\n\n\nDec 23, 2022\n\n\n\n\n\n\n  \n\n\n\n\nIntroducing rdDetermineBonds\n\n\n\n\n\n\n\ntutorial\n\n\n3d\n\n\n\n\nAssigning bonds from 3D coordinates\n\n\n\n\n\n\nDec 18, 2022\n\n\n\n\n\n\n  \n\n\n\n\nTiming methods for serializing molecules\n\n\n\n\n\n\n\nreference\n\n\noptimization\n\n\n\n\nQuickly saving/restoring molecules from text formats\n\n\n\n\n\n\nDec 9, 2022\n\n\n\n\n\n\n  \n\n\n\n\nDealing with multiconformer SD files\n\n\n\n\n\n\n\n3d\n\n\nconformers\n\n\ntutorial\n\n\n\n\nIf only we could reliably use better file formats\n\n\n\n\n\n\nOct 28, 2022\n\n\n\n\n\n\n  \n\n\n\n\nOptimizing conformer generation parameters\n\n\n\n\n\n\n\n3d\n\n\nconformers\n\n\noptimization\n\n\n\n\nImproving the speed of the RDKit’s conformer generator\n\n\n\n\n\n\nSep 29, 2022\n\n\n\n\n\n\n  \n\n\n\n\n3D maximum common substructure\n\n\n\n\n\n\n\ntutorial\n\n\n3d\n\n\nmcs\n\n\n\n\nTaking atomic coordinates into account when doing MCS\n\n\n\n\n\n\nJun 23, 2022\n\n\n\n\n\n\n  \n\n\n\n\nVariability of PMI descriptors\n\n\n\n\n\n\n\n3d\n\n\nquestions\n\n\n\n\nWhich is more important, stereochemistry or conformational variability?\n\n\n\n\n\n\nJun 22, 2022\n\n\n\n\n\n\n  \n\n\n\n\nSearching with generic groups\n\n\n\n\n\n\n\ntutorial\n\n\nsubstructure\n\n\n\n\nUsing generics to get more specific\n\n\n\n\n\n\nApr 5, 2022\n\n\n\n\n\n\n  \n\n\n\n\nSome thoughts on refactoring the MolDraw2D code\n\n\n\n\n\n\n\ntechnical\n\n\n\n\nA bit of rambling and an overview of some new features\n\n\n\n\n\n\nMar 18, 2022\n\n\n\n\n\n\n  \n\n\n\n\nR-group decomposition and molzip\n\n\n\n\n\n\n\ntutorial\n\n\nrgd\n\n\n\n\nGenerating molecules from all possible combinations of R groups\n\n\n\n\n\n\nMar 14, 2022\n\n\n\n\n\n\n  \n\n\n\n\nThe number of unique fingerprint bits\n\n\n\n\n\n\n\nexploratory\n\n\nreference\n\n\n\n\nHow many distinct atom environments are there in organic molecules?\n\n\n\n\n\n\nJan 4, 2022\n\n\n\n\n\n\n  \n\n\n\n\nA Ternary GHOST\n\n\n\n\n\n\n\nexploratory\n\n\nmachinelearning\n\n\n\n\nExtending the threshold-shifting algorithm to three-class problems\n\n\n\n\n\n\nDec 23, 2021\n\n\n\n\n\n\n  \n\n\n\n\nSome new features in the SubstructLibrary\n\n\n\n\n\n\n\ntutorial\n\n\nsubstructure\n\n\n\n\nChanging the search order, refining searches, and assigning keys\n\n\n\n\n\n\nDec 20, 2021\n\n\n\n\n\n\n  \n\n\n\n\nUsing single-molecule reactions\n\n\n\n\n\n\n\ntutorial\n\n\nreactions\n\n\n\n\nA fast and easy way to apply simple reactions\n\n\n\n\n\n\nDec 15, 2021\n\n\n\n\n\n\n  \n\n\n\n\nHighlighting changing atoms and bonds in reactions\n\n\n\n\n\n\n\ntutorial\n\n\nreactions\n\n\n\n\nA compact view of what changed in a product molecule\n\n\n\n\n\n\nNov 26, 2021\n\n\n\n\n\n\n  \n\n\n\n\nR-Group Decomposition and Highlighting\n\n\n\n\n\n\n\ntutorial\n\n\nprototypes\n\n\ndrawing\n\n\nrgd\n\n\n\n\nMaking pretty pictures for SAR analysis\n\n\n\n\n\n\nAug 7, 2021\n\n\n\n\n\n\n  \n\n\n\n\nGeneralized substructure search\n\n\n\n\n\n\n\ntutorial\n\n\nsubstructure\n\n\n\n\nUsing advanced query features\n\n\n\n\n\n\nAug 3, 2021\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nUsing the RDKit in a C++ program\n\n\n\n\n\n\n\ntutorial\n\n\ntechnical\n\n\n\n\nIt’s actually pretty easy\n\n\n\n\n\n\nJul 24, 2021\n\n\n\n\n\n\n  \n\n\n\n\nLooking at the number of bits set by different fingerprints\n\n\n\n\n\n\n\nfingerprints\n\n\nreference\n\n\n\n\nHow many features do we find?\n\n\n\n\n\n\nJul 6, 2021\n\n\n\n\n\n\n  \n\n\n\n\nSimulating count fingerprints\n\n\n\n\n\n\n\nfingerprints\n\n\ntechnical\n\n\nreference\n\n\n\n\nAn approximation to make working with count vectors more efficient\n\n\n\n\n\n\nJul 6, 2021\n\n\n\n\n\n\n  \n\n\n\n\nSome observations about similarity search thresholds\n\n\n\n\n\n\n\nsimilarity\n\n\nreference\n\n\n\n\nFingerprint efficiency\n\n\n\n\n\n\nMay 26, 2021\n\n\n\n\n\n\n  \n\n\n\n\nFingerprint similarity thresholds for database searches\n\n\n\n\n\n\n\nsimilarity\n\n\nreference\n\n\n\n\nFOMO and similarity search\n\n\n\n\n\n\nMay 21, 2021\n\n\n\n\n\n\n  \n\n\n\n\nThresholds for “random” in fingerprints the RDKit supports\n\n\n\n\n\n\n\nfingerprints\n\n\nsimilarity\n\n\nreference\n\n\n\n\nWhen is it just noise?\n\n\n\n\n\n\nMay 18, 2021\n\n\n\n\n\n\n  \n\n\n\n\nIntro to the molecule enumerator\n\n\n\n\n\n\n\ntutorial\n\n\nsubstructure\n\n\n\n\nUsing some advanced query features\n\n\n\n\n\n\nMay 13, 2021\n\n\n\n\n\n\n  \n\n\n\n\nA new way to use the RDKit from other languages\n\n\n\n\n\n\n\ntechnical\n\n\n\n\nIntroducing the RDKit CFFI interface\n\n\n\n\n\n\nMay 1, 2021\n\n\n\n\n\n\n  \n\n\n\n\nETKDG and distance constraints\n\n\n\n\n\n\n\nconformers\n\n\nexploration\n\n\n\n\nBiasing the conformational search\n\n\n\n\n\n\nFeb 22, 2021\n\n\n\n\n\n\n  \n\n\n\n\nLooking at random-coordinate embedding\n\n\n\n\n\n\n\nconformers\n\n\nexploration\n\n\n3d\n\n\n\n\nAn alternative starting point for conformer generation\n\n\n\n\n\n\nJan 31, 2021\n\n\n\n\n\n\n  \n\n\n\n\nSphere exclusion clustering with the RDKit\n\n\n\n\n\n\n\nsimilarity\n\n\ntutorial\n\n\n\n\nVery fast clustering for larger datasets\n\n\n\n\n\n\nNov 18, 2020\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSetting up an environment to make Python contributions to the RDKit\n\n\n\n\n\n\n\ncontributing\n\n\ntutorial\n\n\n\n\nA relatively simple way to become a code contributor\n\n\n\n\n\n\nMar 30, 2020\n\n\n\n\n\n\n  \n\n\n\n\nFinding regioisomers\n\n\n\n\n\n\n\nsubstructure\n\n\ntutorial\n\n\n\n\nAdvanced substructure searching technique\n\n\n\n\n\n\nJan 30, 2020\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTrying out the new tautomer canonicalization code\n\n\n\n\n\n\n\nprototypes\n\n\ntechnical\n\n\n\n\nEnumerating tautomers and picking a canonical one\n\n\n\n\n\n\nJan 25, 2020\n\n\n\n\n\n\n  \n\n\n\n\nSome thoughts on the performance of the RDKit cartridge\n\n\n\n\n\n\n\ncartridge\n\n\n\n\nData, hints, and even a bit of ranting\n\n\n\n\n\n\nJan 21, 2020\n\n\n\n\n\n\n  \n\n\n\n\nSimilarity maps with the new drawing code\n\n\n\n\n\n\n\ntutorial\n\n\n\n\nA new, and nicer, way to generate similarity maps\n\n\n\n\n\n\nJan 3, 2020\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/2020-01-03-similarity-maps-with-new-drawing-code.html",
    "href": "posts/2020-01-03-similarity-maps-with-new-drawing-code.html",
    "title": "Similarity maps with the new drawing code",
    "section": "",
    "text": "As part of the 2019.09 release we added a C++ implementation of the RDKit’s similarity map functionality (https://jcheminf.biomedcentral.com/articles/10.1186/1758-2946-5-43). I forgot to mention this during the “What’s New” bit of my presentation at the UGM, but I think it’s worth calling attention to. So here’s a quick blog post.\n\nfrom rdkit import Chem\nfrom rdkit.Chem import Draw\nfrom rdkit.Chem.Draw import SimilarityMaps\nfrom IPython.display import SVG\nimport io\nfrom PIL import Image\nimport numpy as np\nimport rdkit\nprint(rdkit.__version__)\n\nRDKit WARNING: [11:53:45] Enabling RDKit 2019.09.2 jupyter extensions\n\n\n2019.09.2\n\n\nI start by using “classic” similarity map functionality to show why atorvastatin (Lipitor) and rosuvastatin (Crestor) are similar to each other when using the Morgan fingerprint.\nHere are the two molecules:\n\natorvastatin = Chem.MolFromSmiles('O=C(O)C[C@H](O)C[C@H](O)CCn2c(c(c(c2c1ccc(F)cc1)c3ccccc3)C(=O)Nc4ccccc4)C(C)C')\nrosuvastatin = Chem.MolFromSmiles('OC(=O)C[C@H](O)C[C@H](O)\\C=C\\c1c(C(C)C)nc(N(C)S(=O)(=O)C)nc1c2ccc(F)cc2')\nDraw.MolsToGridImage((atorvastatin,rosuvastatin))\n\n\n\n\nTo use the new drawing code, we create a Draw2D object and pass that to SimilarityMaps.GetSimilarityMapForFingerprint:\n\ndef show_png(data):\n    bio = io.BytesIO(data)\n    img = Image.open(bio)\n    return img\n\n\nd = Draw.MolDraw2DCairo(400, 400)\n_, maxWeight = SimilarityMaps.GetSimilarityMapForFingerprint(atorvastatin, rosuvastatin, \n                                        lambda m, i: SimilarityMaps.GetMorganFingerprint(m, i, radius=2, fpType='bv'), \n                                        draw2d=d)\nd.FinishDrawing()\nshow_png(d.GetDrawingText())\n\n\n\n\nWe can do the same thing with count-based fingerprints:\n\nd = Draw.MolDraw2DCairo(400, 400)\n_, maxWeight = SimilarityMaps.GetSimilarityMapForFingerprint(atorvastatin, rosuvastatin, \n                                        lambda m, i: SimilarityMaps.GetMorganFingerprint(m, i, radius=2, fpType='count'), \n                                        draw2d=d)\nd.FinishDrawing()\nshow_png(d.GetDrawingText())\n\n\n\n\nThe other GetSimilarityMapFrom... functions also accept the optional draw2d argument. Here’s a visualization of the contributions made by the atoms in atorvastatin to its calculatied logp value:\n\nfrom rdkit.Chem import rdMolDescriptors\nator_contribs = rdMolDescriptors._CalcCrippenContribs(atorvastatin)\nd = Draw.MolDraw2DCairo(400, 400)\nSimilarityMaps.GetSimilarityMapFromWeights(atorvastatin,[x[0] for x in ator_contribs],draw2d=d)\nd.FinishDrawing()\nshow_png(d.GetDrawingText())\n\n\n\n\nAnd a couple more visualizations of various partial charge schemes.\nStarting with Gasteiger-Marsilli charges:\n\nfrom rdkit.Chem import rdPartialCharges\nrdPartialCharges.ComputeGasteigerCharges(atorvastatin)\nchgs = [x.GetDoubleProp(\"_GasteigerCharge\") for x in atorvastatin.GetAtoms()]\nd = Draw.MolDraw2DCairo(400, 400)\nSimilarityMaps.GetSimilarityMapFromWeights(atorvastatin,chgs,draw2d=d)\nd.FinishDrawing()\nshow_png(d.GetDrawingText())\n\n\n\n\nAnd also the partial charges calculated with extended Hueckel theory (eHT) using Mulliken analysis:\n\nfrom rdkit.Chem import rdEHTTools\nfrom rdkit.Chem import rdDistGeom\nmh = Chem.AddHs(atorvastatin)\nrdDistGeom.EmbedMolecule(mh)\n_,res = rdEHTTools.RunMol(mh)\nstatic_chgs = res.GetAtomicCharges()[:atorvastatin.GetNumAtoms()]\nd = Draw.MolDraw2DCairo(400, 400)\nSimilarityMaps.GetSimilarityMapFromWeights(atorvastatin,list(static_chgs),draw2d=d)\nd.FinishDrawing()\nshow_png(d.GetDrawingText())\n\n\n\n\nAs one final demo, I’ll use the method to visualize the variability of the eHT charges with conformation for atorvastatin.\nStart by generating 10 diverse conformers, calculating the charges for each, and plotting the average:\n\nmh = Chem.AddHs(atorvastatin)\nps = rdDistGeom.ETKDGv2()\nps.pruneRmsThresh = 0.5\nps.randomSeed = 0xf00d\nrdDistGeom.EmbedMultipleConfs(mh,10,ps)\nprint(f'Found {mh.GetNumConformers()} conformers')\nchgs = []\nfor conf in mh.GetConformers():\n    _,res = rdEHTTools.RunMol(mh,confId=conf.GetId())\n    chgs.append(res.GetAtomicCharges()[:atorvastatin.GetNumAtoms()])\nchgs = np.array(chgs)\nmean_chgs = np.mean(chgs,axis=0)\nstd_chgs = np.std(chgs,axis=0)\nd = Draw.MolDraw2DCairo(400, 400)\nSimilarityMaps.GetSimilarityMapFromWeights(atorvastatin,list(mean_chgs),draw2d=d)\nd.FinishDrawing()\nshow_png(d.GetDrawingText())\n\nFound 10 conformers\n\n\n\n\n\nThat doesn’t look hugely different from what we saw above.\nTo show the variability, plot the standard deviation of the charges across the 10 conformers:\n\nprint(std_chgs)\nprint(max(std_chgs),min(std_chgs))\nd = Draw.MolDraw2DCairo(400, 400)\nSimilarityMaps.GetSimilarityMapFromWeights(atorvastatin,list(std_chgs),draw2d=d)\nd.FinishDrawing()\nshow_png(d.GetDrawingText())\n\n[0.01292592 0.00743163 0.01971312 0.01433223 0.01063085 0.01283745\n 0.01219511 0.00748435 0.01234194 0.01492494 0.00640842 0.02264999\n 0.02481744 0.00987842 0.00843151 0.01289956 0.00560632 0.00498617\n 0.00604883 0.005569   0.00452067 0.00796675 0.00718033 0.00581337\n 0.00702613 0.00634237 0.00699789 0.00539868 0.00521868 0.02412709\n 0.03131741 0.03709349 0.00657276 0.01175903 0.00674661 0.01012909\n 0.0050995  0.01139418 0.00831795 0.00581207 0.00960073]\n0.03709348867462464 0.00452067345998171\n\n\n\n\n\nThe deviations aren’t huge (the printed array shows that), but the largest value is clearly the amide N.\nThere’s definitely a ToDo here to improve the way the negative contours are drawn so that the fact that they are being drawn with dashed lines is visible."
  },
  {
    "objectID": "posts/2021-05-01-rdkit-cffi-part1.html",
    "href": "posts/2021-05-01-rdkit-cffi-part1.html",
    "title": "A new way to use the RDKit from other languages",
    "section": "",
    "text": "We’ve added a new API which makes it easy to use the RDKit from programming languages other than C++, Python, Java or C#."
  },
  {
    "objectID": "posts/2021-05-01-rdkit-cffi-part1.html#parsing-molecule-formats-and-operating-on-molecules",
    "href": "posts/2021-05-01-rdkit-cffi-part1.html#parsing-molecule-formats-and-operating-on-molecules",
    "title": "A new way to use the RDKit from other languages",
    "section": "Parsing molecule formats and operating on molecules",
    "text": "Parsing molecule formats and operating on molecules\nThe “hello world” equivalent in cheminformatics is generating canonical SMILES. Here’s a full C program showing how you do that with rdkit-cffi, I will explain the rdkit-cffi functions and how they are used in more detail below:\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"cffiwrapper.h\"\n\nvoid canon_smiles(){\n  char *pkl;\n  size_t pkl_size;\n  \n  pkl = get_mol(\"c1cc(O)ccc1\",&pkl_size,\"\");\n  char *smiles=get_smiles(pkl,pkl_size,NULL);\n  printf(\"Canonical SMILES: %s\\n\",smiles);\n  free(smiles);\n  free(pkl);\n}\n\nint main(){\n  enable_logging();\n  printf(\"hello %s\\n\",version()); \n  canon_smiles();\n  return 0;\n}\nI compiled this on my linux machine as follows:\n% cc -o demo.exe -I $RDBASE/Code demo.c $RDBASE/lib/librdkitcffi.so\nRunning it produces:\n% ./demo.exe\nhello 2021.09.1pre\nCanonical SMILES: Oc1ccccc1\nLet’s look at the rdkit-cffi parts of this, starting with the main() function.\nWe start by enabling the RDKit’s logging system:\n  enable_logging();\nIf you skip this, you won’t see any of the usual RDKit errors or warnings.\nNext we use the version() function to get the version of the RDKit which is being used and then print that out.\nWith that basic initialization out of the way we call the function canon_smiles(), which is where the real work happens. Here we start by parsing a SMILES using the get_mol() function:\n  pkl = get_mol(\"c1cc(O)ccc1\",&pkl_size,\"\");\n\nget_mol() returns a binary string with the pickled representation of the molecule and uses the pkl_size argument (an integer) to return the length of that string (this is an unfortunately necessary implementation detail). The final argument to get_mol(), the empty string, can be used to pass in an JSON string containing additional arguments controlling the parsing (we could have also passed this argument as NULL). get_mol() currently supports constructing molecules from SMILES (and CXSMILES), Mol/SDF, and the RDKit’s JSON format; it recognized automatically which parser should be used. We will be expanding the list of supported formats in the future.\nAfter we have the molecule processed we can get the canonical SMILES for it by calling the get_smiles() function:\n  char *smiles=get_smiles(pkl,pkl_size,NULL);\nget_smiles() follows the general pattern for rdkit-cffi functions which operate on molecules: the first two arguments are the pickled molecule and the length of the pickle string, the third argument is a JSON string with additional options to be used when generating the SMILES; in this case we want the defaults, so we pass a NULL pointer (we could also have used the empty string \"\").\nFinally, and not to be overlooked when working in C, we need to free the memory which was allocated to hold the molecule pickle and the SMILES:\n  free(smiles);\n  free(pkl);\nThe functions which are available are declared in cffiwrapper.h."
  },
  {
    "objectID": "posts/2021-05-01-rdkit-cffi-part1.html#modifying-molecules",
    "href": "posts/2021-05-01-rdkit-cffi-part1.html#modifying-molecules",
    "title": "A new way to use the RDKit from other languages",
    "section": "Modifying molecules",
    "text": "Modifying molecules\nSome rdkit-cffi functions modify the molecule. In this case the general pattern is the modify the molecule in place, i.e. to modify the current molecule instead of returning a new one.\nHere’s a simple function which parses a SMILES, add Hs to the molecule, generates a 3D conformer using a fixed random seed, and then prints out the molblock for the modified molecule:\nvoid generate_conformer(){\n  char *pkl;\n  size_t pkl_size;\n  \n  pkl = get_mol(\"c1cc(O)ccc1\",&pkl_size,NULL);\n\n  add_hs(&pkl,&pkl_size);\n\n  set_3d_coords(&pkl,&pkl_size,\"{\\\"randomSeed\\\":42}\");\n\n  char *molb = get_molblock(pkl,pkl_size,NULL);\n  printf(\"%s\\n\",molb);\n  free(molb);\n  free(pkl);\n}\nWe’ve already seen get_mol(). As mentioned above add_hs() modifies the molecule in place, so you need to pass pointers to the pickle string and pickle size so that they can be modifed. set_3d_coords() also modifies the molecule in place to add the conformer. This is also the first time we use the JSON string that most of the functions take as their last argument: here we set the random number seed used in the conformer generation so that we get reproducible results. Finally get_molblock(), like get_smiles(), returns a string with the MOL file data for the molecule. This can be saved to a file and opened in most chemistry software."
  },
  {
    "objectID": "posts/2021-08-07-rgd-and-highlighting.html",
    "href": "posts/2021-08-07-rgd-and-highlighting.html",
    "title": "R-Group Decomposition and Highlighting",
    "section": "",
    "text": "Note: This is a slightly updated version of a post from 2020\nThis one was inspired by a conversation that happened at the 2020 RDKit (virtual) UGM.\nDuring Dominique Sydow’s presentation she showed some pictures of molecules with some regions of the molecule highlighted (in her case to indicate which kinase pocket they interact with). Dominique had created the images by hand, but I wanted to explore what’s possible using the 2020.09 RDKit release.\nWhat this post is going to demonstrate is doing R-group decomposition (RGD) on a set of molecules that share a common scaffold, generating coordinates for those molecules that are aligned to the scaffold, and generating images of the molecules where the R groups are colored to make them easy to pick out.\nThe final images we create will look like this:\n\n\n\nrgd-and-highlighting1-1.png\n\n\nThe rest of this post will go through the steps to create images like this.\nLet’s get started\n\nfrom rdkit import Chem\nfrom rdkit.Chem import Draw\nfrom rdkit.Chem.Draw import IPythonConsole\nIPythonConsole.molSize=(450,350)\nfrom rdkit.Chem import rdRGroupDecomposition\nfrom rdkit.Chem import rdqueries\nfrom rdkit.Chem import rdDepictor\nfrom rdkit.Chem.Draw import rdMolDraw2D\nfrom rdkit import Geometry\nrdDepictor.SetPreferCoordGen(True)\nimport pandas as pd\n\nfrom IPython.display import SVG,Image\nfrom ipywidgets import interact\n\nimport rdkit\nprint(rdkit.__version__)\n\n2021.03.4\n\n\nStart by reading in the data we will use. This is a collection of ChEMBL compounds with Ki data measured for CDK2. The dataset includes compounds from a number of different documents and, since these are medchem papers, many of the documents contain groups of compounds that share a common scaffold.\n\ndf = pd.read_csv('../data/cdk2_rgd_dataset.csv')\ndf.head()\n\n\n\n\n\n  \n    \n      \n      assay_id\n      doc_id\n      description\n      assay_organism\n      assay_chembl_id\n      aidx\n      pref_name\n      activity_id\n      molregno\n      standard_relation\n      ...\n      src_id (#1)\n      type\n      relation\n      value\n      units\n      text_value\n      standard_text_value\n      standard_inchi_key\n      canonical_smiles\n      compound_chembl_id\n    \n  \n  \n    \n      0\n      50641\n      17759\n      Inhibitory activity against human CDK2 (Cyclin...\n      NaN\n      CHEMBL658107\n      CLD0\n      Cyclin-dependent kinase 2\n      265814\n      68026\n      >\n      ...\n      1\n      Ki\n      >\n      20.00\n      uM\n      NaN\n      NaN\n      RPXWUUDZINQPTJ-UHFFFAOYSA-N\n      CNc1nccc(n1)c2sc(C)nc2C\n      CHEMBL46474\n    \n    \n      1\n      50641\n      17759\n      Inhibitory activity against human CDK2 (Cyclin...\n      NaN\n      CHEMBL658107\n      CLD0\n      Cyclin-dependent kinase 2\n      265817\n      67880\n      =\n      ...\n      1\n      Ki\n      =\n      0.14\n      uM\n      NaN\n      NaN\n      GDZTURHUKDAJGD-UHFFFAOYSA-N\n      Cc1nc(C)c(s1)c2ccnc(Nc3ccc(O)cc3)n2\n      CHEMBL442957\n    \n    \n      2\n      50641\n      17759\n      Inhibitory activity against human CDK2 (Cyclin...\n      NaN\n      CHEMBL658107\n      CLD0\n      Cyclin-dependent kinase 2\n      267078\n      67751\n      =\n      ...\n      1\n      Ki\n      =\n      6.50\n      uM\n      NaN\n      NaN\n      CTFDMGIBHFQWKB-UHFFFAOYSA-N\n      Cc1nc(C)c(s1)c2ccnc(N)n2\n      CHEMBL47302\n    \n    \n      3\n      50641\n      17759\n      Inhibitory activity against human CDK2 (Cyclin...\n      NaN\n      CHEMBL658107\n      CLD0\n      Cyclin-dependent kinase 2\n      267081\n      67782\n      =\n      ...\n      1\n      Ki\n      =\n      1.20\n      uM\n      NaN\n      NaN\n      HOKDXVAONYXHJK-UHFFFAOYSA-N\n      Cc1nc(C)c(s1)c2ccnc(Nc3ccccc3F)n2\n      CHEMBL297447\n    \n    \n      4\n      50641\n      17759\n      Inhibitory activity against human CDK2 (Cyclin...\n      NaN\n      CHEMBL658107\n      CLD0\n      Cyclin-dependent kinase 2\n      267084\n      67961\n      =\n      ...\n      1\n      Ki\n      =\n      0.11\n      uM\n      NaN\n      NaN\n      XNKSRGHGPSHYIW-UHFFFAOYSA-N\n      CNc1nc(C)c(s1)c2ccnc(Nc3cccc(O)c3)n2\n      CHEMBL44119\n    \n  \n\n5 rows × 28 columns\n\n\n\nWe pick a group of compounds by selecting all the rows with a given assay ID:\n\ndf_doc1 = df[df.assay_chembl_id=='CHEMBL827377']\nprint(len(df_doc1))\ndf_doc1.head()\n\n91\n\n\n\n\n\n\n  \n    \n      \n      assay_id\n      doc_id\n      description\n      assay_organism\n      assay_chembl_id\n      aidx\n      pref_name\n      activity_id\n      molregno\n      standard_relation\n      ...\n      src_id (#1)\n      type\n      relation\n      value\n      units\n      text_value\n      standard_text_value\n      standard_inchi_key\n      canonical_smiles\n      compound_chembl_id\n    \n  \n  \n    \n      47\n      302524\n      21080\n      Binding affinity for human cyclin-dependent ki...\n      Homo sapiens\n      CHEMBL827377\n      CLD0\n      Cyclin-dependent kinase 2\n      1438958\n      305637\n      >\n      ...\n      1\n      Ki\n      >\n      19.95\n      uM\n      NaN\n      NaN\n      TWQUOUJLNRGSRZ-UHFFFAOYSA-N\n      Cc1ccc2c(c3ccnc(Nc4cccc(c4)C(F)(F)F)n3)c(nn2n1...\n      CHEMBL182493\n    \n    \n      48\n      302524\n      21080\n      Binding affinity for human cyclin-dependent ki...\n      Homo sapiens\n      CHEMBL827377\n      CLD0\n      Cyclin-dependent kinase 2\n      1438962\n      305651\n      >\n      ...\n      1\n      Ki\n      >\n      19.95\n      uM\n      NaN\n      NaN\n      CYHPFZLFUXOCJJ-UHFFFAOYSA-N\n      Cc1ccc2c(c3ccnc(Nc4ccc(F)c(F)c4)n3)c(nn2n1)c5c...\n      CHEMBL182326\n    \n    \n      49\n      302524\n      21080\n      Binding affinity for human cyclin-dependent ki...\n      Homo sapiens\n      CHEMBL827377\n      CLD0\n      Cyclin-dependent kinase 2\n      1439061\n      305664\n      >\n      ...\n      1\n      Ki\n      >\n      19.95\n      uM\n      NaN\n      NaN\n      MYSOMHSTKVRJRA-UHFFFAOYSA-N\n      Cc1ccc2c(c3ccnc(Nc4ccc5OCCOc5c4)n3)c(nn2n1)c6c...\n      CHEMBL183064\n    \n    \n      50\n      302524\n      21080\n      Binding affinity for human cyclin-dependent ki...\n      Homo sapiens\n      CHEMBL827377\n      CLD0\n      Cyclin-dependent kinase 2\n      1439063\n      305674\n      >\n      ...\n      1\n      Ki\n      >\n      19.95\n      uM\n      NaN\n      NaN\n      VUGNSTAXWJUVEZ-UHFFFAOYSA-N\n      Cc1ccc2c(c3ccnc(Nc4ccc(Cl)c(c4)C(F)(F)F)n3)c(n...\n      CHEMBL361038\n    \n    \n      51\n      302524\n      21080\n      Binding affinity for human cyclin-dependent ki...\n      Homo sapiens\n      CHEMBL827377\n      CLD0\n      Cyclin-dependent kinase 2\n      1439065\n      305687\n      =\n      ...\n      1\n      Ki\n      =\n      3.98\n      uM\n      NaN\n      NaN\n      BWBMBCPGRIOUNV-UHFFFAOYSA-N\n      C1CC1c2nn3ncccc3c2c4ccnc(Nc5ccccc5)n4\n      CHEMBL362296\n    \n  \n\n5 rows × 28 columns\n\n\n\nLook at some of the compounds:\n\nrdDepictor.SetPreferCoordGen(True)\nsmis = df_doc1['canonical_smiles']\ncids = list(df_doc1.compound_chembl_id)\nms = [Chem.MolFromSmiles(x) for x in smis]\nfor m in ms:\n    rdDepictor.Compute2DCoords(m)\nDraw.MolsToGridImage(ms[:12],legends=cids,molsPerRow=4)\n\n\n\n\nDefine a core. I’m doing this manually and am only specifically labeling four of the seven R-groups in this set of molecules. The others will be labelled automatically by the RGD code.\n\ncore = Chem.MolFromSmiles('c1cc(-c2c([*:1])nn3nc([*:2])ccc23)nc(N(c2ccc([*:4])c([*:3])c2))n1')\nrdDepictor.SetPreferCoordGen(True)\nrdDepictor.Compute2DCoords(core)\ncore\n\n\n\n\nSome pre-processing work we need to do: - convert the dummy atoms in the scaffold into query atoms that match anything - add hydrogens to the molecules - select only the subset of molecules which match the core - set a property on each atom which is used to track its original index (we use this later in the RGD analysis)\n\nps = Chem.AdjustQueryParameters.NoAdjustments()\nps.makeDummiesQueries=True\nqcore = Chem.AdjustQueryProperties(core,ps)\nmhs = [Chem.AddHs(x,addCoords=True) for x in ms]\nmms = [x for x in mhs if x.HasSubstructMatch(qcore)]\nfor m in mms:\n    for atom in m.GetAtoms():\n        atom.SetIntProp(\"SourceAtomIdx\",atom.GetIdx())\nprint(len(mhs),len(mms))\n\n91 91\n\n\nNow do the actual RGD:\n\nrdkit.RDLogger.DisableLog('rdApp.warning')\ngroups,_ = rdRGroupDecomposition.RGroupDecompose([qcore],mms,asSmiles=False,asRows=True)\n\nThis is the function that actually does the work of generating aligned coordinates and creating the image with highlighted R groups\n\nfrom collections import defaultdict\n\ndef highlight_rgroups(mol,row,core,width=350,height=200,\n                      fillRings=True,legend=\"\",\n                      sourceIdxProperty=\"SourceAtomIdx\",\n                      lbls=('R1','R2','R3','R4')):\n    # copy the molecule and core\n    mol = Chem.Mol(mol)\n    core = Chem.Mol(core)\n\n    # -------------------------------------------\n    # include the atom map numbers in the substructure search in order to \n    # try to ensure a good alignment of the molecule to symmetric cores\n    for at in core.GetAtoms():\n        if at.GetAtomMapNum():\n            at.ExpandQuery(rdqueries.IsotopeEqualsQueryAtom(200+at.GetAtomMapNum()))\n            \n    for lbl in row:\n        if lbl=='Core':\n            continue\n        rg = row[lbl]\n        for at in rg.GetAtoms():\n            if not at.GetAtomicNum() and at.GetAtomMapNum() and \\\n            at.HasProp('dummyLabel') and at.GetProp('dummyLabel')==lbl:\n                # attachment point. the atoms connected to this\n                # should be from the molecule\n                for nbr in at.GetNeighbors():\n                    if nbr.HasProp(sourceIdxProperty):\n                        mAt = mol.GetAtomWithIdx(nbr.GetIntProp(sourceIdxProperty))\n                        if mAt.GetIsotope():\n                            mAt.SetIntProp('_OrigIsotope',mAt.GetIsotope())\n                        mAt.SetIsotope(200+at.GetAtomMapNum())\n    # remove unmapped hs so that they don't mess up the depiction\n    rhps = Chem.RemoveHsParameters()\n    rhps.removeMapped = False\n    tmol = Chem.RemoveHs(mol,rhps)\n    rdDepictor.GenerateDepictionMatching2DStructure(tmol,core)\n\n    oldNewAtomMap={}\n    # reset the original isotope values and account for the fact that\n    # removing the Hs changed atom indices\n    for i,at in enumerate(tmol.GetAtoms()):\n        if at.HasProp(sourceIdxProperty):\n            oldNewAtomMap[at.GetIntProp(sourceIdxProperty)] = i\n            if at.HasProp(\"_OrigIsotope\"):\n                at.SetIsotope(at.GetIntProp(\"_OrigIsotope\"))\n                at.ClearProp(\"_OrigIsotope\")\n            else:\n                at.SetIsotope(0)\n      \n    # ------------------\n    #  set up our colormap\n    #   the three choices here are all \"colorblind\" colormaps\n    \n    # \"Tol\" colormap from https://davidmathlogic.com/colorblind\n    colors = [(51,34,136),(17,119,51),(68,170,153),(136,204,238),(221,204,119),(204,102,119),(170,68,153),(136,34,85)]\n    # \"IBM\" colormap from https://davidmathlogic.com/colorblind\n    colors = [(100,143,255),(120,94,240),(220,38,127),(254,97,0),(255,176,0)]\n    # Okabe_Ito colormap from https://jfly.uni-koeln.de/color/\n    colors = [(230,159,0),(86,180,233),(0,158,115),(240,228,66),(0,114,178),(213,94,0),(204,121,167)]\n    for i,x in enumerate(colors):\n        colors[i] = tuple(y/255 for y in x)\n  \n    #----------------------\n    # Identify and store which atoms, bonds, and rings we'll be highlighting\n    highlightatoms = defaultdict(list)\n    highlightbonds = defaultdict(list)\n    atomrads = {}\n    widthmults = {}\n\n    rings = []\n    for i,lbl in enumerate(lbls):    \n        color = colors[i%len(colors)]\n        rquery = row[lbl]\n        Chem.GetSSSR(rquery)\n        rinfo = rquery.GetRingInfo()\n        for at in rquery.GetAtoms():\n            if at.HasProp(sourceIdxProperty):\n                origIdx = oldNewAtomMap[at.GetIntProp(sourceIdxProperty)]\n                highlightatoms[origIdx].append(color)\n                atomrads[origIdx] = 0.4\n        if fillRings:\n            for aring in rinfo.AtomRings():\n                tring = []\n                allFound = True\n                for aid in aring:\n                    at = rquery.GetAtomWithIdx(aid)\n                    if not at.HasProp(sourceIdxProperty):\n                        allFound = False\n                        break\n                    tring.append(oldNewAtomMap[at.GetIntProp(sourceIdxProperty)])\n                if allFound:\n                    rings.append((tring,color))\n        for qbnd in rquery.GetBonds():\n            batom = qbnd.GetBeginAtom()\n            eatom = qbnd.GetEndAtom()\n            if batom.HasProp(sourceIdxProperty) and eatom.HasProp(sourceIdxProperty):\n                origBnd = tmol.GetBondBetweenAtoms(oldNewAtomMap[batom.GetIntProp(sourceIdxProperty)],\n                                                 oldNewAtomMap[eatom.GetIntProp(sourceIdxProperty)])\n                bndIdx = origBnd.GetIdx()\n                highlightbonds[bndIdx].append(color)\n                widthmults[bndIdx] = 2\n\n    d2d = rdMolDraw2D.MolDraw2DCairo(width,height)\n    dos = d2d.drawOptions()\n    dos.useBWAtomPalette()\n                \n    #----------------------\n    # if we are filling rings, go ahead and do that first so that we draw\n    # the molecule on top of the filled rings\n    if fillRings and rings:\n        # a hack to set the molecule scale\n        d2d.DrawMoleculeWithHighlights(tmol,legend,dict(highlightatoms),\n                                       dict(highlightbonds),\n                                       atomrads,widthmults)\n        d2d.ClearDrawing()\n        conf = tmol.GetConformer()\n        for (aring,color) in rings:\n            ps = []\n            for aidx in aring:\n                pos = Geometry.Point2D(conf.GetAtomPosition(aidx))\n                ps.append(pos)\n            d2d.SetFillPolys(True)\n            d2d.SetColour(color)\n            d2d.DrawPolygon(ps)\n        dos.clearBackground = False\n\n    #----------------------\n    # now draw the molecule, with highlights:\n    d2d.DrawMoleculeWithHighlights(tmol,legend,dict(highlightatoms),dict(highlightbonds),\n                                   atomrads,widthmults)\n    d2d.FinishDrawing()\n    png = d2d.GetDrawingText()\n    return png\n\nInteractively try that out on all the molecules in our set:\n\n@interact(idx=range(0,len(ms)))\ndef draw_it(idx=0):\n    m = mms[idx]\n    row = groups[idx]\n    return Image(highlight_rgroups(m,row,qcore,lbls=('R1','R2','R3','R4')))\n\n\n\n\nIt would be cool to do see multiple molecules at once. Unforunately DrawMolsToGridImage() doesn’t support the multiple highlighting we’re doing here (we decided that the API for that would just be too complex; this may change in the future if we can figure out a sensible API for it), so we have to manually combine the images. Fortunately the pillow package makes that easy:\n\nfrom PIL import Image as pilImage\nfrom io import BytesIO\n\ndef draw_multiple(ms,groups,qcore,lbls,legends=None,nPerRow=4,subImageSize=(250,200)):\n    nRows = len(ms)//nPerRow\n    if len(ms)%nPerRow:\n        nRows+=1\n    nCols = nPerRow\n    imgSize = (subImageSize[0]*nCols,subImageSize[1]*nRows)\n    res = pilImage.new('RGB',imgSize)\n    \n    for i,m in enumerate(ms):\n        col = i%nPerRow\n        row = i//nPerRow\n        if legends:\n            legend = legends[i]\n        else:\n            legend = ''\n        png = highlight_rgroups(m,groups[i],qcore,lbls=lbls,legend=legend,\n                               width=subImageSize[0],height=subImageSize[1])\n        bio = BytesIO(png)\n        img = pilImage.open(bio)\n        res.paste(img,box=(col*subImageSize[0],row*subImageSize[1]))\n    bio = BytesIO()\n    res.save(bio,format='PNG')\n    return bio.getvalue()\n\nNow let’s look at the first 16 molecules in the dataset:\n\nImage(draw_multiple(mms[:16],groups,qcore,('R1','R2','R3','R4'),legends=cids,subImageSize=(300,250)))\n\n\n\n\nRepeat that analysis with the compounds from another document just to make sure we did everything sufficiently generally:\n\ndf_doc2 = df[df.assay_chembl_id=='CHEMBL658107']\nprint(len(df_doc2))\ndf_doc2.head()\n\n33\n\n\n\n\n\n\n  \n    \n      \n      assay_id\n      doc_id\n      description\n      assay_organism\n      assay_chembl_id\n      aidx\n      pref_name\n      activity_id\n      molregno\n      standard_relation\n      ...\n      src_id (#1)\n      type\n      relation\n      value\n      units\n      text_value\n      standard_text_value\n      standard_inchi_key\n      canonical_smiles\n      compound_chembl_id\n    \n  \n  \n    \n      0\n      50641\n      17759\n      Inhibitory activity against human CDK2 (Cyclin...\n      NaN\n      CHEMBL658107\n      CLD0\n      Cyclin-dependent kinase 2\n      265814\n      68026\n      >\n      ...\n      1\n      Ki\n      >\n      20.00\n      uM\n      NaN\n      NaN\n      RPXWUUDZINQPTJ-UHFFFAOYSA-N\n      CNc1nccc(n1)c2sc(C)nc2C\n      CHEMBL46474\n    \n    \n      1\n      50641\n      17759\n      Inhibitory activity against human CDK2 (Cyclin...\n      NaN\n      CHEMBL658107\n      CLD0\n      Cyclin-dependent kinase 2\n      265817\n      67880\n      =\n      ...\n      1\n      Ki\n      =\n      0.14\n      uM\n      NaN\n      NaN\n      GDZTURHUKDAJGD-UHFFFAOYSA-N\n      Cc1nc(C)c(s1)c2ccnc(Nc3ccc(O)cc3)n2\n      CHEMBL442957\n    \n    \n      2\n      50641\n      17759\n      Inhibitory activity against human CDK2 (Cyclin...\n      NaN\n      CHEMBL658107\n      CLD0\n      Cyclin-dependent kinase 2\n      267078\n      67751\n      =\n      ...\n      1\n      Ki\n      =\n      6.50\n      uM\n      NaN\n      NaN\n      CTFDMGIBHFQWKB-UHFFFAOYSA-N\n      Cc1nc(C)c(s1)c2ccnc(N)n2\n      CHEMBL47302\n    \n    \n      3\n      50641\n      17759\n      Inhibitory activity against human CDK2 (Cyclin...\n      NaN\n      CHEMBL658107\n      CLD0\n      Cyclin-dependent kinase 2\n      267081\n      67782\n      =\n      ...\n      1\n      Ki\n      =\n      1.20\n      uM\n      NaN\n      NaN\n      HOKDXVAONYXHJK-UHFFFAOYSA-N\n      Cc1nc(C)c(s1)c2ccnc(Nc3ccccc3F)n2\n      CHEMBL297447\n    \n    \n      4\n      50641\n      17759\n      Inhibitory activity against human CDK2 (Cyclin...\n      NaN\n      CHEMBL658107\n      CLD0\n      Cyclin-dependent kinase 2\n      267084\n      67961\n      =\n      ...\n      1\n      Ki\n      =\n      0.11\n      uM\n      NaN\n      NaN\n      XNKSRGHGPSHYIW-UHFFFAOYSA-N\n      CNc1nc(C)c(s1)c2ccnc(Nc3cccc(O)c3)n2\n      CHEMBL44119\n    \n  \n\n5 rows × 28 columns\n\n\n\n\nsmis = df_doc2['canonical_smiles']\ncids = list(df_doc2.compound_chembl_id)\nms = [Chem.MolFromSmiles(x) for x in smis]\nfor m in ms:\n    rdDepictor.Compute2DCoords(m)\nDraw.MolsToGridImage(ms[:12],legends=cids,molsPerRow=4)\n\n\n\n\n\ncore = Chem.MolFromSmiles('Cc1nc([*:3])sc1-c1ccnc(N([*:1])[*:2])n1')\nps = Chem.AdjustQueryParameters.NoAdjustments()\nps.makeDummiesQueries=True\nqcore = Chem.AdjustQueryProperties(core,ps)\nmhs = [Chem.AddHs(x,addCoords=True) for x in ms]\nmms = [x for x in mhs if x.HasSubstructMatch(qcore)]\nfor m in mms:\n    for atom in m.GetAtoms():\n        atom.SetIntProp(\"SourceAtomIdx\",atom.GetIdx())\nprint(len(mhs),len(mms))\nrdDepictor.SetPreferCoordGen(True)\nrdDepictor.Compute2DCoords(qcore)\nqcore\n\n33 33\n\n\n\n\n\n\nrdkit.RDLogger.DisableLog('rdApp.warning')\ngroups,_ = rdRGroupDecomposition.RGroupDecompose([qcore],mms,asSmiles=False,asRows=True)\n\n\n@interact(idx=range(0,len(mms)))\ndef draw_it(idx=0):\n    m = mms[idx]\n    row = groups[idx]\n    return Image(highlight_rgroups(m,row,qcore,lbls=('R1','R2','R3')))\n\n\n\n\n\nImage(draw_multiple(mms[:12],groups,qcore,('R1','R2','R3'),subImageSize=(300,250)))\n\n\n\n\n\ndf_doc3 = df[df.assay_chembl_id=='CHEMBL3101313']\nprint(len(df_doc3))\ndf_doc3.head()\n\n25\n\n\n\n\n\n\n  \n    \n      \n      assay_id\n      doc_id\n      description\n      assay_organism\n      assay_chembl_id\n      aidx\n      pref_name\n      activity_id\n      molregno\n      standard_relation\n      ...\n      src_id (#1)\n      type\n      relation\n      value\n      units\n      text_value\n      standard_text_value\n      standard_inchi_key\n      canonical_smiles\n      compound_chembl_id\n    \n  \n  \n    \n      1129\n      1281340\n      76402\n      Displacement of B-Alexa-Fluor647 from CDK2 (un...\n      Homo sapiens\n      CHEMBL3101313\n      CLD0\n      Cyclin-dependent kinase 2\n      13859835\n      1610535\n      <\n      ...\n      1\n      Ki\n      <\n      0.10\n      uM\n      NaN\n      NaN\n      USOUMMYIFYDJEI-ZZTDINLMSA-N\n      COC[C@H](Cc1ccc(O)cc1)NC(=O)c2cc(C(=O)O)c3cc(\\...\n      CHEMBL3099753\n    \n    \n      1130\n      1281340\n      76402\n      Displacement of B-Alexa-Fluor647 from CDK2 (un...\n      Homo sapiens\n      CHEMBL3101313\n      CLD0\n      Cyclin-dependent kinase 2\n      13859836\n      1610534\n      =\n      ...\n      1\n      Ki\n      =\n      0.10\n      uM\n      NaN\n      NaN\n      DLJWCYCMLMVSML-FQEVSTJZSA-N\n      COC[C@H](Cc1ccc(O)cc1)NC(=O)c2cc(C(=O)O)c3cc(c...\n      CHEMBL3099752\n    \n    \n      1131\n      1281340\n      76402\n      Displacement of B-Alexa-Fluor647 from CDK2 (un...\n      Homo sapiens\n      CHEMBL3101313\n      CLD0\n      Cyclin-dependent kinase 2\n      13859837\n      1610533\n      =\n      ...\n      1\n      Ki\n      =\n      0.16\n      uM\n      NaN\n      NaN\n      BHBDKGIDYKROMY-BAJJQUEBSA-N\n      CN(C)C(=O)[C@H](Cc1ccc(O)cc1)NC(=O)c2cc(C(=O)O...\n      CHEMBL3099751\n    \n    \n      1132\n      1281340\n      76402\n      Displacement of B-Alexa-Fluor647 from CDK2 (un...\n      Homo sapiens\n      CHEMBL3101313\n      CLD0\n      Cyclin-dependent kinase 2\n      13859838\n      1610532\n      =\n      ...\n      1\n      Ki\n      =\n      0.10\n      uM\n      NaN\n      NaN\n      IYRLCOILNQBJEJ-ZNOKPGKASA-N\n      CNC(=O)[C@H](Cc1ccc(O)cc1)NC(=O)c2cc(C(=O)O)c3...\n      CHEMBL3099750\n    \n    \n      1133\n      1281340\n      76402\n      Displacement of B-Alexa-Fluor647 from CDK2 (un...\n      Homo sapiens\n      CHEMBL3101313\n      CLD0\n      Cyclin-dependent kinase 2\n      13859839\n      1610531\n      =\n      ...\n      1\n      Ki\n      =\n      0.30\n      uM\n      NaN\n      NaN\n      DDIHZTFUIFPFOO-OAQYLSRUSA-N\n      CCC[C@H](Cc1ccc(O)cc1)NC(=O)c2cc(C(=O)O)c3cc(c...\n      CHEMBL3099749\n    \n  \n\n5 rows × 28 columns\n\n\n\nFinally, do another document, just because it’s fun. :-)\n\nsmis = df_doc3['canonical_smiles']\ncids = list(df_doc3.compound_chembl_id)\nms = [Chem.MolFromSmiles(x) for x in smis]\nfor m in ms:\n    rdDepictor.Compute2DCoords(m)\nDraw.MolsToGridImage(ms[:12],legends=cids,molsPerRow=4)\n\n\n\n\n\ncore = Chem.MolFromSmiles('OC(=O)c1cc(C(=O)NC(C[*:1])[*:2])nc2ccc([*:3])cc12')\nps = Chem.AdjustQueryParameters.NoAdjustments()\nps.makeDummiesQueries=True\nqcore = Chem.AdjustQueryProperties(core,ps)\nmhs = [Chem.AddHs(x,addCoords=True) for x in ms]\nmms = [x for x in mhs if x.HasSubstructMatch(qcore)]\nfor m in mms:\n    for atom in m.GetAtoms():\n        atom.SetIntProp(\"SourceAtomIdx\",atom.GetIdx())\nprint(len(mhs),len(mms))\nrdDepictor.SetPreferCoordGen(True)\nrdDepictor.Compute2DCoords(qcore)\nqcore\n\n25 22\n\n\n\n\n\n\nrdkit.RDLogger.DisableLog('rdApp.warning')\ngroups,_ = rdRGroupDecomposition.RGroupDecompose([qcore],mms,asSmiles=False,asRows=True)\n\n\n@interact(idx=range(0,len(mms)))\ndef draw_it(idx=0):\n    m = mms[idx]\n    row = groups[idx]\n    return Image(highlight_rgroups(m,row,qcore,lbls=('R1','R2','R3')))\n\n\n\n\n\nImage(draw_multiple(mms[:12],groups,qcore,('R1','R2','R3'),subImageSize=(300,250)))"
  },
  {
    "objectID": "posts/2021-07-24-setting-up-a-cxx-dev-env.html",
    "href": "posts/2021-07-24-setting-up-a-cxx-dev-env.html",
    "title": "Using the RDKit in a C++ program",
    "section": "",
    "text": "Note: the instructions in this blog post currently only work on linux systems. There’s a configuration problem with the way we use cmake on the Mac and Windows that needs to be cleared up. I will update the post after that’s done.\nLast week I (re)discoverered that it’s pretty easy to use the RDKit in other C++ projects. This is obviously somthing that’s possible, but I thought of it as being something of a pain. It turns out that it’s not, as I hope to show you in this post.\nI started by setting up a fresh conda environment and grabbing an RDKit build from conda-forge, this is a bit heavyweight since you end up with a bunch of python packages as well as the RDKit itself (I’m going to look into making this more minimal), but it’s much easier than doing your own build.\nThe first thing is to set up a conda environment:\nconda create -n rdkit_dev\nconda activate rdkit_dev\nconda install -c conda-forge mamba\nmamba install -c conda-forge cmake rdkit eigen\nNote: I start by installing mamba here because it makes doing conda installs much, much faster.\nHere’s a simple demo program which reads in a set of molecules from an input file and generates tautomer hashes for them. It uses the boost::timer library in order to separately time how long it takes to read the molecules and generate the hashes. I called this file tautomer_hash.cpp:\n#include <GraphMol/FileParsers/MolSupplier.h>\n#include <GraphMol/MolHash/MolHash.h>\n#include <GraphMol/RDKitBase.h>\n#include <RDGeneral/RDLog.h>\n#include <algorithm>\n#include <boost/timer/timer.hpp>\n#include <iostream>\n#include <vector>\n\nusing namespace RDKit;\n\nvoid readmols(std::string pathName, unsigned int maxToDo,\n              std::vector<RWMOL_SPTR> &mols) {\n  boost::timer::auto_cpu_timer t;\n  // using a supplier without sanitizing the molecules...\n  RDKit::SmilesMolSupplier suppl(pathName, \" \\t\", 1, 0, true, false);\n  unsigned int nDone = 0;\n  while (!suppl.atEnd() && (maxToDo <= 0 || nDone < maxToDo)) {\n    RDKit::ROMol *m = suppl.next();\n    if (!m) {\n      continue;\n    }\n    m->updatePropertyCache();\n    // the tautomer hash code uses conjugation info\n    MolOps::setConjugation(*m);\n    nDone += 1;\n    mols.push_back(RWMOL_SPTR((RWMol *)m));\n  }\n  std::cerr << \"read: \" << nDone << \" mols.\" << std::endl;\n}\n\nvoid generatehashes(const std::vector<RWMOL_SPTR> &mols) {\n  boost::timer::auto_cpu_timer t;\n  for (auto &mol : mols) {\n    auto hash =\n        MolHash::MolHash(mol.get(), MolHash::HashFunction::HetAtomTautomer);\n  }\n}\nint main(int argc, char *argv[]) {\n  RDLog::InitLogs();\n  std::vector<RWMOL_SPTR> mols;\n  BOOST_LOG(rdInfoLog) << \"read mols\" << std::endl;\n\n  readmols(argv[1], 10000, mols);\n  BOOST_LOG(rdInfoLog) << \"generate hashes\" << std::endl;\n  generatehashes(mols);\n\n  BOOST_LOG(rdInfoLog) << \"done \" << std::endl;\n}\nThis is a pretty crappy program since it doesn’t do much error checking, but the purpose here is to demonstrate how to get the environment setup, not to teach how to write nice C++ programs. :-)\nThe way to make the build easy is to use cmake to set everything up, so I need a CMakeLists.txt file that defines my executable and its RDKit dependencies:\ncmake_minimum_required(VERSION 3.18)\n\nproject(simple_cxx_example)\nset(CMAKE_CXX_STANDARD 14)\nset(CMAKE_CXX_STANDARD_REQUIRED True)\n\n\nfind_package(RDKit REQUIRED)\nfind_package(Boost COMPONENTS timer system REQUIRED)\nadd_executable(tautomer_hash tautomer_hash.cpp)\ntarget_link_libraries(tautomer_hash RDKit::SmilesParse RDKit::MolHash\n   Boost::timer)\nThis tells cmake to find the RDKit and boost installs (which “just works” since cmake, boost, and the RDKit were all installed from conda), defines the executable I want to create, and then lists the RDKit and boost libraries I use. And that is pretty much that.\nNow I create a build dir, run cmake to setup the build, and run make to actually build my program:\n(rdkit_dev) glandrum@Badger:~/RDKit_blog/src/simple_cxx_example$ mkdir build\n(rdkit_dev) glandrum@Badger:~/RDKit_blog/src/simple_cxx_example$ cd build\n(rdkit_dev) glandrum@Badger:~/RDKit_blog/src/simple_cxx_example/build$ cmake ..\n-- The C compiler identification is GNU 9.3.0\n-- The CXX compiler identification is GNU 9.3.0\n-- Detecting C compiler ABI info\n-- Detecting C compiler ABI info - done\n-- Check for working C compiler: /usr/bin/cc - skipped\n-- Detecting C compile features\n-- Detecting C compile features - done\n-- Detecting CXX compiler ABI info\n-- Detecting CXX compiler ABI info - done\n-- Check for working CXX compiler: /usr/bin/c++ - skipped\n-- Detecting CXX compile features\n-- Detecting CXX compile features - done\n-- Looking for pthread.h\n-- Looking for pthread.h - found\n-- Performing Test CMAKE_HAVE_LIBC_PTHREAD\n-- Performing Test CMAKE_HAVE_LIBC_PTHREAD - Failed\n-- Looking for pthread_create in pthreads\n-- Looking for pthread_create in pthreads - not found\n-- Looking for pthread_create in pthread\n-- Looking for pthread_create in pthread - found\n-- Found Threads: TRUE  \n-- Found Boost: /home/glandrum/miniconda3/envs/rdkit_dev/lib/cmake/Boost-1.74.0/BoostConfig.cmake (found suitable version \"1.74.0\", minimum required is \"1.74.0\")  \n-- Found Boost: /home/glandrum/miniconda3/envs/rdkit_dev/lib/cmake/Boost-1.74.0/BoostConfig.cmake (found version \"1.74.0\") found components: timer system \n-- Configuring done\n-- Generating done\n-- Build files have been written to: /home/glandrum/RDKit_blog/src/simple_cxx_example/build\n(rdkit_dev) glandrum@Badger:~/RDKit_blog/src/simple_cxx_example/build$ make tautomer_hash\n[ 50%] Building CXX object CMakeFiles/tautomer_hash.dir/tautomer_hash.cpp.o\n[100%] Linking CXX executable tautomer_hash\n[100%] Built target tautomer_hash\nAnd now I can run the program:\n(rdkit_dev) glandrum@Badger:~/RDKit_blog/src/simple_cxx_example/build$ ./tautomer_hash /scratch/RDKit_git/Code/Profiling/GraphMol/chembl23_very_active.txt\n[07:51:33] read mols\nread: 10000 mols.\n 0.819242s wall, 0.740000s user + 0.070000s system = 0.810000s CPU (98.9%)\n[07:51:33] generate hashes\n 0.872662s wall, 0.870000s user + 0.010000s system = 0.880000s CPU (100.8%)\n[07:51:34] done \n(rdkit_dev) glandrum@Badger:~/RDKit_blog/src/simple_cxx_example/build$ \nIf you don’t feel like copy/pasting, the source files for this post are available from github.\nThis all works so nicely because of the time and effort Riccardo Vianello invested a few years ago to improve the RDKit’s cmake integration.\nNext step: add this to the documentation!"
  },
  {
    "objectID": "posts/2021-05-26-similarity-threshold-observations1.html",
    "href": "posts/2021-05-26-similarity-threshold-observations1.html",
    "title": "Some observations about similarity search thresholds",
    "section": "",
    "text": "Updated 08.06.2021 after I expanded the set of “related compounds”. The source of the previous version of the post is available in github. The updates didn’t change the discussion that much.\n\nTL;DR\nBased on the analysis here it looks like the fingerprint the RDKit provides which does the best job of efficiently retrieving chemically similar structures is the RDKit fingerprint with maxPath set to 6.\n\n\nIntro / Results\nI recently did a post presenting an approach for finding reasonable thresholds for similarity searches using the fingerprints the RDKit provides. This is a followup to that one written after I’ve done some more looking at the data. I want to come up with a suggestion for which fingerprint to use for similarity searches when the goal is retrieving as many chemically related compounds as possible. I’ll do that by looking at search efficiency as measured by the fraction of the total database retrieved when using similarity thresholds sufficient to return 90-95% of the related compounds. See the earlier post for an explanation of what “related compounds” means here and how the searches were done.\nAs a reminder, this is how I presented the results in that post and how to interpret the data:\n\n\n\n\n\n\n\n\n0.95 of related compounds\n\n\n0.9 of related compounds\n\n\n0.8 of related compounds\n\n\n0.5 of related compounds\n\n\n\n\nFingerprint\n\n\n0.95 noise level\n\n\nthreshold\n\n\ndb fraction / count per million\n\n\nthreshold\n\n\ndb fraction / count per million\n\n\nthreshold\n\n\ndb fraction / count per million\n\n\nthreshold\n\n\ndb fraction / count per million\n\n\n\n\nMorgan2 (bits)\n\n\n0.27\n\n\n0.4\n\n\n0.00019 / 190\n\n\n0.4\n\n\n0.00019 / 190\n\n\n0.45\n\n\n0.00012 / 115\n\n\n0.55\n\n\n2.5e-05 / 25\n\n\n\n\nThe 0.95 noise level (from the previous analysis) for the MFP2 fingerprint is 0.27. If I want to retrieve 95% of the related compounds I need to set the similarity threshold to 0.4. With this threshold I would retrieve ~190 compounds per million compounds in the database (0.4% of the database). Similarly, if I were willing to live with finding 50% of the related actives I could set the search threshold to 0.55, in which case I’d only retrieve ~25 rows per million compounds in the database.\nI won’t reproduce the full results table from the post here, but here are the rows with the highest search efficiencies (lowest number of compounds returned from the “background database”) at 90% and 95% of related compounds found. I sorted the table by the efficiency at 90% of related compounds retrieved:\n\n\n\n\n\n\n\n\n0.95 of related compounds\n\n\n0.9 of related compounds\n\n\n0.8 of related compounds\n\n\n0.5 of related compounds\n\n\n\n\nFingerprint\n\n\n0.95 noise level\n\n\nthreshold\n\n\ndb fraction / count per million\n\n\nthreshold\n\n\ndb fraction / count per million\n\n\nthreshold\n\n\ndb fraction / count per million\n\n\nthreshold\n\n\ndb fraction / count per million\n\n\n\n\nRDKit 7 (bits)\n\n\n0.43\n\n\n0.55\n\n\n0.00051 / 510\n\n\n0.6\n\n\n8e-05 / 80\n\n\n0.6\n\n\n8e-05 / 80\n\n\n0.7\n\n\n3e-05 / 30\n\n\n\n\nTopological Torsions (counts)\n\n\n0.19\n\n\n0.35\n\n\n0.00049 / 489\n\n\n0.4\n\n\n0.00011 / 110\n\n\n0.45\n\n\n7.5e-05 / 75\n\n\n0.55\n\n\n2.5e-05 / 25\n\n\n\n\nlinear RDKit 7 (bits)\n\n\n0.26\n\n\n0.45\n\n\n0.00053 / 535\n\n\n0.5\n\n\n0.00013 / 130\n\n\n0.55\n\n\n9e-05 / 90\n\n\n0.65\n\n\n3.5e-05 / 35\n\n\n\n\nRDKit 6 (bits)\n\n\n0.31\n\n\n0.5\n\n\n0.00021 / 210\n\n\n0.55\n\n\n0.00014 / 135\n\n\n0.6\n\n\n6e-05 / 60\n\n\n0.7\n\n\n3e-05 / 30\n\n\n\n\nMorgan2 (counts)\n\n\n0.25\n\n\n0.4\n\n\n0.00014 / 140\n\n\n0.4\n\n\n0.00014 / 140\n\n\n0.45\n\n\n8.5e-05 / 84\n\n\n0.55\n\n\n2e-05 / 20\n\n\n\n\nAvalon 1024 (bits)\n\n\n0.37\n\n\n0.55\n\n\n0.00075 / 750\n\n\n0.6\n\n\n0.00014 / 140\n\n\n0.65\n\n\n9e-05 / 90\n\n\n0.75\n\n\n2.5e-05 / 25\n\n\n\n\nMorgan3 (counts)\n\n\n0.20\n\n\n0.3\n\n\n0.00026 / 260\n\n\n0.35\n\n\n0.00015 / 154\n\n\n0.35\n\n\n0.00015 / 154\n\n\n0.45\n\n\n3.5e-05 / 35\n\n\n\n\nRDKit 5 (bits)\n\n\n0.29\n\n\n0.5\n\n\n0.00025 / 250\n\n\n0.55\n\n\n0.00016 / 155\n\n\n0.6\n\n\n6e-05 / 60\n\n\n0.7\n\n\n3e-05 / 30\n\n\n\n\nTopological Torsions (bits)\n\n\n0.22\n\n\n0.4\n\n\n0.00016 / 160\n\n\n0.4\n\n\n0.00016 / 160\n\n\n0.45\n\n\n0.00011 / 105\n\n\n0.55\n\n\n3.5e-05 / 35\n\n\n\n\nMorgan2 (bits)\n\n\n0.27\n\n\n0.4\n\n\n0.00019 / 190\n\n\n0.4\n\n\n0.00019 / 190\n\n\n0.45\n\n\n0.00012 / 115\n\n\n0.55\n\n\n2.5e-05 / 25\n\n\n\n\nFeatMorgan3 (counts)\n\n\n0.28\n\n\n0.4\n\n\n0.00022 / 220\n\n\n0.4\n\n\n0.00022 / 220\n\n\n0.45\n\n\n0.00013 / 130\n\n\n0.55\n\n\n3e-05 / 30\n\n\n\n\nlinear RDKit 6 (bits)\n\n\n0.28\n\n\n0.5\n\n\n0.00022 / 220\n\n\n0.5\n\n\n0.00022 / 220\n\n\n0.55\n\n\n0.00014 / 140\n\n\n0.7\n\n\n3e-05 / 30\n\n\n\n\nThe threshold values are rounded to the nearest 0.05.\nI’ve included count-based fingerprints in the above table, but they wouldn’t be my first choice for use in a real-world similarity search application. Calculating similarity for count-based fingerprints is significantly slower than bit vector fingerprints, so they really aren’t practical for large datasets. Note that the RDKit has a method for approximating counts using bit vector fingerprints which is used by the Atom Pair and Topological Torsion fingeprints and could also be an option for the other fingerprint types, but that’s a topic for another post.\nBased on these numbers (and, of course, the dataset I used) it looks like the RDKit fingerprint is the optimal choice for chemical similarity search. Taking the efficiency at both 90% and 95% into account, the version of the fingerprint with maxPath=6 is arguably better than the version with maxPath=7 (which is the default). There’s not a publication for the RDKit fingerprint but it is described in detail in the RDKit documentation.\nThe Morgan3 fingerprint, which is what I kind of expected to be the best at this task, doesn’t do that well - the bit-vector based form didn’t even make this list of top performaers. The Morgan2 fingerprint, on the other hand, seems like another good choice. The Morgan fingerprints are the RDKit’s implementation of the circular fingerprints described in this publication.\nA real surprise to me was how well the topological torsions fingerprint does at this chemical search. I had (I guess without much evidence) thought of it as more of a fuzzy (or “scaffold-hopping”) fingerprint, but the high efficiency on this chemical search problem makes me reconsider that. Topological torsions were introduced in this publication.\nThe Avalon fingerprint seems to be another decent choice, at least at 90%. This isn’t surprising to me, but I’ll probably remain resistant to making heavy of it due to the complexity of the fingerprint itself. The only non-code description I’m aware of for the Avalon FP is in the supplementary material for this paper; it’s likely that the current version of the fingerprint, which was under active development for at least 10 years after that paper appeared, deviates from that.\nBefore getting any deeper into details with this kind of analysis, I think I would like to look into using more than 10K of the “related” molecules and increasing the size of the background database just to make sure the statistics are solid. I’ll do that in a separate post and leave the count-based fingerprints out."
  },
  {
    "objectID": "posts/2021-12-23-ternary-ghost.html",
    "href": "posts/2021-12-23-ternary-ghost.html",
    "title": "A Ternary GHOST",
    "section": "",
    "text": "When we published the GHOST paper on shifting the decision boundary to improve the predictive performance of classification models built on imbalanced datasets, we only considered binary classifiers (e.g. active/inactive, soluble/insoluble, etc.). I was recently asked if the method could be extended to ternary (three-class) classifiers. This post is about doing that.\nThe code here isn’t set up for easy re-use at the moment. It will eventually find its way into the open-source ghostml package once we’ve had a chance to review and test it more thoroughly.\n\nAside: the ghostml package is now pip installable: python -m pip install ghostml to install it in your environment\n\nIn order for this to make sense, I think I should start with some explanation of the way I’ve approached the problem:\n\n\nThings are a bit more complicated here than with binary classifiers. For the binary case we just have a single threshold which determines whether an instance is predicted to be in class 0 or 1. So, assuming that we optimized based on the probability of class 1, we can formulate the decision as:\nif probabilities[1] >= threshold:\n   prediction = 1\nelse:\n   prediction = 0\nBefore doing any optimization threshold is equal to 0.5.\nFor ternary predictions we have two different decision boundaries and there’s no longer a simple threshold; instead the default decision rule can be expressed as:\nprediction = argmax(probabilities)\ni.e., the prediction is the class which has the highest predicted probability.\n\nAside: the same decision rule can be used for a binary classifier with the default threshold. It’s just easier to explain using the threshold of 0.5.\n\nIf we want to introduce two thresholds for the ternary classifier, and assuming that we optimize the thresholds for classes 0 and 2, we have to use a more complex decision rule:\n        if probabilities[0]>=thresholds[0]:\n            # we might still be in class 2 if the relative probability of that\n            # is larger than the probability of class 0\n            if (probabilities[2]-thresholds[1])>(probabilities[0]-thresholds[0]):\n                prediction = 2\n            else:\n                prediction = 0\n        elif probabilities[2]>=thresholds[1]:\n            prediction = 0\n        else:\n            prediction = 1\n\n\n\nFor the sake of this post let’s assume that we’re optimizing the thresholds for classes 0 and 2; we could also do 0 and 1, or 1 and 2, the results should still be the same.\nIn this post I explore two different approaches for optimizing these thresholds.\n\n\nHere I optimize the two thresholds independently of each other by constructing two binary classification problems and optimizing the thresholds for those problems. Here’s the process:\n\nCreate a binary classification set by setting the training-set y values to 1 if the original value is 0 and to 0 otherwise.\nUse the original ghostml approach with that binary classification data and the predicted probabilities of each training point to be 0 in order to set threshold0, the threshold for the predicted probability of being 0.\nCreate a binary classification set by setting the training-set y values to 1 if the original value is 2 and to 0 otherwise.\nUse the original ghostml approach with that binary classification data and the predicted probabilities of each training point to be 2 in order to set threshold2, the threshold for the predicted probability of being 2.\n\nSince the current ghostml code doesn’t support using balanced accuracy for optimization, I just use kappa for the greedy optimization.\n\n\n\nExplore the full grid of possible (threshold0, threshold2) pairs and pick the one which produces the optimal Cohen’s kappa value. I also try a variant of this which optimizes balanced accuracy instead of Cohen’s kappa.\n\n\n\n\nBoth approaches work well with both simulated data and a couple of datasets from ChEMBL. There doesn’t seem to be a large or consistent difference in the quality of the results generated with the two different methods. The greedy optimization approach is, however, quite a bit faster.\nHere’s the improvement in three scoring metrics (kappa, balanced accuracy, and overall accuracy) when using the greedy optimization procedure on 50 simulated datasets with a 10-80-10 class split; the threshold shift improves both kappa and balanced accuracy on all datasets:\n\nAnd here’s the same plot for 20 different random stratified train/tests splits with target CHEMBL205 (carbonic anhydrase II) with activity thresholds chosen to give a 19-72-9 class split. Once again, the threshold shift improves predictive performance:\n\nNote: the original version of this notebook and the two CHEMBL data files (file1, file2), are both in github in the older rdkit blog repo.\n\n\n\nI put some thought into figuring out how to extend this to the general multi-class prediction case, but that turned out to be more difficult than I’d anticipated. If you have suggestions, ideally suggestions accompanied by code, please let me know in the comments!\n\n\n\nMany thanks to Ryo Kunimoto and Takayuki Serizawa at Daiichi Sankyo for inspiring and funding the initial part of this work.\nAnd now onto the code and more detailed exploration\n\nfrom rdkit import Chem\nfrom rdkit.Chem import rdMolDescriptors\nfrom rdkit.Chem import rdFingerprintGenerator\nfrom rdkit.Chem import PandasTools\n# note that you can install ghost using pip: python -m pip install ghostml\nimport ghostml\nimport pandas as pd\nfrom sklearn import metrics\nimport numpy as np\n\n\n%pylab inline\n\nPopulating the interactive namespace from numpy and matplotlib"
  },
  {
    "objectID": "posts/2021-12-23-ternary-ghost.html#try-a-10-80-10-split",
    "href": "posts/2021-12-23-ternary-ghost.html#try-a-10-80-10-split",
    "title": "A Ternary GHOST",
    "section": "Try a 10-80-10 split",
    "text": "Try a 10-80-10 split\nI will test this with multiple different forms of imbalance, just to be sure that it generalizes. Let’s start with an example where the majority class is in the middle:\n\nfrom sklearn.datasets import make_classification\n\naccum_10_80_10 = []\n\nfor rep in range(50):\n    print('--------------')\n    # Generate a ternary imbalanced classification problem\n    X, y = make_classification(n_samples=6000, n_features=20,\n                               n_informative=10, n_redundant=0, n_classes=3, \n                               random_state=0xf00d+rep, shuffle=False, weights = [0.1, 0.8, 0.1])\n    run_ternary_experiment(X,y,accum_10_80_10)\n\nStart by comparing the model-performance metrics kappa, balanced accuracy, and accuracy between the model with the greedy threshold shift based on kappa and the model with “default thresholds”.\n\naccum = accum_10_80_10\nfigsize(9,6)\nscatter([x['orig-kappa'] for x in accum],[x['shift-kappa'] for x in accum],label='kappa');\nscatter([x['orig-balanced'] for x in accum],[x['shift-balanced'] for x in accum],label='balanced accuracy');\nscatter([x['orig-accuracy'] for x in accum],[x['shift-accuracy'] for x in accum],label='accuracy');\nplot([.4,1],[.4,1]);\nlegend();\nxlabel('orig')\nylabel('greedy shift');\ntitle('10-80-10');\n\n\n\n\nThe shift improves all three metrics for every dataset.\nNow compare the results for using a grid search based on Cohen’s kappa to the greedy shift results:\n\nscatter([x['shift-kappa'] for x in accum],[x['global-k-shift-kappa'] for x in accum],label='kappa');\nscatter([x['shift-balanced'] for x in accum],[x['global-k-shift-balanced'] for x in accum],label='balanced accuracy');\nscatter([x['shift-accuracy'] for x in accum],[x['global-k-shift-accuracy'] for x in accum],label='accuracy');\nplot([.4,1],[.4,1]);\nlegend();\nxlabel('greedy shift')\nylabel('grid-kappa');\ntitle('10-80-10');\n\n\n\n\nHere the changes are reasonably small, but they do tend to slightly favor the results of the grid search.\nFinally, do the equivalent plot comparing the result from using balanced accuracy in the grid search to the results from the greedy shift:\n\nscatter([x['shift-kappa'] for x in accum],[x['global-ba-shift-kappa'] for x in accum],label='kappa');\nscatter([x['shift-balanced'] for x in accum],[x['global-ba-shift-balanced'] for x in accum],label='balanced accuracy');\nscatter([x['shift-accuracy'] for x in accum],[x['global-ba-shift-accuracy'] for x in accum],label='accuracy');\nplot([.4,1],[.4,1]);\nlegend();\nxlabel('greedy shift')\nylabel('grid-balanced');\ntitle('10-80-10');\n\n\n\n\nThat plot makes it look like doing the threshold shifts using balanced accuracy doesn’t improve kappa, but it’s important to remember that this comparing the balanced accuracy shift vs the kappa shift.\nUsing balanced accuracy to do the shift instead of kappa does actually help kappa too, as this plot shows:\n\nscatter([x['orig-kappa'] for x in accum],[x['global-ba-shift-kappa'] for x in accum],label='kappa');\nscatter([x['orig-balanced'] for x in accum],[x['global-ba-shift-balanced'] for x in accum],label='balanced accuracy');\nscatter([x['orig-accuracy'] for x in accum],[x['global-ba-shift-accuracy'] for x in accum],label='accuracy');\nplot([.4,1],[.4,1]);\nlegend();\nxlabel('orig')\nylabel('grid-balanced');\ntitle('10-80-10');\n\n\n\n\nStill, with these datasets it looks like optimizing the threshold with kappa instead of balanced accuracy is a better idea."
  },
  {
    "objectID": "posts/2021-12-23-ternary-ghost.html#is-the-majority-class",
    "href": "posts/2021-12-23-ternary-ghost.html#is-the-majority-class",
    "title": "A Ternary GHOST",
    "section": "0 is the majority class",
    "text": "0 is the majority class\nNow let’s make sure that the code doesn’t have some “feature” which causes it to only work with the middle class is the majority:\n\naccum_80_10_10 = []\n\nfor rep in range(50):\n    print('--------------')\n    # Generate a ternary imbalanced classification problem\n    X, y = make_classification(n_samples=6000, n_features=20,\n                               n_informative=10, n_redundant=0, n_classes=3, \n                               random_state=0xf00d+rep, shuffle=False, weights = [0.8, 0.1, 0.1])\n    run_ternary_experiment(X,y,accum_80_10_10)\n\n\naccum = accum_80_10_10\nfigsize(9,6)\nscatter([x['orig-kappa'] for x in accum],[x['shift-kappa'] for x in accum],label='kappa');\nscatter([x['orig-balanced'] for x in accum],[x['shift-balanced'] for x in accum],label='balanced accuracy');\nscatter([x['orig-accuracy'] for x in accum],[x['shift-accuracy'] for x in accum],label='accuracy');\nplot([.4,1],[.4,1]);\nlegend();\nxlabel('orig')\nylabel('greedy shift');\ntitle('80-10-10');\n\n\n\n\n\nscatter([x['shift-kappa'] for x in accum],[x['global-k-shift-kappa'] for x in accum],label='kappa');\nscatter([x['shift-balanced'] for x in accum],[x['global-k-shift-balanced'] for x in accum],label='balanced accuracy');\nscatter([x['shift-accuracy'] for x in accum],[x['global-k-shift-accuracy'] for x in accum],label='accuracy');\nplot([.4,1],[.4,1]);\nlegend();\nxlabel('greedy shift')\nylabel('grid-kappa');\ntitle('80-10-10');\n\n\n\n\n\nscatter([x['shift-kappa'] for x in accum],[x['global-ba-shift-kappa'] for x in accum],label='kappa');\nscatter([x['shift-balanced'] for x in accum],[x['global-ba-shift-balanced'] for x in accum],label='balanced accuracy');\nscatter([x['shift-accuracy'] for x in accum],[x['global-ba-shift-accuracy'] for x in accum],label='accuracy');\nplot([.4,1],[.4,1]);\nlegend();\nxlabel('greedy shift')\nylabel('grid-balanced');\ntitle('80-10-10');\n\n\n\n\nSame conclusions as before (good thing!)"
  },
  {
    "objectID": "posts/2021-12-23-ternary-ghost.html#is-the-majority-class-1",
    "href": "posts/2021-12-23-ternary-ghost.html#is-the-majority-class-1",
    "title": "A Ternary GHOST",
    "section": "2 is the majority class",
    "text": "2 is the majority class\n\naccum_10_10_80 = []\n\nfor rep in range(50):\n    print('--------------')\n    # Generate a ternary imbalanced classification problem\n    X, y = make_classification(n_samples=6000, n_features=20,\n                               n_informative=10, n_redundant=0, n_classes=3, \n                               random_state=0xf00d+rep, shuffle=False, weights = [0.1, 0.1, 0.8])\n    run_ternary_experiment(X,y,accum_10_10_80)\n\n\naccum = accum_10_10_80\nfigsize(9,6)\nscatter([x['orig-kappa'] for x in accum],[x['shift-kappa'] for x in accum],label='kappa');\nscatter([x['orig-balanced'] for x in accum],[x['shift-balanced'] for x in accum],label='balanced accuracy');\nscatter([x['orig-accuracy'] for x in accum],[x['shift-accuracy'] for x in accum],label='accuracy');\nplot([.4,1],[.4,1]);\nlegend();\nxlabel('orig')\nylabel('greedy shift');\ntitle('10-10-80');\n\n\n\n\n\nscatter([x['shift-kappa'] for x in accum],[x['global-k-shift-kappa'] for x in accum],label='kappa');\nscatter([x['shift-balanced'] for x in accum],[x['global-k-shift-balanced'] for x in accum],label='balanced accuracy');\nscatter([x['shift-accuracy'] for x in accum],[x['global-k-shift-accuracy'] for x in accum],label='accuracy');\nplot([.4,1],[.4,1]);\nlegend();\nxlabel('greedy shift')\nylabel('grid-kappa');\ntitle('10-10-80');\n\n\n\n\n\nscatter([x['shift-kappa'] for x in accum],[x['global-ba-shift-kappa'] for x in accum],label='kappa');\nscatter([x['shift-balanced'] for x in accum],[x['global-ba-shift-balanced'] for x in accum],label='balanced accuracy');\nscatter([x['shift-accuracy'] for x in accum],[x['global-ba-shift-accuracy'] for x in accum],label='accuracy');\nplot([.4,1],[.4,1]);\nlegend();\nxlabel('greedy shift')\nylabel('grid-balanced');\ntitle('10-10-80');\n\n\n\n\nSame conclusions as before (good thing!)"
  },
  {
    "objectID": "posts/2021-12-23-ternary-ghost.html#chembl205-carbonic-anhydrase-ii",
    "href": "posts/2021-12-23-ternary-ghost.html#chembl205-carbonic-anhydrase-ii",
    "title": "A Ternary GHOST",
    "section": "CHEMBL205: Carbonic Anhydrase II",
    "text": "CHEMBL205: Carbonic Anhydrase II\n\ndata = pd.read_csv('../data/target_CHEMBL205.csv.gz')\nPandasTools.AddMoleculeColumnToFrame(data,smilesCol='canonical_smiles')\ndata['pKi'] = [-math.log10(x*1e-9) for x in data['standard_value']]\ndata.head()\n\n\n\n\n\n  \n    \n      \n      compound_chembl_id\n      canonical_smiles\n      standard_value\n      standard_units\n      standard_relation\n      standard_type\n      year\n      ROMol\n      pKi\n    \n  \n  \n    \n      0\n      CHEMBL1054\n      NS(=O)(=O)c1cc2c(cc1Cl)NC(C(Cl)Cl)NS2(=O)=O\n      91.0\n      nM\n      =\n      Ki\n      2009\n      \n      7.040959\n    \n    \n      1\n      CHEMBL1055\n      NS(=O)(=O)c1cc(C2(O)NC(=O)c3ccccc32)ccc1Cl\n      138.0\n      nM\n      =\n      Ki\n      2009\n      \n      6.860121\n    \n    \n      2\n      CHEMBL1060\n      O=P([O-])([O-])O.[Na+].[Na+]\n      13200000.0\n      nM\n      =\n      Ki\n      2004\n      \n      1.879426\n    \n    \n      3\n      CHEMBL106848\n      NS(=O)(=O)c1ccc(SCCO)cc1\n      21.0\n      nM\n      =\n      Ki\n      2013\n      \n      7.677781\n    \n    \n      4\n      CHEMBL107217\n      CCN(CC)C(=S)[S-].[Na+]\n      3100.0\n      nM\n      =\n      Ki\n      2009\n      \n      5.508638\n    \n  \n\n\n\n\nPick two pKi values for binning\n\ndef binner(act,bins=(5,8.5)):\n    for i,bin in enumerate(bins):\n        if act<=bin:\n            return i\n    return len(bins)\ndata['activity'] = [binner(x) for x in data.pKi]\ndata.groupby('activity').describe()\n\n\n\n\n\n  \n    \n      \n      standard_value\n      year\n      pKi\n    \n    \n      \n      count\n      mean\n      std\n      min\n      25%\n      50%\n      75%\n      max\n      count\n      mean\n      ...\n      75%\n      max\n      count\n      mean\n      std\n      min\n      25%\n      50%\n      75%\n      max\n    \n    \n      activity\n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n    \n  \n  \n    \n      0\n      968.0\n      1.242009e+18\n      3.864224e+19\n      10000.000\n      10000.0000\n      50000.0\n      196700.000\n      1.202264e+21\n      968.0\n      2012.994835\n      ...\n      2016.0\n      2020.0\n      968.0\n      4.069107\n      1.200449\n      -12.080000\n      3.706216\n      4.301030\n      5.000000\n      5.00000\n    \n    \n      1\n      3582.0\n      7.292523e+02\n      1.778519e+03\n      3.200\n      13.5000\n      73.4\n      417.750\n      9.900000e+03\n      3582.0\n      2013.261307\n      ...\n      2017.0\n      2020.0\n      3582.0\n      7.050231\n      0.915651\n      5.004365\n      6.379084\n      7.134306\n      7.869666\n      8.49485\n    \n    \n      2\n      427.0\n      1.309327e+00\n      8.709364e-01\n      0.008\n      0.6355\n      1.0\n      2.035\n      3.100000e+00\n      427.0\n      2014.962529\n      ...\n      2017.0\n      2020.0\n      427.0\n      9.050659\n      0.500779\n      8.508638\n      8.691437\n      9.000000\n      9.196895\n      11.09691\n    \n  \n\n3 rows × 24 columns\n\n\n\nOk, that’s imbalanced :-)\nGenerate fingerprints:\n\nfrom rdkit.Chem import SaltRemover\nsr = SaltRemover.SaltRemover()\nstripped = [sr.StripMol(m) for m in data.ROMol]\nfpgen = rdFingerprintGenerator.GetMorganGenerator(radius=2)\nfps = [fpgen.GetFingerprint(m) for m in stripped]\n\nAnd now run the experiment with 20 random splits:\n\naccum_chembl205 = []\nfor i in range(20):\n    run_ternary_experiment(fps,data.activity,accum_chembl205,random_state=0xf00d+i)\n\n\naccum = accum_chembl205\nfigsize(9,6)\nscatter([x['orig-kappa'] for x in accum],[x['shift-kappa'] for x in accum],label='kappa');\nscatter([x['orig-balanced'] for x in accum],[x['shift-balanced'] for x in accum],label='balanced accuracy');\nscatter([x['orig-accuracy'] for x in accum],[x['shift-accuracy'] for x in accum],label='accuracy');\nplot([.4,1],[.4,1]);\nlegend();\nxlabel('orig')\nylabel('greedy shift');\ntitle('CHEMBL205');\n\n\n\n\n\nscatter([x['shift-kappa'] for x in accum],[x['global-k-shift-kappa'] for x in accum],label='kappa');\nscatter([x['shift-balanced'] for x in accum],[x['global-k-shift-balanced'] for x in accum],label='balanced accuracy');\nscatter([x['shift-accuracy'] for x in accum],[x['global-k-shift-accuracy'] for x in accum],label='accuracy');\nplot([.4,1],[.4,1]);\nlegend();\nxlabel('greedy shift')\nylabel('grid-kappa');\ntitle('CHEMBL205');\n\n\n\n\n\nscatter([x['shift-kappa'] for x in accum],[x['global-ba-shift-kappa'] for x in accum],label='kappa');\nscatter([x['shift-balanced'] for x in accum],[x['global-ba-shift-balanced'] for x in accum],label='balanced accuracy');\nscatter([x['shift-accuracy'] for x in accum],[x['global-ba-shift-accuracy'] for x in accum],label='accuracy');\nplot([.4,1],[.4,1]);\nlegend();\nxlabel('greedy shift')\nylabel('grid-balanced');\ntitle('CHEMBL205');\n\n\n\n\nWe see the same behavior as before: shifting the descision thresholds using either the greedy approach or grid-based approach improves prediction accuracy over the default decision thresholds."
  },
  {
    "objectID": "posts/2021-12-23-ternary-ghost.html#chembl217-dopamine-d2",
    "href": "posts/2021-12-23-ternary-ghost.html#chembl217-dopamine-d2",
    "title": "A Ternary GHOST",
    "section": "CHEMBL217: Dopamine D2",
    "text": "CHEMBL217: Dopamine D2\n\ndata = pd.read_csv('../data/target_CHEMBL217.csv.gz')\nPandasTools.AddMoleculeColumnToFrame(data,smilesCol='canonical_smiles')\ndata['pKi'] = [-math.log10(x*1e-9) for x in data['standard_value']]\ndef binner(act,bins=(5,8)):\n    for i,bin in enumerate(bins):\n        if act<=bin:\n            return i\n    return len(bins)\ndata['activity'] = [binner(x) for x in data.pKi]\ndata.groupby('activity').describe()\n\n\n\n\n\n  \n    \n      \n      standard_value\n      year\n      pKi\n    \n    \n      \n      count\n      mean\n      std\n      min\n      25%\n      50%\n      75%\n      max\n      count\n      mean\n      ...\n      75%\n      max\n      count\n      mean\n      std\n      min\n      25%\n      50%\n      75%\n      max\n    \n    \n      activity\n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n    \n  \n  \n    \n      0\n      356.0\n      143415.189354\n      781194.668326\n      10000.000\n      10000.0000\n      10000.00\n      24234.5\n      10000000.00\n      356.0\n      2011.679775\n      ...\n      2017.0\n      2019.0\n      356.0\n      4.672916\n      0.581865\n      2.000000\n      4.615626\n      5.000000\n      5.000000\n      5.000000\n    \n    \n      1\n      4014.0\n      830.546163\n      1471.610125\n      10.000\n      63.1875\n      238.51\n      931.0\n      9906.00\n      4014.0\n      2011.100648\n      ...\n      2015.0\n      2020.0\n      4014.0\n      6.620074\n      0.724919\n      5.004102\n      6.031050\n      6.622494\n      7.199370\n      8.000000\n    \n    \n      2\n      607.0\n      3.715942\n      2.786155\n      0.027\n      1.2150\n      3.00\n      5.9\n      9.86\n      607.0\n      2011.957166\n      ...\n      2016.0\n      2019.0\n      607.0\n      8.614671\n      0.475862\n      8.006123\n      8.229148\n      8.522879\n      8.915457\n      10.568636\n    \n  \n\n3 rows × 24 columns\n\n\n\n\nfrom rdkit.Chem import SaltRemover\nsr = SaltRemover.SaltRemover()\nstripped = [sr.StripMol(m) for m in data.ROMol]\nfpgen = rdFingerprintGenerator.GetMorganGenerator(radius=2)\nfps = [fpgen.GetFingerprint(m) for m in stripped]\n\n\naccum_chembl217 = []\nfor i in range(20):\n    run_ternary_experiment(fps,data.activity,accum_chembl217,random_state=0xf00d+i)\n\n\naccum = accum_chembl217\nfigsize(9,6)\nscatter([x['orig-kappa'] for x in accum],[x['shift-kappa'] for x in accum],label='kappa');\nscatter([x['orig-balanced'] for x in accum],[x['shift-balanced'] for x in accum],label='balanced accuracy');\nscatter([x['orig-accuracy'] for x in accum],[x['shift-accuracy'] for x in accum],label='accuracy');\nplot([.2,1],[.2,1]);\nlegend();\nxlabel('orig')\nylabel('greedy shift');\ntitle('CHEMBL217');\n\n\n\n\n\nscatter([x['shift-kappa'] for x in accum],[x['global-k-shift-kappa'] for x in accum],label='kappa');\nscatter([x['shift-balanced'] for x in accum],[x['global-k-shift-balanced'] for x in accum],label='balanced accuracy');\nscatter([x['shift-accuracy'] for x in accum],[x['global-k-shift-accuracy'] for x in accum],label='accuracy');\nplot([.4,1],[.4,1]);\nlegend();\nxlabel('greedy shift')\nylabel('grid-kappa');\ntitle('CHEMBL217');\n\n\n\n\n\nscatter([x['shift-kappa'] for x in accum],[x['global-ba-shift-kappa'] for x in accum],label='kappa');\nscatter([x['shift-balanced'] for x in accum],[x['global-ba-shift-balanced'] for x in accum],label='balanced accuracy');\nscatter([x['shift-accuracy'] for x in accum],[x['global-ba-shift-accuracy'] for x in accum],label='accuracy');\nplot([.4,1],[.4,1]);\nlegend();\nxlabel('greedy shift')\nylabel('grid-balanced');\ntitle('CHEMBL217');\n\n\n\n\nAgain, the same conclusions hold here."
  },
  {
    "objectID": "posts/2022-03-18-refactoring-moldraw2d.html",
    "href": "posts/2022-03-18-refactoring-moldraw2d.html",
    "title": "Some thoughts on refactoring the MolDraw2D code",
    "section": "",
    "text": "The functionality described here is available in the 2022.03.1 and later releases of the RDKit"
  },
  {
    "objectID": "posts/2022-03-18-refactoring-moldraw2d.html#molecule-rendering",
    "href": "posts/2022-03-18-refactoring-moldraw2d.html#molecule-rendering",
    "title": "Some thoughts on refactoring the MolDraw2D code",
    "section": "Molecule rendering",
    "text": "Molecule rendering\nThere are some small differences in the way molecules are rendered; these will most likely only be visible if you are really paying attention."
  },
  {
    "objectID": "posts/2022-03-18-refactoring-moldraw2d.html#reaction-rendering",
    "href": "posts/2022-03-18-refactoring-moldraw2d.html#reaction-rendering",
    "title": "Some thoughts on refactoring the MolDraw2D code",
    "section": "Reaction rendering",
    "text": "Reaction rendering\nHere the changes are a bit larger: the reaction rendering code now makes better use of the available space.\nHere’s a rendering of one of the sample reactions we use in the testing code using the 2021.09.4 release of the RDKit:\n\nHere’s the new version:"
  },
  {
    "objectID": "posts/2022-03-18-refactoring-moldraw2d.html#drawing-molecules-in-grids-using-different-scales",
    "href": "posts/2022-03-18-refactoring-moldraw2d.html#drawing-molecules-in-grids-using-different-scales",
    "title": "Some thoughts on refactoring the MolDraw2D code",
    "section": "Drawing molecules in grids using different scales",
    "text": "Drawing molecules in grids using different scales\nWhen drawing molecules in a grid the default behavior is to draw them all at the same scale. Here’s an example of that:\n\nSince the last molecule is big, the other two molecules end up being drawn really small. We can change that by setting the new drawing option drawMolsSameScale to False:\n\nAs an aside: if you’re bothered by how big small molecules like ethanol end up being, you can use the fixedBondLength drawing option (units are, roughly, pixels per angstrom) to set the maximum bond length. Combining this with drawMolsSameScale=False for the three molecules above results in:"
  },
  {
    "objectID": "posts/2022-03-18-refactoring-moldraw2d.html#the-flexicanvas-fitting-the-canvas-size-to-the-molecule",
    "href": "posts/2022-03-18-refactoring-moldraw2d.html#the-flexicanvas-fitting-the-canvas-size-to-the-molecule",
    "title": "Some thoughts on refactoring the MolDraw2D code",
    "section": "The “flexicanvas”: fitting the canvas size to the molecule",
    "text": "The “flexicanvas”: fitting the canvas size to the molecule\nAside: I added the initial version of this before Dave did the refactoring, but the new backend simplifies the implementation.\nNormally the drawing code scales the molecule and font size to fit the canvas provided for it. With the SVG and Cairo renderers it’s now possible to set the font size and scale and let the drawer figure out how large the canvas needs to be. If I use this feature I get a larger canvas for oxytocin:\n\nthan I do for ezetimibe:\n\nbut the bond lengths and font sizes are the same in each image.\nYou can use this functionality by creating a MolDraw2D object with width and height set to -1. Here’s the code used to produce the image of ezetimibe above:\nezetimibe = Chem.MolFromSmiles('O=C1[C@H](CC[C@H](O)c2ccc(F)cc2)[C@@H](c2ccc(O)cc2)N1c1ccc(F)cc1')\nd2d = Draw.MolDraw2DCairo(-1,-1)\nd2d.drawOptions().scalingFactor = 20  # units are roughly pixels/angstrom\nd2d.drawOptions().fixedFontSize = 14\nd2d.DrawMolecule(ezetimibe)\nd2d.FinishDrawing()\nImage(d2d.GetDrawingText())"
  },
  {
    "objectID": "posts/2022-06-23-3d-mcs.html",
    "href": "posts/2022-06-23-3d-mcs.html",
    "title": "3D maximum common substructure",
    "section": "",
    "text": "One of the “underdocumented”, and perhaps lesser known, features of the RDKit MCS code is the ability to take atomic coordinates into account when generating the MCS. The idea here is to find the MCS between a set of 3D molecules where the distance between potential matching atoms is taken into account.\nThis blog post shows how to do it.\n\nfrom rdkit import Chem\nfrom rdkit.Chem import rdDistGeom\nfrom rdkit.Chem import rdFMCS\nfrom rdkit.Chem import Draw\nfrom rdkit.Chem.Draw import IPythonConsole\nfrom rdkit.Chem import rdDepictor\nrdDepictor.SetPreferCoordGen(True)\nIPythonConsole.ipython_3d = True\nimport rdkit\nprint(rdkit.__version__)\n\n2022.03.3\n\n\nLet’s start with an artifical example as a demo:\n\nm1 = Chem.MolFromSmiles('c1ccccc1-c1c(C(F)(F)F)cc(-c2c(C(F)(F)F)cccn2)cc1')\nIPythonConsole.drawOptions.addAtomIndices = True\nm1\n\n\n\n\nGenerate a conformer:\n\nm1 = Chem.AddHs(m1)\nrdDistGeom.EmbedMolecule(m1,randomSeed=0xf00d)\nm1 = Chem.RemoveHs(m1)\n\n\nm1\n\n\n        You appear to be running in JupyterLab (or JavaScript failed to load for some other reason).  You need to install the 3dmol extension: \n        jupyter labextension install jupyterlab_3dmol\n        \n\n\n\n\n\n\nClip out the central ring and change one of the atoms to an N\n\nm2 = Chem.RWMol(m1)\nkeep = [6,7,12,13,24,25]\nremove = set(range(m2.GetNumAtoms())).difference(keep)\nm2.BeginBatchEdit()\nfor aidx in remove:\n    m2.RemoveAtom(aidx)\nm2.CommitBatchEdit()\nm2.GetAtomWithIdx(0).SetAtomicNum(7)\nm2\n\n\n        You appear to be running in JupyterLab (or JavaScript failed to load for some other reason).  You need to install the 3dmol extension: \n        jupyter labextension install jupyterlab_3dmol\n        \n\n\n\n\n\n\nA normal MCS will, of course, match this to the N-containing ring:\n\nps = rdFMCS.MCSParameters()\nres = rdFMCS.FindMCS([m1,m2],ps)\nprint(res.smartsString)\n\n[#7]1:[#6]:[#6]:[#6]:[#6]:[#6]:1\n\n\n\nps = rdFMCS.MCSParameters()\nps.AtomCompareParameters.MaxDistance = 0.5\nres = rdFMCS.FindMCS([m1,m2],ps)\nprint(res.smartsString)\n\n[#6]:[#6]:[#6]:[#6]:[#6]\n\n\n\nps = rdFMCS.MCSParameters()\nps.AtomCompareParameters.MaxDistance = 0.5\nps.AtomTyper = rdFMCS.AtomCompare.CompareAny\nres = rdFMCS.FindMCS([m1,m2],ps)\nprint(res.smartsString)\n\n[#7,#6]1:[#6]:[#6]:[#6]:[#6]:[#6]:1\n\n\n\nA real example\n\n# exported from the binding db and converted to SDF in pymol\nms = [x for x in Chem.ForwardSDMolSupplier('../data/1TDU-results.sdf')]\nms2d = [Chem.Mol(x) for x in ms]\nfor m in ms2d:\n    rdDepictor.Compute2DCoords(m)\nIPythonConsole.drawOptions.addAtomIndices = False\nDraw.MolsToGridImage(ms2d)\n\n\n\n\n\nimport py3Dmol\nviewer = py3Dmol.view(width=350, height=350)\nIPythonConsole.addMolToView(ms[0],viewer)\nIPythonConsole.addMolToView(ms[1],viewer)\nIPythonConsole.addMolToView(ms[2],viewer)\nviewer.zoomTo()\nviewer.show()\n\n\n        You appear to be running in JupyterLab (or JavaScript failed to load for some other reason).  You need to install the 3dmol extension: \n        jupyter labextension install jupyterlab_3dmol\n        \n\n\n\n\nps = rdFMCS.MCSParameters()\nres = rdFMCS.FindMCS(ms,ps)\nqry = Chem.MolFromSmarts(res.smartsString)\nqry\n\n\n\n\n\nmatches = [x.GetSubstructMatch(qry) for x in ms2d]\n\nconf = Chem.Conformer(qry.GetNumAtoms())\nfor i,mi in enumerate(matches[0]):\n    conf.SetAtomPosition(i,ms2d[0].GetConformer().GetAtomPosition(mi))\nqry.AddConformer(conf)\n\nrdDepictor.SetPreferCoordGen(False) # coordgen doesn't always obey the scaffold, so switch to the RDKit coordinates\nfor m in ms2d:\n    rdDepictor.GenerateDepictionMatching2DStructure(m,qry)\nrdDepictor.SetPreferCoordGen(True)\nDraw.MolsToGridImage(ms2d,highlightAtomLists=matches)\n\n\n\n\n\nps = rdFMCS.MCSParameters()\nps.AtomTyper = rdFMCS.AtomCompare.CompareAny\nres = rdFMCS.FindMCS(ms,ps)\nqry = Chem.MolFromSmarts(res.smartsString)\nqry\n\n\n\n\n\nmatches = [x.GetSubstructMatch(qry) for x in ms2d]\n\nconf = Chem.Conformer(qry.GetNumAtoms())\nfor i,mi in enumerate(matches[0]):\n    conf.SetAtomPosition(i,ms2d[0].GetConformer().GetAtomPosition(mi))\nqry.AddConformer(conf)\nrdDepictor.SetPreferCoordGen(False) # coordgen doesn't always obey the scaffold, so switch to the RDKit coordinates\nfor m in ms2d:\n    rdDepictor.GenerateDepictionMatching2DStructure(m,qry)\nrdDepictor.SetPreferCoordGen(True)\n\nDraw.MolsToGridImage(ms2d,highlightAtomLists=matches)\n\n\n\n\nThis is an example where the constrained coordinates, which only match part of a ring system, cause problems.\nBoth of those MCS results are matching significant parts of the molecules, but we saw that the molecules didn’t actually align quite that well.\nWhat about if we take atom coordinates into account?\n\nps = rdFMCS.MCSParameters()\nps.AtomCompareParameters.MaxDistance = 1.0\nps.AtomTyper = rdFMCS.AtomCompare.CompareAny\nres = rdFMCS.FindMCS(ms,ps)\nqry = Chem.MolFromSmarts(res.smartsString)\nqry\n\n\n\n\n\nmatches = [x.GetSubstructMatch(qry) for x in ms2d]\n\nconf = Chem.Conformer(qry.GetNumAtoms())\nfor i,mi in enumerate(matches[0]):\n    conf.SetAtomPosition(i,ms2d[0].GetConformer().GetAtomPosition(mi))\nqry.AddConformer(conf)\nfor m in ms2d:\n    rdDepictor.GenerateDepictionMatching2DStructure(m,qry)\nDraw.MolsToGridImage(ms2d,highlightAtomLists=matches)\n\n\n\n\nThe MCS gave us a SMARTS which matches, but unfortunately it does not provide the matching atoms. Finding those via substructure search would be easy if we could assume that the MCS only matches each molecule once, but that’s not always going to be the case.\nThis is actually one of those examples.\nLet’s look at how many times the core can match each of the molecules:\n\nallMatches = []\nfor m in ms:\n    allMatches.append(m.GetSubstructMatches(qry,uniquify=False))\nallMatches\n\n[((13, 15, 17, 16, 20, 19, 18, 21), (13, 15, 18, 19, 20, 16, 17, 21)),\n ((12, 13, 15, 14, 18, 17, 16, 19),\n  (12, 13, 16, 17, 18, 14, 15, 19),\n  (19, 18, 14, 15, 13, 16, 17, 12),\n  (19, 18, 17, 16, 13, 15, 14, 12)),\n ((13, 14, 17, 18, 19, 20, 21, 22), (13, 14, 21, 20, 19, 18, 17, 22))]\n\n\nNow define a function which goes through all the possible substructure matches and finds the one which satisfies the 3D distance constraints on the core:\n\ndef getAlignedSubstructMatch(ms,qry,distTol=1.0):\n    allMatches = []\n    for m in ms:\n        allMatches.append(m.GetSubstructMatches(qry,uniquify=False))\n\n    keepMatches = []\n    for match0 in allMatches[0]:\n        allMatched = True\n        for i in range(1,len(ms)):\n            imatched = False\n            for matchi in allMatches[i]:\n                matched = True\n                for i0,ii in zip(match0,matchi):\n                    dist = (ms[0].GetConformer().GetAtomPosition(i0) - ms[i].GetConformer().GetAtomPosition(ii)).Length()\n                    if dist > distTol:\n                        matched = False\n                        break\n                if matched:\n                    keepMatches.append(matchi)\n                    imatched = True\n                    break\n            if not imatched:\n                allMatched = False\n                keepMatches = []\n                break\n        if allMatched:\n            keepMatches = [match0] + keepMatches\n            break\n        else:\n            keepMatches = []\n    return keepMatches\n    \n\nThe results for our molecules and the 3D MCS core:\n\nkeepMatches = getAlignedSubstructMatch(ms,qry)\nkeepMatches\n\n[(13, 15, 17, 16, 20, 19, 18, 21),\n (12, 13, 15, 14, 18, 17, 16, 19),\n (13, 14, 17, 18, 19, 20, 21, 22)]\n\n\nAnd highlight the substructures:\n\nDraw.MolsToGridImage(ms2d,highlightAtomLists=keepMatches)\n\n\n\n\nLet’s redraw the molecules in 3D and highlight the atoms involved in the MCS. It’s nice to see, plus I learned some stuff about how to use py3Dmol while doing it… so that’s a bonus. :-)\n\nimport py3Dmol\nviewer = py3Dmol.view(width=450, height=450)\nIPythonConsole.addMolToView(ms[0],viewer)\nIPythonConsole.addMolToView(ms[1],viewer)\nIPythonConsole.addMolToView(ms[2],viewer)\nfor idx,clr in zip((-1,-2,-3),('redCarbon','cyanCarbon','blueCarbon')):\n    viewer.setStyle({'model':idx,},\n                    {'stick':{'colorscheme':clr,'radius':.15}})\n    viewer.setStyle({'model':idx,'serial':keepMatches[idx]},\n                    {'stick':{'colorscheme':clr},'sphere':{'colorscheme':clr,'radius':.5}})\n\nviewer.zoomTo()\nviewer.show()\n\n\n        You appear to be running in JupyterLab (or JavaScript failed to load for some other reason).  You need to install the 3dmol extension: \n        jupyter labextension install jupyterlab_3dmol"
  },
  {
    "objectID": "posts/2022-09-29-optimizing-conformer-generation-parameters.html",
    "href": "posts/2022-09-29-optimizing-conformer-generation-parameters.html",
    "title": "Optimizing conformer generation parameters",
    "section": "",
    "text": "Whether it’s making it go faster or producing better results, we’re always on the lookout for ways to improve the RDKit’s conformer generator. Earlier this year I spent some time using a profiler to look in detail at where the code spends its time and saw that a lot of time is spent in optimizing structures using the so-called “distance geometry forcefield” (see the documentation for more details about conformer generation). Directly changing the optimization code is one of those daunting tasks which is only to be undertaken when one has a lot of time available, so I wasn’t particularly enthusiastic about that. However, while looking at the code I realized that the behavior of the optimizer is controlled by a number of parameters which have rather arbitrary values. Given that I know we never really tried to systematically find the best values for these parameters and that they definitely can have an impact on how quickly the optimizations converge (as well as how well converged they are), it seemed like adjusting these would be a logical place to try and improve things.\nFortunately, we had a student, Thibault Kläy, starting a semester project in the group who was willing to take on this project. This post has a brief description of what Thibault did and an exploration of the key results from his project.\nTL;DR Thibault found that increasing one of the force field convergence parameters (optimizerForceTol) from its default value of 0.001 to 0.0135 reduced the average run time of conformer generation by around 20% for the >4000 molecules in the Platinum set. This improvement in run time came without a significant decrease in the quality of the conformers, as measured by how close we get to the crystal conformer. This will be the default value for optimizerForceTol starting in the 2022.09 release, but you can already change the value yourself, see below."
  },
  {
    "objectID": "posts/2022-09-29-optimizing-conformer-generation-parameters.html#finding-the-best-parameters",
    "href": "posts/2022-09-29-optimizing-conformer-generation-parameters.html#finding-the-best-parameters",
    "title": "Optimizing conformer generation parameters",
    "section": "Finding the best parameters",
    "text": "Finding the best parameters\nAt first I hoped that we’d be able to adjust the parameters while only making small changes to the conformers generated… this turned out to be competely unrealistic, so we decided to evaluate the quality of the results the same way we validated the results in the ETKDG paper: by looking at how well we reproduce crystal conformers. Since using the CSD compounds we used in the original paper was complicated (from a licensing perspective), we just used the PDB structures from the Platinum set. We filtered this down to only include molecules with less than 50 heavy atoms.\nThibault explored changing the following parameters: - optimizerForceTol - basinThresh - ERROR_TOL - MOVETOL - FORCETOL - TOLX\nThe first two of those can be modified by the user; the last four require recompiling the RDKit.\nAfter running a lot of calculations Thibault found that the only parameters which really yielded a significant improvement in runtime performance were optimizerForceTol and basinThresh, that optimizerForceTol gave larger improvements, and that the results were not cumulative (so once optimizerForceTol was set to an optimal value changing basinThresh no longer really improved things).\nThe rest of this post repeats some of Thibault’s analysis to show the impact of setting optimizerForceTol to the new recommended value.\n\nfrom rdkit import Chem\nfrom rdkit.Chem.Draw import IPythonConsole\nIPythonConsole.ipython_3d = True\nfrom rdkit.Chem import rdDistGeom\nfrom rdkit.Chem import TorsionFingerprints\nfrom rdkit.Chem import AllChem\n%matplotlib inline\nimport pylab as plt\nplt.style.use('tableau-colorblind10')\nplt.rcParams['font.size'] = '16'\nimport numpy as np\n\nimport rdkit\nprint(rdkit.__version__)\n\n2022.03.5\n\n\nStart by generating conformers using the original and updated values of optimizerForceTol. This takes quite a while to run:\nimport gzip\nimport time\nimport pickle\n\netkdg = rdDistGeom.ETKDGv3()\netkdg.randomSeed = 0xa700f\netkdg.verbose = False\netkdg.numThreads = 8\nconformer_num=100\n\n# 0.001 was the default value of optimizerForceTol up to and including v2022.03\ntimings = []\nfor forceTol in ('0.001', '0.0135'):\n    print(\nf'''---------------------------\n    forceTol: {forceTol}\n---------------------------''')\n    inf = gzip.open('../data/platinum_dataset_2017_01.sdf.gz')\n    outf = gzip.open(f'./results/platinum_forcetol_{forceTol}.100confs.pkl.gz','wb+')\n    etkdg.optimizerForceTol = float(forceTol)\n    lts = []\n    for i,m in enumerate(Chem.ForwardSDMolSupplier(inf,removeHs=False)):\n        if not m:\n            continue\n        if m.GetNumHeavyAtoms()>50:\n            continue\n        Chem.AssignStereochemistryFrom3D(m)\n        start = time.time()\n        conformation_ids = rdDistGeom.EmbedMultipleConfs(m, numConfs=conformer_num, params=etkdg)\n        lts.append(time.time()-start)\n        if not (i+1)%1000:\n            print(f\"***** done {i+1}\")\n        pickle.dump(m,outf)\n    timings.append(lts)\nwith open('./results/optmizer_force_tol_timings.pkl','wb+') as outf:\n    pickle.dump(timings,outf)\n\nRepeat that exercise for random coordinate embedding, this one takes even longer.\nimport gzip\nimport time\nimport pickle\n\netkdg = rdDistGeom.ETKDGv3()\netkdg.randomSeed = 0xa700f\netkdg.verbose = False\netkdg.numThreads = 8\netkdg.useRandomCoords = True\nconformer_num=100\n\n# 0.001 was the default value of optimizerForceTol up to and including v2022.03\ntimings = []\nfor forceTol in ('0.001', '0.0135'):\n    print(\nf'''---------------------------\n    forceTol: {forceTol}\n---------------------------''')\n    inf = gzip.open('../data/platinum_dataset_2017_01.sdf.gz')\n    outf = gzip.open(f'./results/platinum_forcetol_{forceTol}.random_coords.100confs.pkl.gz','wb+')\n    etkdg.optimizerForceTol = float(forceTol)\n    lts = []\n    for i,m in enumerate(Chem.ForwardSDMolSupplier(inf,removeHs=False)):\n        if not m:\n            continue\n        if m.GetNumHeavyAtoms()>50:\n            continue\n        Chem.AssignStereochemistryFrom3D(m)\n        start = time.time()\n        conformation_ids = rdDistGeom.EmbedMultipleConfs(m, numConfs=conformer_num, params=etkdg)\n        lts.append(time.time()-start)\n        if not (i+1)%1000:\n            print(f\"***** done {i+1}\")\n        pickle.dump(m,outf)\n    timings.append(lts)\nwith open('./results/optmizer_force_tol_timings.random_coords.pkl','wb+') as outf:\n    pickle.dump(timings,outf)"
  },
  {
    "objectID": "posts/2022-09-29-optimizing-conformer-generation-parameters.html#comparison-to-crystal-conformers",
    "href": "posts/2022-09-29-optimizing-conformer-generation-parameters.html#comparison-to-crystal-conformers",
    "title": "Optimizing conformer generation parameters",
    "section": "Comparison to crystal conformers",
    "text": "Comparison to crystal conformers\nIs there an impact on our ability to find the crystal conformer?\n\nRMSD\n\ninf = gzip.open('../data/platinum_dataset_2017_01.sdf.gz')\n\nbase_xtal_rms = []\nmod_xtal_rms = []\nwith gzip.open('./results/platinum_forcetol_0.001.100confs.pkl.gz') as basef,\\\n     gzip.open('./results/platinum_forcetol_0.0135.100confs.pkl.gz') as modf:\n    for i,m in enumerate(Chem.ForwardSDMolSupplier(inf,removeHs=False)):\n        if not m:\n            continue\n        if m.GetNumHeavyAtoms()>50:\n            continue\n        m = Chem.RemoveHs(m)\n        try:\n            m1 = Chem.RemoveHs(pickle.load(basef))\n            m2 = Chem.RemoveHs(pickle.load(modf))\n        except EOFError:\n            break\n        base_best = 1000\n        mod_best = 1000\n        for conf1,conf2 in zip(m1.GetConformers(),m2.GetConformers()):\n            rms = AllChem.GetBestRMS(m1,m,conf1.GetId())\n            base_best = min(base_best,rms)\n            rms = AllChem.GetBestRMS(m2,m,conf2.GetId())\n            mod_best = min(mod_best,rms)\n        if base_best<1000 and mod_best<1000:\n            base_xtal_rms.append(base_best)\n            mod_xtal_rms.append(mod_best)\n\n\nthresh = 0.5\nplt.rcParams['figure.figsize']=(7,7)\nplt.scatter(base_xtal_rms,mod_xtal_rms);\nlim = max(base_xtal_rms+mod_xtal_rms)\nplt.plot((0,lim),(0,lim),'k')\nplt.plot((0,lim),(thresh,lim+thresh),ls='dashed',color='grey')\nplt.plot((thresh,lim),(0,lim-thresh),ls='dashed',color='grey');\nplt.xlabel('optimizerForceTol=0.001');\nplt.ylabel('optimizerForceTol=0.0135');\nplt.title('platinum 100 confs/mol, RMSD to xtal conf');\n\n\n\n\n\nthresh = 0.5\nplt.rcParams['figure.figsize']=(7,7)\nplt.hexbin(base_xtal_rms,mod_xtal_rms,cmap='Blues',bins='log');\noutside = [(x,y) for x,y in zip(base_xtal_rms,mod_xtal_rms) if abs(x-y)>thresh]\nplt.scatter([x for x,y in outside],[y for x,y in outside],marker='.')\nlim = max(base_xtal_rms+mod_xtal_rms)\nplt.plot((0,lim),(0,lim),'k')\nplt.plot((0,lim),(thresh,lim+thresh),ls='dashed',color='grey')\nplt.plot((thresh,lim),(0,lim-thresh),ls='dashed',color='grey');\nplt.xlabel('optimizerForceTol=0.001');\nplt.ylabel('optimizerForceTol=0.0135');\nplt.title('platinum 100 confs/mol, RMSD to xtal conf');\n\n\n\n\nBased on these plots it looks like we haven’t negatively impacted our ability to reproduce crystal conformers.\nLet’s look at the \\(\\Delta\\) RMSD differences directly:\n\nd = np.array(mod_xtal_rms)-np.array(base_xtal_rms)\nplt.hist(d,bins=20);\nplt.xlabel('RMSD(forceTol=0.0135)-RMSD(forceTol=0.001)')\nplt.title('platinum 100 confs/mol');\n\n\n\n\nZoom in:\n\nd = np.array(mod_xtal_rms)-np.array(base_xtal_rms)\nplt.hist([x for x in d if abs(x)<=0.75],bins=20);\nplt.xlabel('RMSD(forceTol=0.0135)-RMSD(forceTol=0.001)')\nplt.title('platinum 100 confs/mol');\n\n\n\n\nThere really aren’t significant changes here.\n\n\nTFD\nRMSD, though familiar and intuitive, has some well-documented shortcomings. Torsion Fingerprint Differences (TFDs) were developed as an alternative metric for comparing structures which is less susceptible to some of these problems.\nWe used TFDs in the original ETKDG paper, so let’s try them here too\n\n# The RDKit's TFD implementation doesn't currently (v2022.03) have a fast implementation of\n# the method we need, so do it directly here:\ndef GetBestTFDBetweenMolecules(mol1, mol2, confId1=-1, useWeights=True, maxDev='equal',\n                           symmRadius=2, ignoreColinearBonds=True):\n  \"\"\" Wrapper to calculate the TFD between two molecules.\n      All conformers of mol2 will be compared against a single conformer of mol1\n      and the lowest TFD returned\n      \n      Important: The two molecules must be instances of the same molecule\n\n      Arguments:\n      - mol1:     first instance of the molecule of interest\n      - mol2:     second instance the molecule of interest\n      - confId1:  conformer index for mol1 (default: first conformer)\n      - useWeights: flag for using torsion weights in the TFD calculation\n      - maxDev:   maximal deviation used for normalization\n                  'equal': all torsions are normalized using 180.0 (default)\n                  'spec':  each torsion is normalized using its specific\n                           maximal deviation as given in the paper\n      - symmRadius: radius used for calculating the atom invariants\n                    (default: 2)\n      - ignoreColinearBonds: if True (default), single bonds adjacent to\n                             triple bonds are ignored\n                             if False, alternative not-covalently bound\n                             atoms are used to define the torsion\n\n      Return: TFD value\n  \"\"\"\n  if (Chem.MolToSmiles(mol1) != Chem.MolToSmiles(mol2)):\n    raise ValueError(\"The two molecules must be instances of the same molecule!\")\n  mol2 = TorsionFingerprints._getSameAtomOrder(mol1, mol2)\n  tl, tlr = TorsionFingerprints.CalculateTorsionLists(mol1, maxDev=maxDev, symmRadius=symmRadius,\n                                  ignoreColinearBonds=ignoreColinearBonds)\n  # first molecule\n  torsion1 = TorsionFingerprints.CalculateTorsionAngles(mol1, tl, tlr, confId=confId1)\n  if useWeights:\n    weights = TorsionFingerprints.CalculateTorsionWeights(mol1, ignoreColinearBonds=ignoreColinearBonds)\n  best = 1e8\n  for conf in mol2.GetConformers():\n    # second molecule\n    torsion2 = TorsionFingerprints.CalculateTorsionAngles(mol2, tl, tlr, confId=conf.GetId())\n    if useWeights:\n      tfd = TorsionFingerprints.CalculateTFD(torsion1, torsion2, weights=weights)\n    else:\n      tfd = TorsionFingerprints.CalculateTFD(torsion1, torsion2)\n    best = min(best,tfd)\n  return best\n\n\ninf = gzip.open('../data/platinum_dataset_2017_01.sdf.gz')\nbase_xtal_tfd = []\nmod_xtal_tfd = []\nwith gzip.open('./results/platinum_forcetol_0.001.100confs.pkl.gz') as basef,\\\n     gzip.open('./results/platinum_forcetol_0.0135.100confs.pkl.gz') as modf:\n    for i,m in enumerate(Chem.ForwardSDMolSupplier(inf,removeHs=False)):\n        if not m:\n            continue\n        if m.GetNumHeavyAtoms()>50:\n            continue\n        m = Chem.RemoveHs(m)\n        try:\n            m1 = Chem.RemoveHs(pickle.load(basef))\n            m2 = Chem.RemoveHs(pickle.load(modf))\n        except EOFError:\n            break\n        base_best = 1000\n        mod_best = 1000\n        base_best = GetBestTFDBetweenMolecules(m,m1)\n        mod_best = GetBestTFDBetweenMolecules(m,m2)\n        if base_best<1000 and mod_best<1000:\n            base_xtal_tfd.append(base_best)\n            mod_xtal_tfd.append(mod_best)\n        if not (i+1)%500:\n            print(f\"Done {i+1}\")\n\nDone 500\nDone 1000\nDone 1500\nDone 2000\nDone 2500\nDone 3000\nDone 3500\nDone 4000\nDone 4500\n\n\n\nthresh = 0.2\nplt.rcParams['figure.figsize']=(7,7)\nplt.scatter(base_xtal_tfd,mod_xtal_tfd);\nlim = max(base_xtal_tfd+mod_xtal_tfd)\nplt.plot((0,lim),(0,lim),'k')\nplt.plot((0,lim),(thresh,lim+thresh),ls='dashed',color='grey')\nplt.plot((thresh,lim),(0,lim-thresh),ls='dashed',color='grey');\nplt.xlabel('optimizerForceTol=0.001');\nplt.ylabel('optimizerForceTol=0.0135');\nplt.title('platinum 100 confs/mol, TFD to xtal conf');\n\n\n\n\n\nthresh = 0.2\nplt.rcParams['figure.figsize']=(7,7)\nplt.hexbin(base_xtal_tfd,mod_xtal_tfd,cmap='Blues',bins='log');\nlim = max(base_xtal_tfd+mod_xtal_tfd)\nplt.plot((0,lim),(0,lim),'k')\nplt.plot((0,lim),(thresh,lim+thresh),ls='dashed',color='grey')\nplt.plot((thresh,lim),(0,lim-thresh),ls='dashed',color='grey');\nplt.xlabel('optimizerForceTol=0.001');\nplt.ylabel('optimizerForceTol=0.0135');\nplt.title('platinum 100 confs/mol, TFD to xtal conf');\n\n\n\n\nLook at the histogram of the changes in TFD between the two methods\n\nd = np.array(mod_xtal_tfd)-np.array(base_xtal_tfd)\nplt.hist(d,bins=20);\nplt.xlabel('TFD(forceTol=0.0135)-TFD(forceTol=0.001)')\nplt.title('platinum 100 confs/mol');\n\n\n\n\nZoom in:\n\nd = np.array(mod_xtal_tfd)-np.array(base_xtal_tfd)\nplt.hist([x for x in d if abs(x)<0.1],bins=20);\nplt.xlabel('TFD(forceTol=0.0135)-TFD(forceTol=0.001)')\nplt.title('platinum 100 confs/mol');\n\n\n\n\nConclusion: the updated force field parameters don’t have a much of an impact at all on our ability to reproduce crystal conformers as measured by TFD."
  },
  {
    "objectID": "posts/2022-09-29-optimizing-conformer-generation-parameters.html#comparing-to-crystal-structures",
    "href": "posts/2022-09-29-optimizing-conformer-generation-parameters.html#comparing-to-crystal-structures",
    "title": "Optimizing conformer generation parameters",
    "section": "Comparing to crystal structures",
    "text": "Comparing to crystal structures\n\nRMSD\n\nimport gzip\ninf = gzip.open('../data/platinum_dataset_2017_01.sdf.gz')\n\nbase_xtal_rms = []\nmod_xtal_rms = []\nwith gzip.open('./results/platinum_forcetol_0.001.random_coords.100confs.pkl.gz') as basef,\\\n     gzip.open('./results/platinum_forcetol_0.0135.random_coords.100confs.pkl.gz') as modf:\n    for i,m in enumerate(Chem.ForwardSDMolSupplier(inf,removeHs=False)):\n        if not m:\n            continue\n        if m.GetNumHeavyAtoms()>50:\n            continue\n        m = Chem.RemoveHs(m)\n        try:\n            m1 = Chem.RemoveHs(pickle.load(basef))\n            m2 = Chem.RemoveHs(pickle.load(modf))\n        except EOFError:\n            break\n        base_best = 1000\n        mod_best = 1000\n        for conf1,conf2 in zip(m1.GetConformers(),m2.GetConformers()):\n            rms = AllChem.GetBestRMS(m1,m,conf1.GetId())\n            base_best = min(base_best,rms)\n            rms = AllChem.GetBestRMS(m2,m,conf2.GetId())\n            mod_best = min(mod_best,rms)\n        if base_best<1000 and mod_best<1000:\n            base_xtal_rms.append(base_best)\n            mod_xtal_rms.append(mod_best)\n\n\nthresh = 0.5\nplt.rcParams['figure.figsize']=(7,7)\nplt.scatter(base_xtal_rms,mod_xtal_rms);\nlim = max(base_xtal_rms+mod_xtal_rms)\nplt.plot((0,lim),(0,lim),'k')\nplt.plot((0,lim),(thresh,lim+thresh),ls='dashed',color='grey')\nplt.plot((thresh,lim),(0,lim-thresh),ls='dashed',color='grey');\nplt.xlabel('optimizerForceTol=0.001');\nplt.ylabel('optimizerForceTol=0.0135');\nplt.title('platinum 100 confs/mol, RMSD to xtal conf');\n\n\n\n\n\nthresh = 0.5\nplt.rcParams['figure.figsize']=(7,7)\nplt.hexbin(base_xtal_rms,mod_xtal_rms,cmap='Blues',bins='log');\noutside = [(x,y) for x,y in zip(base_xtal_rms,mod_xtal_rms) if abs(x-y)>thresh]\nplt.scatter([x for x,y in outside],[y for x,y in outside],marker='.')\nlim = max(base_xtal_rms+mod_xtal_rms)\nplt.plot((0,lim),(0,lim),'k')\nplt.plot((0,lim),(thresh,lim+thresh),ls='dashed',color='grey')\nplt.plot((thresh,lim),(0,lim-thresh),ls='dashed',color='grey');\nplt.xlabel('optimizerForceTol=0.001');\nplt.ylabel('optimizerForceTol=0.0135');\nplt.title('platinum 100 confs/mol, RMSD to xtal conf');\n\n\n\n\nOnce again, it looks like we haven’t negatively impacted our ability to reproduce crystal conformers in any serious way.\nLet’s look at the \\(\\Delta\\) RMSD differences directly:\n\nd = np.array(mod_xtal_rms)-np.array(base_xtal_rms)\nplt.hist(d,bins=20);\nplt.xlabel('RMSD(forceTol=0.0135)-RMSD(forceTol=0.001)')\nplt.title('platinum 100 confs/mol');\n\n\n\n\nZoom in:\n\nd = np.array(mod_xtal_rms)-np.array(base_xtal_rms)\nplt.hist([x for x in d if abs(x)<=0.5],bins=20);\nplt.xlabel('RMSD(forceTol=0.0135)-RMSD(forceTol=0.001)')\nplt.title('platinum 100 confs/mol');\n\n\n\n\n\n\nTFDs\n\ninf = gzip.open('../data/platinum_dataset_2017_01.sdf.gz')\nbase_xtal_tfd = []\nmod_xtal_tfd = []\nwith gzip.open('./results/platinum_forcetol_0.001.random_coords.100confs.pkl.gz') as basef,\\\n     gzip.open('./results/platinum_forcetol_0.0135.random_coords.100confs.pkl.gz') as modf:\n    for i,m in enumerate(Chem.ForwardSDMolSupplier(inf,removeHs=False)):\n        if not m:\n            continue\n        if m.GetNumHeavyAtoms()>50:\n            continue\n        m = Chem.RemoveHs(m)\n        try:\n            m1 = Chem.RemoveHs(pickle.load(basef))\n            m2 = Chem.RemoveHs(pickle.load(modf))\n        except EOFError:\n            break\n        base_best = 1000\n        mod_best = 1000\n        base_best = GetBestTFDBetweenMolecules(m,m1)\n        mod_best = GetBestTFDBetweenMolecules(m,m2)\n        if base_best<1000 and mod_best<1000:\n            base_xtal_tfd.append(base_best)\n            mod_xtal_tfd.append(mod_best)\n        if not (i+1)%500:\n            print(f\"Done {i+1}\")\n\nDone 500\nDone 1000\nDone 1500\nDone 2000\nDone 2500\nDone 3000\nDone 3500\nDone 4000\nDone 4500\n\n\n\nthresh = 0.2\nplt.rcParams['figure.figsize']=(7,7)\nplt.scatter(base_xtal_tfd,mod_xtal_tfd);\nlim = max(base_xtal_tfd+mod_xtal_tfd)\nplt.plot((0,lim),(0,lim),'k')\nplt.plot((0,lim),(thresh,lim+thresh),ls='dashed',color='grey')\nplt.plot((thresh,lim),(0,lim-thresh),ls='dashed',color='grey');\nplt.xlabel('optimizerForceTol=0.001');\nplt.ylabel('optimizerForceTol=0.0135');\nplt.title('platinum 100 confs/mol, TFD to xtal conf');\n\n\n\n\n\nthresh = 0.2\nplt.rcParams['figure.figsize']=(7,7)\nplt.hexbin(base_xtal_tfd,mod_xtal_tfd,cmap='Blues',bins='log');\nlim = max(base_xtal_tfd+mod_xtal_tfd)\nplt.plot((0,lim),(0,lim),'k')\nplt.plot((0,lim),(thresh,lim+thresh),ls='dashed',color='grey')\nplt.plot((thresh,lim),(0,lim-thresh),ls='dashed',color='grey');\nplt.xlabel('optimizerForceTol=0.001');\nplt.ylabel('optimizerForceTol=0.0135');\nplt.title('platinum 100 confs/mol, TFD to xtal conf');\n\n\n\n\nLook at the histogram of the changes in TFD between the two methods\n\nd = np.array(mod_xtal_tfd)-np.array(base_xtal_tfd)\nplt.hist(d,bins=20);\nplt.xlabel('TFD(forceTol=0.0135)-TFD(forceTol=0.001)')\nplt.title('platinum 100 confs/mol');\n\n\n\n\nZoom in:\n\nd = np.array(mod_xtal_tfd)-np.array(base_xtal_tfd)\nplt.hist([x for x in d if abs(x)<0.1],bins=20);\nplt.xlabel('TFD(forceTol=0.0135)-TFD(forceTol=0.001)')\nplt.title('platinum 100 confs/mol');\n\n\n\n\nAgain, there are no major changes seen here."
  },
  {
    "objectID": "posts/2021-12-20-substructlibrary-search-order.html",
    "href": "posts/2021-12-20-substructlibrary-search-order.html",
    "title": "Some new features in the SubstructLibrary",
    "section": "",
    "text": "Earlier this year I did a blog post on “Generalized substructure search” with the RDKit. That demonstrated how to use some advanced query features like link nodes, variable attachment points, and tautomer insensitivity to search through the compounds from ChEMBL 29 with the RDKit’s SubstructLibrary.\nThis post uses the same ChEMBL 29 SubstructLibrary to demonstrate a couple of new features which were added in the 2021.09 release of the RDKit: 1. Changing the search order 2. Specifying which compounds are actually searched 3. Saving a molecule key (or name) together with the molecules in the SubstructLibrary\nFor more about the SubstructLibrary, take a look at this earlier post about generalized substructure search.\n\nfrom rdkit import Chem\nfrom rdkit.Chem.Draw import IPythonConsole\nfrom rdkit.Chem import Draw\nfrom rdkit.Chem import rdSubstructLibrary\nfrom rdkit import RDLogger\nfrom rdkit import rdBase\nimport pickle\nimport time\nimport gzip\nprint(rdBase.rdkitVersion)\nprint(time.asctime())\n\n2021.09.3\nMon Dec 20 05:14:01 2021\n\n\nHere’s the code to build the SubstructLibrary from the sdf file distributed by the ChEMBL team. This uses a feature added in RDKit v2021.09 to allow a molecule key (or name) to be stored with the molecules in a SubstructLibrary.\nExecuting this takes about 45 minutes on my machine.\nRDLogger.DisableLog(“rdApp.warning”)\nmolholder = rdSubstructLibrary.CachedTrustedSmilesMolHolder() patts = rdSubstructLibrary.TautomerPatternHolder() # this will automatically grab the “_Name” property for each molecule # in the ChEMBL SD file this contains the ChEMBL ID for the molecules. keys = rdSubstructLibrary.KeyFromPropHolder() slib = rdSubstructLibrary.SubstructLibrary(molholder,patts,keys) t1 = time.time() with gzip.GzipFile(‘/home/glandrum/Downloads/chembl_29.sdf.gz’) as gz, Chem.ForwardSDMolSupplier(gz) as suppl: nDone = 0 for m in suppl: if m is None: continue # skip huge molecules if m.GetNumHeavyAtoms()>75: continue slib.AddMol(m) nDone += 1 if not nDone%50000: print(f’ did {nDone} in {time.time()-t1:.2f}s’) with open(‘./results/chembl29_ssslib.pkl’,‘wb+’) as outf: pickle.dump(slib,outf) print(f’That took {time.time()-t1:.2f}s in total.’) with open(‘./results/chembl29_ssslib.pkl’,‘wb+’) as outf: pickle.dump(slib,outf)\nWe’re going to use the number of heavy atoms to determine the search order. Since that takes a while, go ahead and pre-calculate those values and store them in the same pickle file as the SubstructLibrary:\nholder = slib.GetMolHolder() nats = sorted([(holder.GetMol(x).GetNumHeavyAtoms(),x) for x in range(len(slib))]) order = [y for x,y in nats] # append that to the pickle file with the substruct lib: with open(‘./results/chembl29_ssslib.pkl’,‘ab’) as outf: pickle.dump(order,outf)\nRead in the saved data:\n\nwith open('./results/chembl29_ssslib.pkl','rb') as inf:\n    slib = pickle.load(inf)\n    nat_order = pickle.load(inf)\n\nHere’s the query we’ll use for this post:\n\nqry = Chem.MolFromSmarts('[O,N]=C-c:1:c:c:n:c:c:1')\nqry\n\n\n\n\nLet’s look at doing a search. We also take advantage of the SubstructLibrary’s KeyHolder (a new feature in v2021.09) to include the compound ChEMBL IDs in the results:\n\nmids = slib.GetMatches(qry)\nprint(f'{len(mids)} results')\nms = [slib.GetMolHolder().GetMol(x) for x in mids[:9]]\nlegends = [slib.GetKeyHolder().GetKey(x) for x in mids[:9]]\nDraw.MolsToGridImage(ms,legends=legends,subImgSize=(250,200))\n\n1000 results\n\n\n\n\n\nOne of the new features is that we can change the search order; this allows us to get the smallest molecules first (always a good idea with a substructure search).\nHere we’re using the number of heavy atoms to set the search order:\n\nslib.SetSearchOrder(nat_order)\nmids = slib.GetMatches(qry)\nprint(f'{len(mids)} results')\nms = [slib.GetMolHolder().GetMol(x) for x in mids[:9]]\nlegends = [slib.GetKeyHolder().GetKey(x) for x in mids[:9]]\nDraw.MolsToGridImage(ms,legends=legends,subImgSize=(250,200))\n\n1000 results\n\n\n\n\n\nIt’s important to note that we are not just sorting the results from the search here: we’re changing the order in which the search is done. So even though we’re only getting 1000 results (the default max number of results from the SubstructLibrary), we know that they are the 1000 smallest results.\nSo if we change the maximum number of results to three, we’ll get the same first three results:\n\nslib.SetSearchOrder(nat_order)\nmids2 = slib.GetMatches(qry,maxResults=3)\nprint(f'{len(mids2)} results')\nms = [slib.GetMolHolder().GetMol(x) for x in mids2[:9]]\nlegends = [slib.GetKeyHolder().GetKey(x) for x in mids2[:9]]\nDraw.MolsToGridImage(ms,legends=legends,subImgSize=(250,200))\n\n3 results\n\n\n\n\n\nWe can also use the search order to limit the compounds we search. In this case I’m going to refine the results of the previous search and identify compounds which also contain Br:\n\nslib.SetSearchOrder(mids)\nmids_new = slib.GetMatches(Chem.MolFromSmarts('[Br]'))\nprint(f'{len(mids_new)} sub-results')\nms = [slib.GetMolHolder().GetMol(x) for x in mids_new[:9]]\nlegends = [slib.GetKeyHolder().GetKey(x) for x in mids_new[:9]]\nDraw.MolsToGridImage(ms,legends=legends,subImgSize=(250,200))\n\n66 sub-results\n\n\n\n\n\nNotice that the results are still coming back sorted by the number of heavy atoms. That’s because the IDs of the molecules being used for the search search is sorted.\nWe almost certainly ran up against the default limit on the number of results (1000 compounds) when doing the first search. Let’s loosen that to 50K. This will take longer since the first query ends up having to run through the entire database.\n\nslib.SetSearchOrder(nat_order)\nmids = slib.GetMatches(qry,maxResults=50000)\nprint(f'{len(mids)} results')\n\nslib.SetSearchOrder(mids)\nmids_new = slib.GetMatches(Chem.MolFromSmarts('[Br]'))\nprint(f'{len(mids_new)} sub-results')\n\n17764 results\n919 sub-results\n\n\nIt’s never a bad idea to check the performance of these queries.\nHere’s the run time for the default value of maxResults:\n\nslib.SetSearchOrder(nat_order)\n%timeit mids = slib.GetMatches(qry)\n\n71.7 ms ± 710 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)\n\n\nAnd here’s the search time for going through the entire database (we only get 17K results here, so maxResults=50K corresponds to searching through the entire database):\n\nslib.SetSearchOrder(nat_order)\n%timeit mids = slib.GetMatches(qry,maxResults=50000)\n\n5.09 s ± 79.4 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)"
  },
  {
    "objectID": "posts/2021-05-18-fingerprint-thresholds1.html",
    "href": "posts/2021-05-18-fingerprint-thresholds1.html",
    "title": "Thresholds for “random” in fingerprints the RDKit supports",
    "section": "",
    "text": "This is an updated version of a post. The original version of the notebook can be found in github.\nA frequent question that comes up when considering fingerprint similarity is: “What threshold should I use to determine what a neighbor is?” The answer is poorly defined. Of course it depends heavily on the details of the fingerprint, but there’s also a very subjective component: you want to pick a low enough threshold that you’re sure you won’t miss anything, but you don’t want to pick up too much noise.\nThe goal here is to systematically come up with some guidelines that can be used for fingerprints supported within the RDKit. We will do that by looking a similarities between random “drug-like” (MW<600) molecules picked from ChEMBL.\nFor the analysis, the 25K similarity values are sorted and the values at particular threshold are examined.\nThere’s a fair amount of code and results below, so here’s the summary table. To help interpret this: 22500 of the 25000 pairs (90%) have a MACCS keys similarity value less than 0.528."
  },
  {
    "objectID": "posts/2021-05-18-fingerprint-thresholds1.html#count-based",
    "href": "posts/2021-05-18-fingerprint-thresholds1.html#count-based",
    "title": "Thresholds for “random” in fingerprints the RDKit supports",
    "section": "count based",
    "text": "count based\n\ncompareFPs(ms1,ms2,lambda x:rdMolDescriptors.GetMorganFingerprint(x,0),\"Morgan0 (counts)\")\n\n0.7 0.42857142857142855\n0.8 0.47058823529411764\n0.9 0.525\n0.95 0.5675675675675675\n0.99 0.6511627906976745\n\n\n\n\n\n\ncompareFPs(ms1,ms2,lambda x:rdMolDescriptors.GetMorganFingerprint(x,1),\"Morgan1 (counts)\")\n\n0.7 0.2653061224489796\n0.8 0.2926829268292683\n0.9 0.3333333333333333\n0.95 0.36363636363636365\n0.99 0.42857142857142855\n\n\n\n\n\n\ncompareFPs(ms1,ms2,lambda x:rdMolDescriptors.GetMorganFingerprint(x,2),\"Morgan2 (counts)\")\n\n0.7 0.18110236220472442\n0.8 0.20125786163522014\n0.9 0.22916666666666666\n0.95 0.2523364485981308\n0.99 0.304635761589404\n\n\n\n\n\n\ncompareFPs(ms1,ms2,lambda x:rdMolDescriptors.GetMorganFingerprint(x,3),\"Morgan3 (counts)\")\n\n0.7 0.140625\n0.8 0.1557377049180328\n0.9 0.17751479289940827\n0.95 0.19607843137254902\n0.99 0.23841059602649006"
  },
  {
    "objectID": "posts/2021-05-18-fingerprint-thresholds1.html#bit-vector-based",
    "href": "posts/2021-05-18-fingerprint-thresholds1.html#bit-vector-based",
    "title": "Thresholds for “random” in fingerprints the RDKit supports",
    "section": "bit-vector based",
    "text": "bit-vector based\n\ncompareFPs(ms1,ms2,lambda x:rdMolDescriptors.GetHashedMorganFingerprint(x,0,1024),\"Morgan0 (bits)\")\n\n0.7 0.43478260869565216\n0.8 0.475\n0.9 0.5294117647058824\n0.95 0.5714285714285714\n0.99 0.65625\n\n\n\n\n\n\ncompareFPs(ms1,ms2,lambda x:rdMolDescriptors.GetHashedMorganFingerprint(x,1,1024),\"Morgan1 (bits)\")\n\n0.7 0.2727272727272727\n0.8 0.30120481927710846\n0.9 0.34065934065934067\n0.95 0.37142857142857144\n0.99 0.4342105263157895\n\n\n\n\n\n\ncompareFPs(ms1,ms2,lambda x:rdMolDescriptors.GetHashedMorganFingerprint(x,2,1024),\"Morgan2 (bits)\")\n\n0.7 0.19708029197080293\n0.8 0.2169811320754717\n0.9 0.24603174603174602\n0.95 0.2689655172413793\n0.99 0.3217391304347826\n\n\n\n\n\n\ncompareFPs(ms1,ms2,lambda x:rdMolDescriptors.GetHashedMorganFingerprint(x,3,1024),\"Morgan3 (bits)\")\n\n0.7 0.16477272727272727\n0.8 0.18072289156626506\n0.9 0.20261437908496732\n0.95 0.2222222222222222\n0.99 0.26356589147286824"
  },
  {
    "objectID": "posts/2021-05-18-fingerprint-thresholds1.html#count-based-1",
    "href": "posts/2021-05-18-fingerprint-thresholds1.html#count-based-1",
    "title": "Thresholds for “random” in fingerprints the RDKit supports",
    "section": "count based",
    "text": "count based\n\ncompareFPs(ms1,ms2,lambda x:rdMolDescriptors.GetMorganFingerprint(x,0,useFeatures=True),\"FeatMorgan0 (counts)\")\n\n0.7 0.5833333333333334\n0.8 0.6296296296296297\n0.9 0.6896551724137931\n0.95 0.7368421052631579\n0.99 0.8181818181818182\n\n\n\n\n\n\ncompareFPs(ms1,ms2,lambda x:rdMolDescriptors.GetMorganFingerprint(x,1,useFeatures=True),\"FeatMorgan1 (counts)\")\n\n0.7 0.3902439024390244\n0.8 0.42528735632183906\n0.9 0.47368421052631576\n0.95 0.5106382978723404\n0.99 0.5813953488372093\n\n\n\n\n\n\ncompareFPs(ms1,ms2,lambda x:rdMolDescriptors.GetMorganFingerprint(x,2,useFeatures=True),\"FeatMorgan2 (counts)\")\n\n0.7 0.272\n0.8 0.29770992366412213\n0.9 0.3333333333333333\n0.95 0.36363636363636365\n0.99 0.424\n\n\n\n\n\n\ncompareFPs(ms1,ms2,lambda x:rdMolDescriptors.GetMorganFingerprint(x,3,useFeatures=True),\"FeatMorgan3 (counts)\")\n\n0.7 0.2087378640776699\n0.8 0.22818791946308725\n0.9 0.2558139534883721\n0.95 0.2785714285714286\n0.99 0.3275862068965517"
  },
  {
    "objectID": "posts/2021-05-18-fingerprint-thresholds1.html#bit-vectors",
    "href": "posts/2021-05-18-fingerprint-thresholds1.html#bit-vectors",
    "title": "Thresholds for “random” in fingerprints the RDKit supports",
    "section": "bit vectors",
    "text": "bit vectors\n\ncompareFPs(ms1,ms2,lambda x:rdMolDescriptors.GetHashedMorganFingerprint(x,0,1024,useFeatures=True),\"FeatMorgan0 (bits)\")\n\n0.7 0.5833333333333334\n0.8 0.6296296296296297\n0.9 0.6896551724137931\n0.95 0.7368421052631579\n0.99 0.8181818181818182\n\n\n\n\n\n\ncompareFPs(ms1,ms2,lambda x:rdMolDescriptors.GetHashedMorganFingerprint(x,1,1024,useFeatures=True),\"FeatMorgan1 (bits)\")\n\n0.7 0.39473684210526316\n0.8 0.42857142857142855\n0.9 0.4772727272727273\n0.95 0.5142857142857142\n0.99 0.5849056603773585\n\n\n\n\n\n\ncompareFPs(ms1,ms2,lambda x:rdMolDescriptors.GetHashedMorganFingerprint(x,2,1024,useFeatures=True),\"FeatMorgan2 (bits)\")\n\n0.7 0.28368794326241137\n0.8 0.30973451327433627\n0.9 0.3469387755102041\n0.95 0.37606837606837606\n0.99 0.43434343434343436\n\n\n\n\n\n\ncompareFPs(ms1,ms2,lambda x:rdMolDescriptors.GetHashedMorganFingerprint(x,3,1024,useFeatures=True),\"FeatMorgan3 (bits)\")\n\n0.7 0.22807017543859648\n0.8 0.24770642201834864\n0.9 0.27564102564102566\n0.95 0.29901960784313725\n0.99 0.3488372093023256"
  },
  {
    "objectID": "posts/2021-05-18-fingerprint-thresholds1.html#branched-default",
    "href": "posts/2021-05-18-fingerprint-thresholds1.html#branched-default",
    "title": "Thresholds for “random” in fingerprints the RDKit supports",
    "section": "Branched (default)",
    "text": "Branched (default)\n\ncompareFPs(ms1,ms2,lambda x:Chem.RDKFingerprint(x,maxPath=4),\"RDKit 4 (bits)\")\n\n0.7 0.2094017094017094\n0.8 0.23863636363636365\n0.9 0.2849462365591398\n0.95 0.3254237288135593\n0.99 0.4258373205741627\n\n\n\n\n\n\ncompareFPs(ms1,ms2,lambda x:Chem.RDKFingerprint(x,maxPath=5),\"RDKit 5 (bits)\")\n\n0.7 0.19672131147540983\n0.8 0.21875\n0.9 0.2534562211981567\n0.95 0.28735632183908044\n0.99 0.3682170542635659\n\n\n\n\n\n\ncompareFPs(ms1,ms2,lambda x:Chem.RDKFingerprint(x,maxPath=6),\"RDKit 6 (bits)\")\n\n0.7 0.22965641952983726\n0.8 0.2502120441051739\n0.9 0.28023598820059\n0.95 0.30818767249310025\n0.99 0.3686382393397524\n\n\n\n\n\n\ncompareFPs(ms1,ms2,lambda x:Chem.RDKFingerprint(x,maxPath=7),\"RDKit 7 (bits)\")\n\n0.7 0.3130372492836676\n0.8 0.34558303886925795\n0.9 0.38909541511771994\n0.95 0.4286600496277916\n0.99 0.5068903535050928"
  },
  {
    "objectID": "posts/2021-05-18-fingerprint-thresholds1.html#linear",
    "href": "posts/2021-05-18-fingerprint-thresholds1.html#linear",
    "title": "Thresholds for “random” in fingerprints the RDKit supports",
    "section": "linear",
    "text": "linear\n\ncompareFPs(ms1,ms2,lambda x:Chem.RDKFingerprint(x,maxPath=4,branchedPaths=False),\"linear RDKit 4 (bits)\")\n\n0.7 0.22456140350877193\n0.8 0.25773195876288657\n0.9 0.30864197530864196\n0.95 0.35403726708074534\n0.99 0.46153846153846156\n\n\n\n\n\n\ncompareFPs(ms1,ms2,lambda x:Chem.RDKFingerprint(x,maxPath=5,branchedPaths=False),\"linear RDKit 5 (bits)\")\n\n0.7 0.19756838905775076\n0.8 0.22549019607843138\n0.9 0.2687224669603524\n0.95 0.3090909090909091\n0.99 0.40425531914893614\n\n\n\n\n\n\ncompareFPs(ms1,ms2,lambda x:Chem.RDKFingerprint(x,maxPath=6,branchedPaths=False),\"linear RDKit 6 (bits)\")\n\n0.7 0.18657937806873978\n0.8 0.21005917159763313\n0.9 0.24612403100775193\n0.95 0.2820069204152249\n0.99 0.36476426799007444\n\n\n\n\n\n\ncompareFPs(ms1,ms2,lambda x:Chem.RDKFingerprint(x,maxPath=7,branchedPaths=False),\"linear RDKit 7 (bits)\")\n\n0.7 0.18204488778054864\n0.8 0.20286085825747724\n0.9 0.23367198838896952\n0.95 0.2640625\n0.99 0.33689024390243905"
  },
  {
    "objectID": "posts/2021-05-18-fingerprint-thresholds1.html#count-based-2",
    "href": "posts/2021-05-18-fingerprint-thresholds1.html#count-based-2",
    "title": "Thresholds for “random” in fingerprints the RDKit supports",
    "section": "count-based",
    "text": "count-based\n\ncompareFPs(ms1,ms2,lambda x:rdMolDescriptors.GetAtomPairFingerprint(x),\"Atom Pairs (counts)\")\n\n0.7 0.17993630573248406\n0.8 0.20386266094420602\n0.9 0.23671497584541062\n0.95 0.26545454545454544\n0.99 0.32547169811320753\n\n\n\n\n\n\ncompareFPs(ms1,ms2,lambda x:rdMolDescriptors.GetTopologicalTorsionFingerprint(x),\"Torsions (counts)\")\n\n0.7 0.10714285714285714\n0.8 0.13\n0.9 0.16470588235294117\n0.95 0.19387755102040816\n0.99 0.26582278481012656"
  },
  {
    "objectID": "posts/2021-05-18-fingerprint-thresholds1.html#bit-vectors-1",
    "href": "posts/2021-05-18-fingerprint-thresholds1.html#bit-vectors-1",
    "title": "Thresholds for “random” in fingerprints the RDKit supports",
    "section": "bit vectors",
    "text": "bit vectors\n\ncompareFPs(ms1,ms2,lambda x:rdMolDescriptors.GetHashedAtomPairFingerprintAsBitVect(x),\"Atom Pairs (bits)\")\n\n0.7 0.27488151658767773\n0.8 0.3008298755186722\n0.9 0.3353658536585366\n0.95 0.36342042755344417\n0.99 0.4146341463414634\n\n\n\n\n\n\ncompareFPs(ms1,ms2,lambda x:rdMolDescriptors.GetHashedTopologicalTorsionFingerprintAsBitVect(x),\"Torsions (bits)\")\n\n0.7 0.1326530612244898\n0.8 0.1553398058252427\n0.9 0.18840579710144928\n0.95 0.2191780821917808\n0.99 0.2876712328767123"
  },
  {
    "objectID": "posts/2022-12-09-timing-text-methods-for-serializing-mols.html",
    "href": "posts/2022-12-09-timing-text-methods-for-serializing-mols.html",
    "title": "Timing methods for serializing molecules",
    "section": "",
    "text": "This is just a short one, mainly to have the information online to use as a reference.\nThe RDKit has a number of different ways of serializing and deserializing molecules (converting them to and from strings). This post looks at how long it takes to do that with the three serialization approaches I normally recommend: 1. CXSMILES 2. The RDKit’s internal binary format 3. the RDKit’s variant of commonchem JSON.\nI looked at just serializing the molecular structure, including atomic coordinates, and serializing a few propertis together with the molecule.\nNote that this isn’t exactly comparing apples to apples: the binary and JSON formats both capture more or less the full perceived state of the molecule (aromaticity, ring systems, etc), while the CXSMILES variant doesn’t include the ring information.\nHere are the timing results for 50K molecules from ChEMBL. I ran this on my normal desktop machine, a 3-year old Dell desktop with a 3.1GHz Intel Core9 CPU. I’m running the conda-forge RDKit build.\nTimes are in seconds\nWriting\n\n\n\nMethod\nMol\nMol + coordinates\nMol + properties\n\n\n\n\nCXSMILES\n3.9\n6.4\nN/A\n\n\nPickle\n1.31\n1.48\n1.44\n\n\nJSON\n2.4\n3.1\n4.1\n\n\n\nReading\n\n\n\nMethod\nMol\nMol + coordinates\nMol + properties\n\n\n\n\nCXSMILES\n1.56\n3.78\nN/A\n\n\nPickle\n0.9\n1.14\n1.16\n\n\nJSON\n1.66\n2.08\n2.14\n\n\n\nThe binary format is, of course, the fastest. The JSON format is slower than that, but it’s still faster than using CXSMILES when serializing coordinates and roughly equivalent to CXSMILES when just storing the molecule (but, as noted above, the JSON contains more info than the CXSMILES does).\n\nfrom rdkit import Chem\nimport time\nimport gzip\nimport rdkit\nprint(rdkit.__version__)\n\n2022.09.1\n\n\nRead in a set of 50K ChEMBL molecules that we’ll use for the testing.\n\nmols = []\nsuppl = Chem.SmilesMolSupplier('../data/new_chembl_document_activity_set.smi')\nwhile len(mols)<50000:\n    try:\n        m = next(suppl)\n    except StopIteration:\n        break;\n    mols.append(m)\n    \n\n\nlen(mols)\n\n50000\n\n\nThis class makes timing our runs easier:\n\nclass timer(object):\n    def __init__(self, *args, **kwargs):\n        pass\n    def __enter__(self):\n        self.t1=time.time()\n    def __exit__(self, type, value, traceback):\n        delta = time.time()-self.t1\n        print(f'That took {delta:.2f} seconds')\n\n\njsons[0]\n\n'{\"commonchem\":{\"version\":10},\"defaults\":{\"atom\":{\"z\":6,\"impHs\":0,\"chg\":0,\"nRad\":0,\"isotope\":0,\"stereo\":\"unspecified\"},\"bond\":{\"bo\":1,\"stereo\":\"unspecified\"}},\"molecules\":[{\"name\":\"436078\",\"atoms\":[{\"z\":8,\"chg\":-1},{\"z\":7,\"chg\":1},{\"z\":8},{},{\"impHs\":1},{\"impHs\":1},{},{\"z\":7},{},{\"z\":8},{\"impHs\":1,\"stereo\":\"ccw\"},{\"impHs\":1},{\"impHs\":2},{\"impHs\":2},{\"impHs\":1},{\"z\":8},{\"impHs\":1,\"stereo\":\"ccw\"},{},{\"z\":8},{},{\"impHs\":1},{\"impHs\":1},{\"impHs\":1},{\"impHs\":1},{}],\"bonds\":[{\"atoms\":[0,1]},{\"bo\":2,\"atoms\":[1,2]},{\"atoms\":[1,3]},{\"bo\":2,\"atoms\":[3,4]},{\"atoms\":[4,5]},{\"bo\":2,\"atoms\":[5,6]},{\"atoms\":[6,7]},{\"atoms\":[7,8]},{\"bo\":2,\"atoms\":[8,9]},{\"atoms\":[8,10]},{\"atoms\":[10,11]},{\"atoms\":[11,12]},{\"atoms\":[12,13]},{\"atoms\":[13,14]},{\"atoms\":[14,15]},{\"atoms\":[14,16]},{\"atoms\":[16,17]},{\"bo\":2,\"atoms\":[17,18]},{\"atoms\":[6,19]},{\"bo\":2,\"atoms\":[19,20]},{\"atoms\":[20,21]},{\"bo\":2,\"atoms\":[21,22]},{\"atoms\":[22,23]},{\"bo\":2,\"atoms\":[23,24]},{\"atoms\":[24,3]},{\"atoms\":[17,7]},{\"atoms\":[16,10]},{\"atoms\":[15,11]},{\"atoms\":[24,19]}],\"properties\":{\"numAtoms\":25,\"numBonds\":29,\"numRings\":5,\"smiles\":\"O=C1[C@@H]2C3CCC(O3)[C@@H]2C(=O)N1c1ccc([N+](=O)[O-])c2ccccc12\"},\"extensions\":[{\"name\":\"rdkitRepresentation\",\"formatVersion\":2,\"toolkitVersion\":\"2022.09.1\",\"aromaticAtoms\":[3,4,5,6,19,20,21,22,23,24],\"aromaticBonds\":[3,4,5,18,19,20,21,22,23,24,28],\"cipRanks\":[23,19,24,13,7,6,12,18,16,21,8,14,0,1,15,20,9,17,22,10,4,2,3,5,11],\"cipCodes\":[[10,\"S\"],[16,\"R\"]],\"atomRings\":[[3,24,19,6,5,4],[8,7,17,16,10],[12,11,15,14,13],[15,14,16,10,11],[20,21,22,23,24,19]]}]}]}'\n\n\n\nMolecules without conformers\nGenerating CXSMILES:\n\nwith timer() as cm:\n    smis = [Chem.MolToCXSmiles(m) for m in mols]\n\nThat took 3.88 seconds\n\n\nGenerating the RDKit’s binary format:\n\nwith timer() as cm:\n    pkls = [m.ToBinary() for m in mols]\n\nThat took 1.31 seconds\n\n\nGenerating the RDKit’s variant of commonchem JSON:\n\nwith timer() as cm:\n    jsons = [Chem.MolToJSON(m) for m in mols]\n\nThat took 2.40 seconds\n\n\nGenerating JSON for all of the molecules at once:\n\nwith timer() as cm:\n    allJson = Chem.MolsToJSON(mols)\n\nThat took 2.83 seconds\n\n\nNow look at reading the molecules.\nStart from SMILES, but skip full sanitization since we know that the chemistry and aromaticity are correct:\n\nwith timer() as cm:\n    for smi in smis:\n        m = Chem.MolFromSmiles(smi,sanitize=False)\n        m.UpdatePropertyCache()\n\nThat took 1.56 seconds\n\n\nFrom the binary format:\n\nwith timer() as cm:\n    for pkl in pkls:\n        m = Chem.Mol(pkl)\n\nThat took 0.92 seconds\n\n\nAnd the two variants for parsing JSON:\n\nwith timer() as cm:\n    for js in jsons:\n        m = Chem.JSONToMols(js)[0]\n\nThat took 1.66 seconds\n\n\n\nwith timer() as cm:\n    _ = Chem.JSONToMols(allJson)\n\nThat took 1.49 seconds\n\n\n\n\nMolecules with a conformer\nAdd a conformer to each molecule (which will be written to the output) and re-do the timing runs:\n\nfrom rdkit.Chem import rdDepictor\nfor mol in mols:\n    rdDepictor.Compute2DCoords(mol)\n\n\nwith timer() as cm:\n    smis = [Chem.MolToCXSmiles(m) for m in mols]\n\nThat took 6.43 seconds\n\n\n\nsmis[0]\n\n'O=C1[C@@H]2C3CCC(O3)[C@@H]2C(=O)N1c1ccc([N+](=O)[O-])c2ccccc12 |(-1.03854,-2.25072,;-1.65866,-0.884909,;-3.12813,-0.583792,;-4.49394,-1.20391,;-5.96341,-0.902797,;-6.13112,0.587798,;-4.7653,1.20792,;-3.75347,0.100581,;-3.29584,0.906803,;-1.93002,1.52692,;-1.62891,2.99639,;-0.918193,0.419586,;0.572402,0.587296,;1.17246,1.96204,;2.66305,2.12976,;3.55359,0.922718,;5.04419,1.09043,;5.93473,-0.116609,;5.64424,2.46518,;2.95354,-0.452031,;3.84407,-1.65907,;3.24402,-3.03382,;1.75342,-3.20153,;0.862885,-1.99449,;1.46294,-0.619741,)|'\n\n\n\nwith timer() as cm:\n    pkls = [m.ToBinary() for m in mols]\n\nThat took 1.48 seconds\n\n\n\nwith timer() as cm:\n    jsons = [Chem.MolToJSON(m) for m in mols]\n\nThat took 3.07 seconds\n\n\n\nwith timer() as cm:\n    for smi in smis:\n        m = Chem.MolFromSmiles(smi,sanitize=False)\n        m.UpdatePropertyCache()\n\nThat took 3.78 seconds\n\n\n\nwith timer() as cm:\n    for pkl in pkls:\n        m = Chem.Mol(pkl)\n\nThat took 1.14 seconds\n\n\n\nwith timer() as cm:\n    for js in jsons:\n        m = Chem.JSONToMols(js)[0]\n\nThat took 2.08 seconds\n\n\n\n\nMolecules with properties\nSince all three formats can also save properties, see how those impact writing and parsing times:\n\nfor mol in mols:\n    mol.RemoveAllConformers()\n    mol.SetIntProp('numAtoms',mol.GetNumAtoms())\n    mol.SetIntProp('numBonds',mol.GetNumBonds())\n    mol.SetIntProp('numRings',mol.GetRingInfo().NumRings())\n    mol.SetProp('smiles',Chem.MolToSmiles(mol))\n    \n\n\nwith timer() as cm:\n    pkls = [m.ToBinary(Chem.PropertyPickleOptions.MolProps) for m in mols]\n\nThat took 1.44 seconds\n\n\n\nwith timer() as cm:\n    jsons = [Chem.MolToJSON(m) for m in mols]\n\nThat took 4.09 seconds\n\n\n\nwith timer() as cm:\n    for pkl in pkls:\n        m = Chem.Mol(pkl)\n\nThat took 1.16 seconds\n\n\n\nwith timer() as cm:\n    for js in jsons:\n        m = Chem.JSONToMols(js)[0]\n\nThat took 2.14 seconds"
  },
  {
    "objectID": "posts/2022-04-05-searching-with-generic-groups.html",
    "href": "posts/2022-04-05-searching-with-generic-groups.html",
    "title": "Searching with generic groups",
    "section": "",
    "text": "One of the features added for the v2022.03 RDKit release is support for “Reaxys/Beilstein” generic groups - atoms with labels like “ARY” or “ACY” which can be used to make substructure searches more specific.\nThis post provides a quick overview of that functionality.\nLoad a SubstructLibrary created using ChEMBL_30. The code used to construct this is below. Note that I’ve configured the SubstructLibrary to return search results sorted by the number of heavy atoms so that I get smaller, more specific results first."
  },
  {
    "objectID": "posts/2022-04-05-searching-with-generic-groups.html#aside",
    "href": "posts/2022-04-05-searching-with-generic-groups.html#aside",
    "title": "Searching with generic groups",
    "section": "Aside",
    "text": "Aside\nSince the ARY query mainly returns molecules which have a phenyl group attached at the ARY position, let’s compare search performance with a query where we explicitly include the phenyl. Here the extra atoms/bonds will slow the substructure search down but they will also make the fingerprint screenout more effective. The question is which effect is dominant.\n\nfullqry = Chem.MolFromSmiles('c1ccccc1-c1nc2ccccc2[nH]1')\nfullqry\n\n\n\n\n\n%timeit matches = sslib.GetMatches(fullqry,maxResults=5000)\n\n1.05 s ± 54.3 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)\n\n\nIn this case the larger query is a bit faster.\nIt’s worth mentioning that the query with the phenyl group returns different search results than the version with the ARY:\n\nfull_matches = sslib.GetMatches(fullqry,params,maxResults=-1)\nary_matches = sslib.GetMatches(ary_qry,params,maxResults=-1)\nlen(full_matches),len(ary_matches)\n\n(6866, 6488)\n\n\n\nfull_not_ary = set(full_matches).difference(ary_matches)\nmols = [sslib.GetMol(x) for x in full_not_ary]\nprint(f'There are {len(mols)} matches')\nDraw.MolsToGridImage(mols[:12],molsPerRow=4)\n\nThere are 379 matches\n\n\n\n\n\nAs you’d expect, there are a bunch of molecules with heterocyclic aromatic systems here. The ARY query only matches carboaryl systems.\nThere is only one molecule returned by the ARY query but not the full query; this one has an unusual aromatic ring system:\n\nary_not_full = set(ary_matches).difference(full_matches)\nmols = [sslib.GetMol(x) for x in ary_not_full]\nprint(f'There are {len(mols)} matches')\nDraw.MolsToGridImage(mols[:12],molsPerRow=4)\n\nThere are 1 matches\n\n\n\n\n\nThat’s a good one to ignite a round of “but that’s not aromatic!” arguments, but before you start down that road, please read this section of the RDKit docs: https://www.rdkit.org/docs/RDKit_Book.html#aromaticity and possibly the section on aromaticity in the Daylight Theory manual.\nThis seems like a great place to close this post. :-)"
  },
  {
    "objectID": "posts/2021-07-06-number-of-fp-bits-set.html",
    "href": "posts/2021-07-06-number-of-fp-bits-set.html",
    "title": "Looking at the number of bits set by different fingerprints",
    "section": "",
    "text": "This is an updated version of a post. The original version of the notebook can be found in github.\nI’ve done a number of posts looking at Morgan fingerprint statistics before, including:\n\nThe number of collisions in Morgan fingerprints.\nMorgan fingerprint stats\nCollisions in Morgan fingerprints revisited\n\nI have done similar analysis for other fingerprint types, but it looks like I didn’t post that (at least I can’t find it if I did). It’s useful to do this because, as we’ll see, the different fingerprint types have very different numbers of bits set for typical molecules.\nHere’s the summary of the mean and standard deviation of the number of bits set, from an analysis of 5 million molecules with less than 50 heavy atoms extracted from ZINC:\n\n\n\nFingerprint\nType\nMean num_bits\nSD num_bits\n\n\n\n\nMorgan1\nsparse\n29.4\n5.6\n\n\nMorgan2\nsparse\n48.7\n9.6\n\n\nMorgan3\nsparse\n66.8\n13.8\n\n\nFeatMorgan1\nsparse\n20.1\n3.9\n\n\nFeatMorgan2\nsparse\n38.1\n7.7\n\n\nFeatMorgan3\nsparse\n56.0\n11.8\n\n\nRDKit5\nbitvect\n363\n122\n\n\nRDKit6\nbitvect\n621\n233\n\n\nRDKit7\nbitvect\n993\n406\n\n\npattern\nbitvect\n446\n122\n\n\navalon\nbitvect\n280\n130\n\n\natom pairs\nsparse\n167\n56\n\n\nTT\nsparse\n33.4\n9.8\n\n\natom pairs\nbitvect\n267\n90\n\n\nTT\nbitvect\n47.2\n12.0\n\n\n\nThe bit vector fingerprints were all 4096 bits long.\n\nfrom rdkit import Chem,DataStructs\nimport time,random,gzip,pickle,copy\nimport numpy as np\nfrom collections import Counter,defaultdict\nfrom rdkit.Chem import Draw\nfrom rdkit.Chem import rdMolDescriptors\nfrom rdkit.Avalon import pyAvalonTools\nfrom rdkit.Chem.Draw import IPythonConsole\nfrom rdkit import DataStructs\nfrom rdkit import rdBase\n%pylab inline\n\nprint(rdBase.rdkitVersion)\nimport time\nprint(time.asctime())\n\nPopulating the interactive namespace from numpy and matplotlib\n2021.09.1pre\nTue Jul  6 04:58:28 2021\n\n\n/home/glandrum/miniconda3/lib/python3.7/site-packages/IPython/core/magics/pylab.py:160: UserWarning: pylab import has clobbered these variables: ['copy', 'random']\n`%matplotlib` prevents importing * from pylab and numpy\n  \"\\n`%matplotlib` prevents importing * from pylab and numpy\"\n\n\n\ntry:\n    import ipyparallel as ipp\n    rc = ipp.Client()\n    dview = rc[:]\n    dview.execute('from rdkit import Chem')\n    dview.execute('from rdkit import Descriptors')\n    dview.execute('from rdkit.Chem import rdMolDescriptors')\n    dview.execute('from rdkit.Avalon import pyAvalonTools')\nexcept:\n    print(\"could not use ipyparallel\")\n    dview = None\n\nFor test data I’ll use the same 16 million ZINC compounds I used in the bit statistics post.\n\nfilen='/scratch/RDKit_git/LocalData/Zinc/zinc_all_clean.pkl.gz'\n\nLoop over the molecules, skip anything with more than 50 atoms, and build fingerprints for all the others.\nThe fingerprints I generate for this analysis are: - Sparse Morgan with radii 1, 2, and 3 - Sparse FeatureMorgan with radii 1, 2, and 3 - RDKit BitVect with maxPath 5, 6, and 7 - Pattern BitVect - Avalon BitVect - Sparse Atom Pairs - Sparse Topological Torsions - Atom Pair BitVect - Topological Torsion BitVect\nAll of the BitVect fingerprints are 4096 bits long\n\nimport copy\n\nhistoryf = gzip.open('../data/fp_bit_counts.history.pkl.gz','wb+')\n\ncounts=defaultdict(Counter)\nt1 = time.time()\nwith gzip.open(filen,'rb') as inf:\n    i = 0\n    ms = []\n    while 1:\n        try:\n            m,nm = pickle.load(inf)\n        except EOFError:\n            break\n        if not m or m.GetNumHeavyAtoms()>50: continue\n        ms.append(m)\n        i+=1\n        if len(ms)>=10000:\n            for v in 1,2,3:\n                cnts = dview.map_sync(lambda x,v=v:len(rdMolDescriptors.GetMorganFingerprint(x,v).GetNonzeroElements()),\n                                     ms)\n                for obc in cnts:\n                    counts[('Morgan',v)][obc]+=1\n            for v in 1,2,3:\n                cnts = dview.map_sync(lambda x,v=v:len(rdMolDescriptors.GetMorganFingerprint(x,v,useFeatures=True).GetNonzeroElements()),\n                                     ms)\n                for obc in cnts:\n                    counts[('FeatMorgan',v)][obc]+=1\n            for v in 5,6,7:\n                cnts = dview.map_sync(lambda x,v=v:Chem.RDKFingerprint(x,maxPath=v,fpSize=4096).GetNumOnBits(),\n                                      ms)\n                for obc in cnts:\n                    counts[('RDKit',v)][obc]+=1\n            cnts = dview.map_sync(lambda x:Chem.PatternFingerprint(x,fpSize=4096).GetNumOnBits(),\n                                  ms)\n            for obc in cnts:\n                counts[('pattern',-1)][obc]+=1\n            cnts = dview.map_sync(lambda x:pyAvalonTools.GetAvalonFP(x,nBits=4096).GetNumOnBits(),\n                                  ms)\n            for obc in cnts:\n                counts[('avalon',-1)][obc]+=1\n            cnts = dview.map_sync(lambda x:len(rdMolDescriptors.GetAtomPairFingerprint(x).GetNonzeroElements()),\n                                  ms)\n            for obc in cnts:\n                counts[('ap-counts',-1)][obc]+=1\n            cnts = dview.map_sync(lambda x:len(rdMolDescriptors.GetTopologicalTorsionFingerprint(x).GetNonzeroElements()),\n                                  ms)\n            for obc in cnts:\n                counts[('tt-counts',-1)][obc]+=1\n            cnts = dview.map_sync(lambda x:rdMolDescriptors.GetHashedAtomPairFingerprintAsBitVect(x,nBits=4096).GetNumOnBits(),\n                                  ms)\n            for obc in cnts:\n                counts[('ap-bv',-1)][obc]+=1\n            cnts = dview.map_sync(lambda x:rdMolDescriptors.GetHashedTopologicalTorsionFingerprintAsBitVect(x,nBits=4096).GetNumOnBits(),\n                                  ms)\n            for obc in cnts:\n                counts[('tt-bv',-1)][obc]+=1\n            ms = []\n            \n        if not i%50000:\n            t2 = time.time()\n            print(\"Done %d in %.2f sec\"%(i,t2-t1))\n        if not i%500000:\n            pickle.dump(dict(counts),historyf)\n        if i>=5000000:\n            break\n\nDone 50000 in 38.63 sec\nDone 100000 in 77.02 sec\nDone 150000 in 115.17 sec\nDone 200000 in 163.61 sec\nDone 250000 in 215.39 sec\nDone 300000 in 267.96 sec\nDone 350000 in 319.74 sec\nDone 400000 in 373.11 sec\nDone 450000 in 415.37 sec\nDone 500000 in 468.50 sec\nDone 550000 in 526.23 sec\nDone 600000 in 570.65 sec\nDone 650000 in 622.83 sec\nDone 700000 in 674.11 sec\nDone 750000 in 724.71 sec\nDone 800000 in 775.76 sec\nDone 850000 in 823.44 sec\nDone 900000 in 873.37 sec\nDone 950000 in 922.91 sec\nDone 1000000 in 971.03 sec\nDone 1050000 in 1019.84 sec\nDone 1100000 in 1068.24 sec\nDone 1150000 in 1116.11 sec\nDone 1200000 in 1164.39 sec\nDone 1250000 in 1211.31 sec\nDone 1300000 in 1255.67 sec\nDone 1350000 in 1306.25 sec\nDone 1400000 in 1356.04 sec\nDone 1450000 in 1402.95 sec\nDone 1500000 in 1453.38 sec\nDone 1550000 in 1500.31 sec\nDone 1600000 in 1546.90 sec\nDone 1650000 in 1593.48 sec\nDone 1700000 in 1640.38 sec\nDone 1750000 in 1696.32 sec\nDone 1800000 in 1750.83 sec\nDone 1850000 in 1810.42 sec\nDone 1900000 in 1868.12 sec\nDone 1950000 in 1926.07 sec\nDone 2000000 in 1983.37 sec\nDone 2050000 in 2043.56 sec\nDone 2100000 in 2102.81 sec\nDone 2150000 in 2160.67 sec\nDone 2200000 in 2218.30 sec\nDone 2250000 in 2272.73 sec\nDone 2300000 in 2323.77 sec\nDone 2350000 in 2375.39 sec\nDone 2400000 in 2427.04 sec\nDone 2450000 in 2481.36 sec\nDone 2500000 in 2536.57 sec\nDone 2550000 in 2591.71 sec\nDone 2600000 in 2644.06 sec\nDone 2650000 in 2698.32 sec\nDone 2700000 in 2752.86 sec\nDone 2750000 in 2805.41 sec\nDone 2800000 in 2856.95 sec\nDone 2850000 in 2909.60 sec\nDone 2900000 in 2965.05 sec\nDone 2950000 in 3021.72 sec\nDone 3000000 in 3073.35 sec\nDone 3050000 in 3127.90 sec\nDone 3100000 in 3177.67 sec\nDone 3150000 in 3234.92 sec\nDone 3200000 in 3288.20 sec\nDone 3250000 in 3341.28 sec\nDone 3300000 in 3393.97 sec\nDone 3350000 in 3446.92 sec\nDone 3400000 in 3499.45 sec\nDone 3450000 in 3549.88 sec\nDone 3500000 in 3601.67 sec\nDone 3550000 in 3653.41 sec\nDone 3600000 in 3705.95 sec\nDone 3650000 in 3759.37 sec\nDone 3700000 in 3810.11 sec\nDone 3750000 in 3861.68 sec\nDone 3800000 in 3912.28 sec\nDone 3850000 in 3965.28 sec\nDone 3900000 in 4022.67 sec\nDone 3950000 in 4077.32 sec\nDone 4000000 in 4129.91 sec\nDone 4050000 in 4185.33 sec\nDone 4100000 in 4240.67 sec\nDone 4150000 in 4287.86 sec\nDone 4200000 in 4340.04 sec\nDone 4250000 in 4391.57 sec\nDone 4300000 in 4443.67 sec\nDone 4350000 in 4493.96 sec\nDone 4400000 in 4545.53 sec\nDone 4450000 in 4592.16 sec\nDone 4500000 in 4640.05 sec\nDone 4550000 in 4687.30 sec\nDone 4600000 in 4733.79 sec\nDone 4650000 in 4780.85 sec\nDone 4700000 in 4828.29 sec\nDone 4750000 in 4878.40 sec\nDone 4800000 in 4927.55 sec\nDone 4850000 in 4984.36 sec\nDone 4900000 in 5042.20 sec\nDone 4950000 in 5101.82 sec\nDone 5000000 in 5154.32 sec\n\n\n\npickle.dump(dict(counts),gzip.open('../data/fp_bit_counts.pkl.gz','wb+'))\n\nNow plot the distributions of the number of bits set\n\nmorgan_ks = [x for x in counts.keys() if x[0] =='Morgan']\nfeatmorgan_ks = [x for x in counts.keys() if x[0] =='FeatMorgan']\nrdkit_ks = [x for x in counts.keys() if x[0] == 'RDKit']\n\nfigure(figsize=(15,15))\n\npidx=1\nsubplot(3,3,pidx)\nfor n,r in morgan_ks:\n    cnts = sorted(counts[(n,r)].items())\n    \n    plot([x for x,y in cnts],[y for x,y in cnts],label=\n        f\"r={r}\")\n_=title(\"Morgan\")\n_=xlabel(\"num bits set\")\n_=ylabel(\"count\")\n_=legend()\n\npidx=2\nsubplot(3,3,pidx)\nfor n,r in featmorgan_ks:\n    cnts = sorted(counts[(n,r)].items())\n    \n    plot([x for x,y in cnts],[y for x,y in cnts],label=\n        f\"r={r}\")\n_=title(\"FeatMorgan\")\n_=xlabel(\"num bits set\")\n_=ylabel(\"count\")\n_=legend()\n\npidx=3\nsubplot(3,3,pidx)\nfor n,r in rdkit_ks:\n    cnts = sorted(counts[(n,r)].items())\n    \n    plot([x for x,y in cnts],[y for x,y in cnts],label=\n        f\"r={r}\")\n_=title(\"RDKit\")\n_=xlabel(\"num bits set\")\n_=ylabel(\"count\")\n_=legend()\n\nfor k in counts.keys():\n    if k[0] in ('Morgan','FeatMorgan','RDKit'):\n        continue\n    pidx+=1\n    subplot(3,3,pidx)\n    cnts = sorted(counts[k].items())\n    plot([x for x,y in cnts],[y for x,y in cnts])\n    _=title(k[0])\n    _=xlabel(\"num bits set\")\n    _=ylabel(\"count\")\n   \n\n\n\n\nThe avalon FP curve has an interesting shape\n\nfor k,cnts in counts.items():\n    accum = 0\n    denom = 0\n    for cnt,num in cnts.items():\n        accum += cnt*num\n        denom += num\n    mean = accum/denom\n    dev = 0\n    for cnt,num in cnts.items():\n        dev += num*(cnt-mean)**2\n    dev /= (denom-1)\n    dev = dev**0.5\n    label = k[0]\n    if k[1]!=-1:\n        label += str(k[1])\n        \n    print(label,'\\t%.1f'%mean,'%.1f'%dev)\n\nMorgan1     29.4 5.6\nMorgan2     48.7 9.6\nMorgan3     66.8 13.8\nFeatMorgan1     20.1 3.9\nFeatMorgan2     38.1 7.7\nFeatMorgan3     56.0 11.8\nRDKit5  363.3 122.5\nRDKit6  621.7 233.2\nRDKit7  993.6 406.3\npattern     445.5 122.5\navalon  279.8 129.9\nap-counts   166.6 56.3\ntt-counts   33.4 9.8\nap-bv   267.3 90.0\ntt-bv   47.2 12.0\n\n\n\nConvergence\nI did 5 million examples, which took a while (about 1.5 hours with 6 worker processes on my PC). Could I have analyzed less and gotten to the same results? Did the means converge? If so, how quickly?\n\nhistoryf = gzip.open('../data/fp_bit_counts.history.pkl.gz','rb')\nmeans = defaultdict(list)\ndevs = defaultdict(list)\nnmols = []\nwhile 1:\n    try:\n        lcounts = pickle.load(historyf)\n    except EOFError:\n        break\n    for k,cnts in lcounts.items():\n        accum = 0\n        denom = 0\n        for cnt,num in cnts.items():\n            accum += cnt*num\n            denom += num\n        mean = accum/denom\n        dev = 0\n        for cnt,num in cnts.items():\n            dev += num*(cnt-mean)**2\n        dev /= (denom-1)\n        dev = dev**0.5\n        \n        if denom not in nmols:\n            nmols.append(denom)\n        means[k].append(mean)\n        devs[k].append(dev)\n        label = k[0]\n        if k[1]!=-1:\n            label += str(k[1])\n\n        print(denom,label,'\\t%.1f'%mean,'%.1f'%dev)    \n\n500000 Morgan1  26.0 6.2\n500000 Morgan2  42.8 10.7\n500000 Morgan3  58.7 15.5\n500000 FeatMorgan1  18.2 4.3\n500000 FeatMorgan2  33.8 8.5\n500000 FeatMorgan3  49.5 13.2\n500000 RDKit5   324.6 133.9\n500000 RDKit6   560.8 256.2\n500000 RDKit7   902.9 445.7\n500000 pattern  408.8 133.9\n500000 avalon   241.8 133.8\n500000 ap-counts    133.3 57.6\n500000 tt-counts    28.6 10.2\n500000 ap-bv    219.5 93.6\n500000 tt-bv    41.9 12.9\n1000000 Morgan1     27.1 6.1\n1000000 Morgan2     44.6 10.5\n1000000 Morgan3     61.2 15.2\n1000000 FeatMorgan1     18.9 4.2\n1000000 FeatMorgan2     35.2 8.4\n1000000 FeatMorgan3     51.6 13.0\n1000000 RDKit5  340.7 133.9\n1000000 RDKit6  588.9 257.4\n1000000 RDKit7  948.5 449.9\n1000000 pattern     425.2 136.0\n1000000 avalon  257.7 136.7\n1000000 ap-counts   143.7 57.7\n1000000 tt-counts   30.1 10.1\n1000000 ap-bv   234.4 92.8\n1000000 tt-bv   43.6 12.9\n1500000 Morgan1     27.3 5.8\n1500000 Morgan2     45.0 9.9\n1500000 Morgan3     61.7 14.3\n1500000 FeatMorgan1     19.0 4.1\n1500000 FeatMorgan2     35.5 8.0\n1500000 FeatMorgan3     52.0 12.3\n1500000 RDKit5  340.3 127.8\n1500000 RDKit6  587.1 246.2\n1500000 RDKit7  944.8 432.0\n1500000 pattern     424.0 129.4\n1500000 avalon  260.5 133.7\n1500000 ap-counts   145.1 54.8\n1500000 tt-counts   30.5 9.8\n1500000 ap-bv   234.9 87.3\n1500000 tt-bv   43.7 12.3\n2000000 Morgan1     28.0 5.7\n2000000 Morgan2     46.2 9.8\n2000000 Morgan3     63.4 14.1\n2000000 FeatMorgan1     19.4 4.0\n2000000 FeatMorgan2     36.3 7.9\n2000000 FeatMorgan3     53.3 12.1\n2000000 RDKit5  350.7 126.6\n2000000 RDKit6  603.5 243.1\n2000000 RDKit7  969.0 425.8\n2000000 pattern     433.3 128.0\n2000000 avalon  269.5 133.1\n2000000 ap-counts   152.4 55.5\n2000000 tt-counts   31.5 9.8\n2000000 ap-bv   245.8 88.2\n2000000 tt-bv   45.0 12.2\n2500000 Morgan1     28.7 5.8\n2500000 Morgan2     47.5 9.8\n2500000 Morgan3     65.3 14.2\n2500000 FeatMorgan1     19.7 4.0\n2500000 FeatMorgan2     37.2 7.9\n2500000 FeatMorgan3     54.7 12.1\n2500000 RDKit5  361.5 126.3\n2500000 RDKit6  621.2 241.1\n2500000 RDKit7  996.0 420.5\n2500000 pattern     443.2 126.4\n2500000 avalon  278.4 132.6\n2500000 ap-counts   160.1 56.9\n2500000 tt-counts   32.6 9.9\n2500000 ap-bv   257.9 90.2\n2500000 tt-bv   46.3 12.2\n3000000 Morgan1     29.1 5.7\n3000000 Morgan2     48.1 9.8\n3000000 Morgan3     66.1 14.1\n3000000 FeatMorgan1     19.9 3.9\n3000000 FeatMorgan2     37.6 7.8\n3000000 FeatMorgan3     55.3 12.0\n3000000 RDKit5  364.5 124.5\n3000000 RDKit6  625.3 237.2\n3000000 RDKit7  1001.4 413.2\n3000000 pattern     446.5 124.1\n3000000 avalon  280.5 131.5\n3000000 ap-counts   163.7 57.0\n3000000 tt-counts   33.1 9.8\n3000000 ap-bv   263.5 90.5\n3000000 tt-bv   46.9 12.1\n3500000 Morgan1     29.2 5.7\n3500000 Morgan2     48.3 9.7\n3500000 Morgan3     66.4 14.0\n3500000 FeatMorgan1     19.9 3.9\n3500000 FeatMorgan2     37.7 7.8\n3500000 FeatMorgan3     55.6 11.9\n3500000 RDKit5  365.3 123.8\n3500000 RDKit6  626.7 236.0\n3500000 RDKit7  1003.7 411.3\n3500000 pattern     448.4 123.3\n3500000 avalon  280.3 131.1\n3500000 ap-counts   165.1 56.7\n3500000 tt-counts   33.3 9.8\n3500000 ap-bv   265.9 90.1\n3500000 tt-bv   47.2 12.1\n4000000 Morgan1     29.4 5.7\n4000000 Morgan2     48.6 9.8\n4000000 Morgan3     66.7 14.1\n4000000 FeatMorgan1     20.0 3.9\n4000000 FeatMorgan2     38.0 7.8\n4000000 FeatMorgan3     55.9 12.0\n4000000 RDKit5  365.2 124.1\n4000000 RDKit6  627.1 236.6\n4000000 RDKit7  1005.0 412.4\n4000000 pattern     448.6 124.0\n4000000 avalon  281.4 131.3\n4000000 ap-counts   165.7 56.9\n4000000 tt-counts   33.4 9.9\n4000000 ap-bv   266.8 90.6\n4000000 tt-bv   47.3 12.2\n4500000 Morgan1     29.4 5.6\n4500000 Morgan2     48.7 9.6\n4500000 Morgan3     66.8 13.9\n4500000 FeatMorgan1     20.1 3.9\n4500000 FeatMorgan2     38.0 7.7\n4500000 FeatMorgan3     55.9 11.8\n4500000 RDKit5  364.3 123.1\n4500000 RDKit6  624.4 234.6\n4500000 RDKit7  999.1 408.8\n4500000 pattern     447.0 122.7\n4500000 avalon  280.7 130.6\n4500000 ap-counts   166.3 56.4\n4500000 tt-counts   33.4 9.8\n4500000 ap-bv   267.3 89.9\n4500000 tt-bv   47.3 12.1\n5000000 Morgan1     29.4 5.6\n5000000 Morgan2     48.7 9.6\n5000000 Morgan3     66.8 13.8\n5000000 FeatMorgan1     20.1 3.9\n5000000 FeatMorgan2     38.1 7.7\n5000000 FeatMorgan3     56.0 11.8\n5000000 RDKit5  363.3 122.5\n5000000 RDKit6  621.7 233.2\n5000000 RDKit7  993.6 406.3\n5000000 pattern     445.5 122.5\n5000000 avalon  279.8 129.9\n5000000 ap-counts   166.6 56.3\n5000000 tt-counts   33.4 9.8\n5000000 ap-bv   267.3 90.0\n5000000 tt-bv   47.2 12.0\n\n\nLet’s look at those graphically:\n\nmorgan_ks = [x for x in counts.keys() if x[0] =='Morgan']\nfeatmorgan_ks = [x for x in counts.keys() if x[0] =='FeatMorgan']\nrdkit_ks = [x for x in counts.keys() if x[0] == 'RDKit']\n\nfigure(figsize=(15,15))\n\nnmols2 = [x/1000000 for x in nmols]\n\npidx=1\nsubplot(3,3,pidx)\nfor n,r in morgan_ks:\n    lmeans = means[(n,r)]\n    ldevs = devs[(n,r)]\n    errorbar(nmols2,lmeans,yerr=ldevs,capsize=3)\n    \n_=title(\"Morgan\")\n_=xlabel(\"num mols (millions)\")\n_=ylabel(\"count\")\n#_=legend()\n\npidx=2\nsubplot(3,3,pidx)\nfor n,r in featmorgan_ks:\n    lmeans = means[(n,r)]\n    ldevs = devs[(n,r)]\n    errorbar(nmols2,lmeans,yerr=ldevs,capsize=3)\n_=title(\"FeatMorgan\")\n_=xlabel(\"num mols (millions)\")\n_=ylabel(\"count\")\n#_=legend()\n\npidx=3\nsubplot(3,3,pidx)\nfor n,r in rdkit_ks:\n    lmeans = means[(n,r)]\n    ldevs = devs[(n,r)]\n    errorbar(nmols2,lmeans,yerr=ldevs,capsize=3)\n_=title(\"RDKit\")\n_=xlabel(\"num mols (millions)\")\n_=ylabel(\"count\")\n#_=legend()\n\nfor k in counts.keys():\n    if k[0] in ('Morgan','FeatMorgan','RDKit'):\n        continue\n    pidx+=1\n    subplot(3,3,pidx)\n    lmeans = means[k]\n    ldevs = devs[k]\n    errorbar(nmols2,lmeans,yerr=ldevs,capsize=3)\n    _=title(k[0])\n    _=xlabel(\"num mols (millions)\")\n    _=ylabel(\"count\")\n   \n\n\n\n\nLooks like we would have been fine with 3 million molecules."
  },
  {
    "objectID": "posts/2020-11-18-sphere-exclusion-clustering.html",
    "href": "posts/2020-11-18-sphere-exclusion-clustering.html",
    "title": "Sphere exclusion clustering with the RDKit",
    "section": "",
    "text": "Roger Sayle contributed an implementation of sphere-exclusion picking to the RDKit as part of the 2019.09 release and I recently realized that I’d never blogged about that code or how to use it to do compound clustering. So here’s a short(ish) one.\nThe RDKit has had an implementation of the MaxMin algorithm for picking diverse compounds for quite a while (Roger made this a lot faster back in 2017). The input to the MaxMin picker is the number of diverse compounds you want. The new algorithm is different: you provide the minimum distance allowed between the compounds picked and it returns a set of compounds satisfying that constraint.\nBoth of these methods for picking diverse compounds can then be converted into clustering algorithms by defining those picked points to be cluster centroids and then assigning non-picked compounds to the nearest centroid. We’ll do that here for the sphere-exclusion algorithm.\nFurther reading: - for more about the sphere-exclusion picker and/or learn how it works: here’s Roger’s UGM presentation - Roger’s UGM presentation describing his fast implementation of the MaxMin picker is here - Tim Dudgeon’s guest post on this blog provides a nice overview of the new MaxMin picker."
  },
  {
    "objectID": "posts/2020-11-18-sphere-exclusion-clustering.html#looking-at-the-clusters",
    "href": "posts/2020-11-18-sphere-exclusion-clustering.html#looking-at-the-clusters",
    "title": "Sphere exclusion clustering with the RDKit",
    "section": "Looking at the clusters",
    "text": "Looking at the clusters\nLet’s look at the compounds inside a couple of clusters in order to see how closely related they seem to be:\n\nclusts12 = [x for x in clusters if len(clusters[x])==12]\nlen(clusts12)\n\n10\n\n\n\nDraw.MolsToGridImage([ms[x] for x in clusters[clusts12[0]]],molsPerRow=4)\n\n\n\n\nWe can also look at the intra-cluster similarities\n\ndef intracluster_similarities(cluster,fps):\n    res = []\n    cfps = [fps[x] for x in cluster]\n    for i,fpid in enumerate(cluster):\n        tres = DataStructs.BulkTanimotoSimilarity(cfps[i],cfps)\n        del tres[i]\n        res.extend(tres)\n    return res\n        \n\n\nhist(intracluster_similarities(clusters[clusts12[0]],fps));\nxlabel('Similarity');\n\n\n\n\n\nDraw.MolsToGridImage([ms[x] for x in clusters[clusts12[1]]],molsPerRow=4)\n\n\n\n\n\nhist(intracluster_similarities(clusters[clusts12[1]],fps));\nxlabel('Similarity');\n\n\n\n\nBoth clusters are clearly include related compounds"
  },
  {
    "objectID": "posts/2020-11-18-sphere-exclusion-clustering.html#decreasing-the-sphere-radius",
    "href": "posts/2020-11-18-sphere-exclusion-clustering.html#decreasing-the-sphere-radius",
    "title": "Sphere exclusion clustering with the RDKit",
    "section": "Decreasing the sphere radius",
    "text": "Decreasing the sphere radius\nWhat about if we make the clusters tighter by decreasing the threshold distance?\n\nthresh = 0.35 # <- minimum distance between cluster centroids\npicks = lp.LazyBitVectorPick(fps,len(fps),thresh)\nprint(len(picks))\n\n1832\n\n\n\nclusters = assignPointsToClusters(picks,fps)\nhist([len(clusters[x]) for x in clusters]);\nxlabel('cluster size');\n\n\n\n\nWe’ve got more clusters and they are smaller. No big surprise\nAnd let’s look at a couple of those\n\nclusts12 = [x for x in clusters if len(clusters[x])==12]\nlen(clusts12)\n\n17\n\n\n\nDraw.MolsToGridImage([ms[x] for x in clusters[clusts12[0]]],molsPerRow=4)\n\n\n\n\n\nhist(intracluster_similarities(clusters[clusts12[0]],fps));\nxlabel('Similarity');\n\n\n\n\n\nDraw.MolsToGridImage([ms[x] for x in clusters[clusts12[1]]],molsPerRow=4)\n\n\n\n\n\nhist(intracluster_similarities(clusters[clusts12[1]],fps));\nxlabel('Similarity');\n\n\n\n\nAgain, those mostly look quite similar to each other, maybe even more similar than before?"
  },
  {
    "objectID": "posts/2020-11-18-sphere-exclusion-clustering.html#impact-of-sphere-radius-on-the-number-of-clusters",
    "href": "posts/2020-11-18-sphere-exclusion-clustering.html#impact-of-sphere-radius-on-the-number-of-clusters",
    "title": "Sphere exclusion clustering with the RDKit",
    "section": "Impact of sphere radius on the number of clusters",
    "text": "Impact of sphere radius on the number of clusters\nLook at the number of clusters as a function of the threshold\n\nresults = []\nfor thresh in arange(0.65,0.05,-0.05):\n    tpicks = lp.LazyBitVectorPick(fps,len(fps),thresh)\n    results.append([thresh,len(tpicks)])\n\n\nscatter([x for x,y in results],[y for x,y in results]);\nylabel('number of clusters')\nxlabel('distance threshold')\n\nText(0.5, 0, 'distance threshold')"
  },
  {
    "objectID": "posts/2021-05-21-similarity-search-thresholds.html",
    "href": "posts/2021-05-21-similarity-search-thresholds.html",
    "title": "Fingerprint similarity thresholds for database searches",
    "section": "",
    "text": "Updated 08.06.2021 after I expanded the set of “related compounds”. The source of the previous version of the post is available in github"
  },
  {
    "objectID": "posts/2021-05-21-similarity-search-thresholds.html#similarity-between-random-molecules",
    "href": "posts/2021-05-21-similarity-search-thresholds.html#similarity-between-random-molecules",
    "title": "Fingerprint similarity thresholds for database searches",
    "section": "Similarity between random molecules",
    "text": "Similarity between random molecules\nThe workflow and dataset for this is described in a blog post. The very quick summary is that I generated statistics for the similarity distribution of 25K random pairs of reasonable sized (MW<600) molecules exported from ChEMBL."
  },
  {
    "objectID": "posts/2021-05-21-similarity-search-thresholds.html#groups-of-related-compounds",
    "href": "posts/2021-05-21-similarity-search-thresholds.html#groups-of-related-compounds",
    "title": "Fingerprint similarity thresholds for database searches",
    "section": "Groups of related compounds",
    "text": "Groups of related compounds\nThis is really the central pillar of the post: how do we pick sets of compounds we can use to quantify similarity search performance?\nOne obvious possibility is to just take groups of molecules which are known to be active against the same targets. This is the classic similarity-based virtual screening use case and it’s one which has been done a lot in the literature. That’s an interesting (and important) use case and it’s something which I may come back to in a future post, but it requires a connection between chemical similarity and biological activity. That connection (or lack thereof) makes analysis of the threshold results more complex and introduces a significant amount of variability.\nHere I want to look at a different use case: searching a database and retrieving compounds which are chemically similar to each other. For this I need to pick groups of chemically similar compounds without actually using a traditional approach to chemical similarity. The approach I used is to assume that the typical medicinal chemistry SAR paper includes a bunch of compounds which come from a small number of chemical series (typically one). These compounds are definitely related to each other and it’s not unreasonable to expect that a similarity search for one should return the others as results.\nThis led me back to an earlier blog post looking at identifying scaffolds from ChEMBL compounds tested in the same assay (given the structure of ChEMBL, this implies that the compounds are from the same paper). That post includes some pre-filtering of the results to try and get only SAR papers by only keeping assays (papers) where 50-100 compounds were measured. For this post I re-ran that analysis against ChEMBL28 and expanded my search criteria to include IC50 data as well as the Ki data used in the original set. The analysis produced results for 1396 groups (a group is the compounds tested in one assay); for this analysis I further filtered these down to the 1047 groups (70026 compounds in total) where the number of atoms in the scaffold is at least 50% of the average number of atoms for compounds in the group. I further filtered each group to only include compounds which have a substructure match to the fuzzy MCS which was found for the full set. The hope here is that this will limit us to only consider the compounds which are part of the chemical series being reported. This lowers the total number of compounds to 66577 across the 1047 groups.\nSo given these 1047 groups of chemically related compounds I was ready to start doing some searches."
  },
  {
    "objectID": "posts/2021-05-21-similarity-search-thresholds.html#determining-background-retrieval-rates",
    "href": "posts/2021-05-21-similarity-search-thresholds.html#determining-background-retrieval-rates",
    "title": "Fingerprint similarity thresholds for database searches",
    "section": "Determining background retrieval rates",
    "text": "Determining background retrieval rates\nIn order to get a sense of how many compounds would be retrieved from a database when using the related compounds, I randomly picked 100K molecules from ChEMBL28 to use as a background. I wanted a representative sample, so I didn’t apply MW filters when doing this selection.\nI then queried the background compounds with each molecule in a random subset of the 66K members of the “related compounds” set, counted the number of results each returned for each fingerprint/similarity threshold combination, and did statistics based on those results."
  },
  {
    "objectID": "posts/2021-05-21-similarity-search-thresholds.html#summarizing-the-data",
    "href": "posts/2021-05-21-similarity-search-thresholds.html#summarizing-the-data",
    "title": "Fingerprint similarity thresholds for database searches",
    "section": "Summarizing the data",
    "text": "Summarizing the data\nHere’s an example of a graphical summary of the results presented in the final notebook listed below:\n\nThe violin plots show the distribution of similarity values required to match 50% of the related compound pairs for each of the fingerprints. The dark gray boxes show the noise level for the fingerprints. The red line shows the median fraction of the 100K ChEMBL compounds retrieved when using the median value from the violin plots as a similarity threshold."
  },
  {
    "objectID": "posts/2021-05-21-similarity-search-thresholds.html#the-notebooks",
    "href": "posts/2021-05-21-similarity-search-thresholds.html#the-notebooks",
    "title": "Fingerprint similarity thresholds for database searches",
    "section": "The notebooks",
    "text": "The notebooks\nHere are the github links for the notebooks I used: - Similarity between random molecules (this is the previous analysis): https://github.com/greglandrum/rdkit_blog/blob/master/notebooks/Fingerprint%20Thresholds.ipynb - Finding scaffolds for ChEMBL documents with Ki values (also a previous analysis): https://github.com/greglandrum/rdkit_blog/blob/master/notebooks/Finding%20Scaffolds%20Revisited%20again.ipynb - Similarity distributions for related compounds: https://github.com/greglandrum/rdkit_blog/blob/master/notebooks/Fingerprint%20Thresholds%20Scaffolds.ipynb Note that this is a new one and I’m still working on cleaning it up and adding more text/explanation - Fraction of the database retrieved when searching (this one also has the calculation of the summary results presented here): https://github.com/greglandrum/rdkit_blog/blob/master/notebooks/Fingerprint%20Thresholds%20Database%20Fraction.ipynb Note that this is a new one and I’m still working on cleaning it up and adding more text/explanation"
  },
  {
    "objectID": "posts/2021-02-22-etkdg-and-distance-constraints.html",
    "href": "posts/2021-02-22-etkdg-and-distance-constraints.html",
    "title": "ETKDG and distance constraints",
    "section": "",
    "text": "The RDKit’s conformer generator allows you to provide distance “constraints” to bias the conformers which it produces. Last week I wondered how those constraints interact with the terms which the ETKDG algorithm adds to the “distance geometry force field”.\nThis post uses a simple example to explore that interaction\nSee another recent blog post for an overview of how the conformer generator works.\n\nfrom rdkit import Chem\nfrom rdkit.Chem import rdDistGeom\nfrom rdkit.Chem.Draw import IPythonConsole\nfrom rdkit.Chem import rdMolTransforms\nIPythonConsole.ipython_3d = True\nfrom rdkit.Chem import Draw\nimport rdkit\nprint(rdkit.__version__)\n%pylab inline\n\n2020.09.4\nPopulating the interactive namespace from numpy and matplotlib\n\n\nHere’s the molecule we’ll use:\n\nm = Chem.AddHs(Chem.MolFromSmiles('OCCCCCCCN'))\n\n\nfrom rdkit.Chem import rdDepictor\nm2d = Chem.Mol(m)\nrdDepictor.Compute2DCoords(m2d)\nIPythonConsole.drawOptions.addAtomIndices = True\nm2d\n\n\n\n\nGet the bounds matrix for the molecule and look at the min/max values allowed for the O-N distance:\n\nbounds = rdDistGeom.GetMoleculeBoundsMatrix(m)\nbounds[8,0],bounds[0,8]\n\n(3.1500000000000004, 9.902933132591349)\n\n\nLet’s generate a bunch of conformers and look at the distribution of O-N distances:\n\nfigsize(6,6)\nps = rdDistGeom.ETKDGv3()\nps.randomSeed = 0xf00d\ncids = rdDistGeom.EmbedMultipleConfs(m,500,ps)\ndists_etkdg = [rdMolTransforms.GetBondLength(conf,0,8) for conf in m.GetConformers()]\nhist(dists_etkdg,bins=20);\ntitle('ETKDG');\nxlabel('O--N distance');\n\n\n\n\nLook at one conformer:\n\nprint(rdMolTransforms.GetBondLength(m.GetConformer(cids[0]),0,8) )\nIPythonConsole.drawMol3D(m,confId=cids[1])\n\n5.989729201561945\n\n\n\n        You appear to be running in JupyterLab (or JavaScript failed to load for some other reason).  You need to install the 3dmol extension: \n        jupyter labextension install jupyterlab_3dmol\n        \n\n\n\nCompare the distribution we get doing plain DG:\n\nfigsize(6,6)\nps = rdDistGeom.EmbedParameters()\nps.useExpTorsionAnglePrefs = False\nps.useBasicKnowledge = False\nps.randomSeed = 0xf00d\ncids = rdDistGeom.EmbedMultipleConfs(m,500,ps)\ndists = [rdMolTransforms.GetBondLength(conf,0,8) for conf in m.GetConformers()]\nhist(dists,bins=20);\ntitle('DG');\nxlabel('O--N distance');\n\n\n\n\nThere’s not a giant difference, but it does look like the DG conformers for this molecule tend to be more extended: the O and N tend to be farther away from each other.\nHere’s how we can modify the bounds matrix to bring the O and N closer together:\n\nbounds[0,8] = 4.1\nbounds[8,0] = 4.0\nfrom rdkit import DistanceGeometry\nDistanceGeometry.DoTriangleSmoothing(bounds)\n\nTrue\n\n\nStart with using this bounds matrix together with plain DG:\n\nfigsize(6,6)\nps = rdDistGeom.EmbedParameters()\nps.useExpTorsionAnglePrefs = False\nps.useBasicKnowledge = False\nps.randomSeed = 0xf00d\nps.SetBoundsMat(bounds)\ncids = rdDistGeom.EmbedMultipleConfs(m,500,ps)\ndists = [rdMolTransforms.GetBondLength(conf,0,8) for conf in m.GetConformers()]\nhist(dists,bins=20);\ntitle('DG, distance constraints');\nxlabel('O--N distance');\n\n\n\n\n\nprint(rdMolTransforms.GetBondLength(m.GetConformer(cids[0]),0,8) )\nIPythonConsole.drawMol3D(m,confId=cids[0])\n\n3.9739942608788374\n\n\n\n        You appear to be running in JupyterLab (or JavaScript failed to load for some other reason).  You need to install the 3dmol extension: \n        jupyter labextension install jupyterlab_3dmol\n        \n\n\n\nWhen we do ETKDG we add additional terms to the force field that’s used to optimize the structure. Do these override our distance constraints?\n\nfigsize(6,6)\nps = rdDistGeom.ETKDGv3()\nps.randomSeed = 0xf00d\nps.SetBoundsMat(bounds)\ncids = rdDistGeom.EmbedMultipleConfs(m,500,ps)\ndists = [rdMolTransforms.GetBondLength(conf,0,8) for conf in m.GetConformers()]\nhist(dists,bins=20);\ntitle('ETKDG with constraints');\nxlabel('O--N distance');\n\n\n\n\nMost of the distances are longer than what we were looking for, but they are still considerably shorter than what we saw before:\n\nfigsize(9,6)\nps = rdDistGeom.ETKDGv3()\nps.randomSeed = 0xf00d\nps.SetBoundsMat(bounds)\ncids = rdDistGeom.EmbedMultipleConfs(m,500,ps)\ndists = [rdMolTransforms.GetBondLength(conf,0,8) for conf in m.GetConformers()]\nhist(dists,bins=20,label='constraints');\ntitle('ETKDG');\nhist(dists_etkdg,bins=20,label='no constraints');\nlegend();\nxlabel('O--N distance');\n\n\n\n\nSo that answers our original question: the “constraints” we place on the conformers by modifying the bounds matrix aren’t strict, so the additional terms added by ETKDG can result in them being violated. But the results are still significant biased towards the region of conformer space we wanted to explore.\nLet’s try forcing conformations which have distances consistent with an intra-molecular hydrogen bond. Here we need to modify the bounds matrix elements between both the O and the N as well as the O and one of the Hs attached to the N. If we don’t adjust the O-N distance bounds too we end up with a bounds matrix which cannot be smoothed.\n\nbounds = rdDistGeom.GetMoleculeBoundsMatrix(m)\nbounds[0,25] = 1.9\nbounds[25,0] = 1.8\nbounds[0,8] = 3.2\nbounds[8,0] = 2.9\nfrom rdkit import DistanceGeometry\nDistanceGeometry.DoTriangleSmoothing(bounds)\n\nTrue\n\n\n\nfigsize(9,6)\n\nps = rdDistGeom.EmbedParameters()\nps.useExpTorsionAnglePrefs = False\nps.useBasicKnowledge = False\nps.randomSeed = 0xf00d\nps.SetBoundsMat(bounds)\ncids = rdDistGeom.EmbedMultipleConfs(m,500,ps)\ndists = [rdMolTransforms.GetBondLength(conf,0,25) for conf in m.GetConformers()]\nhist(dists,bins=20);\nxlabel('O--H-N distance');\n\n\n\n\n\nprint(rdMolTransforms.GetBondLength(m.GetConformer(cids[0]),0,25) )\nIPythonConsole.drawMol3D(m,confId=cids[0])\n\n1.9045497511922502\n\n\n\n        You appear to be running in JupyterLab (or JavaScript failed to load for some other reason).  You need to install the 3dmol extension: \n        jupyter labextension install jupyterlab_3dmol\n        \n\n\n\nTry using ETKDG:\n\nfigsize(6,6)\nps = rdDistGeom.ETKDGv3()\nps.randomSeed = 0xf00d\nps.SetBoundsMat(bounds)\ncids = rdDistGeom.EmbedMultipleConfs(m,500,ps)\ndists = [rdMolTransforms.GetBondLength(conf,0,25) for conf in m.GetConformers()]\nhist(dists,bins=20);\ntitle('ETKDG, with constraints');\nxlabel('O--H-N distance');\n\n\n\n\n\nprint(rdMolTransforms.GetBondLength(m.GetConformer(cids[0]),0,25) )\nIPythonConsole.drawMol3D(m,confId=cids[0])\n\n2.0641816694294173\n\n\n\n        You appear to be running in JupyterLab (or JavaScript failed to load for some other reason).  You need to install the 3dmol extension: \n        jupyter labextension install jupyterlab_3dmol\n        \n\n\n\nThe O–H-N distances here aren’t completely obeying the 1.8-1.9 distance bounds we imposed, but they seem to match a bit better than what we saw above when we constrained the O–N distance. I think that’s likely because now we have an additional constraining term - the O–H distance as well as the O–N distance - to help override the ETKDG preferences.\nSo to repeat the conclusion: modifying the distance bounds matrix doesn’t act as a hard constraint when we include ETKDG terms in the conformer generation process, but it definitely biases the results towards the areas of conformer space which we were trying to access."
  },
  {
    "objectID": "posts/2023-02-10-more-on-constrained-embedding.html",
    "href": "posts/2023-02-10-more-on-constrained-embedding.html",
    "title": "More on constrained embedding",
    "section": "",
    "text": "This is a reformatted and lightly revised version of a blog post from 2019.\nQuite a while ago I did a blog post showing how to use the Python function AllChem.ConstrainedEmbed() to generate conformers where the positions of a set of atoms are constrained to match the coordinates of a template molecule. More recently a question came up on the mailing list about how to use the core embedding functionality that lies underneath AllChem.ConstrainedEmbed(); this short post will look at that.\nWe’re going to work with cyclosporine here, since it’s delightfully complicated, which makes it fun. :-) In this case we’re going to ignore atomic stereochemistry in order to speed the conformer generation up (the RDKit tends to take a while to generate conformers for molecules with a large number of stereocenters).\nWe’ll also define the macrocylce as the core; this is what we’re going to use to provide constraints.\nStart by generating a conformer for cyclosporine itself.\nFor the other molecule, we’ll take a molecule I pulled from ChEMBL that includes the core. I also removed stereochemistry here.\nGenerate an unconstrained conformer for that:\nNow calculate the RMSD between the core atoms in cylosporine and in our test molecule.\nThere’s no reason to expect this RMSD to be anything other than huge: we’re using different conformer of a flexible core and haven’t aligned them to each other.\nWe can go ahead and do an alignmeent and see how that affects the RMSD:\nAgain, it’s not surprising that this is a large RMSD: the core is quite flexible and we haven’t constrained it at all.\nAdding constraints is the point of this blog post though, so let’s move onto that.\nAllChem.EmbedMolecule() can be given constraints for the positions of certain atoms using the coordMap argument, which expects a dictionary that provides a Point3D for each atom that should have a fixed position.\nWait… what happened here? Shouldn’t this number be smaller since we introduced constraints? This was the question on the mailing list.\nThe function AllChem.EmbedMolecule() uses the coordinates provided in coordMap to set elements of the distance bounds matrix that is used to generate conformers (details about the RDKit’s distance-geometry-based conformer generator are in the documentation). This results in conformers where the distances between the atoms in the conformer closely match the corresponding distances in the coordMap.\nNote that, because the coordinates are being constrained using the distances between them, you should expect rigid shifts of the core atoms relative to the constraints. This is solveable by aligning the core of the test molecule to the core of the reference:\nNote that the output coordinates don’t match the constraint coordinates exactly. This will almost always be the case; they should be close, but some differences are, unforunately, expected due to the nature of the algorithm.\nAn alternative is to use random coordinate embedding instead of the usual distance-bounds embedding to generate the initial coordinates in the conformer generation. When we do this it’s possible to get exact coordinate matches of the core and no alignment is necessary. Random-coordinate embedding is not the default because the current RDKit implementation tends to be slower than the other approach.\nIt’s worth taking a look at the conformers of our molecules. We’ll do that using py3Dmol. This code snippet uses a bit of convenience functionality that the RDKit’s IPythonConsole provides, but it also demonstrates how to draw molecules with different colors.\nHere one molecule is drawn with cyan bonds and the other with red bonds."
  },
  {
    "objectID": "posts/2023-02-10-more-on-constrained-embedding.html#extra-minimize-with-constraints",
    "href": "posts/2023-02-10-more-on-constrained-embedding.html#extra-minimize-with-constraints",
    "title": "More on constrained embedding",
    "section": "Extra: minimize with constraints",
    "text": "Extra: minimize with constraints\n\nfrom rdkit.Chem import rdForceFieldHelpers\nmcp = Chem.Mol(newmh)\nmmffps = rdForceFieldHelpers.MMFFGetMoleculeProperties(mcp)\nff = rdForceFieldHelpers.MMFFGetMoleculeForceField(mcp,mmffps)\nmaxIters = 10\nwhile ff.Minimize(maxIts=1000) and maxIters>0:\n    maxIters -= 1\n\n\ndelta2 = 0.0\nfor mi,newmi in zip(m_match,newm_match):\n    d = (mh.GetConformer().GetAtomPosition(mi) - mcp.GetConformer().GetAtomPosition(newmi)).LengthSq()\n    delta2 += d\nprint('core RMSD:',math.sqrt(delta2/len(m_match)))\n\ncore RMSD: 2.313775204899967\n\n\n\ndrawit((mh,mcp))\n\n\n        You appear to be running in JupyterLab (or JavaScript failed to load for some other reason).  You need to install the 3dmol extension: \n        jupyter labextension install jupyterlab_3dmol\n        \n\n\n\nThat’s messed up the core coordinates… we can fix that by adding some position constraints to the force field:\n\nmcp = Chem.Mol(newmh)\nmmffps = rdForceFieldHelpers.MMFFGetMoleculeProperties(mcp)\nff = rdForceFieldHelpers.MMFFGetMoleculeForceField(mcp,mmffps)\nfor atidx in newm_match:\n    ff.MMFFAddPositionConstraint(atidx,0.05,200)\nmaxIters = 10\nwhile ff.Minimize(maxIts=1000) and maxIters>0:\n    maxIters -= 1\n\n\ndelta2 = 0.0\nfor mi,newmi in zip(m_match,newm_match):\n    d = (mh.GetConformer().GetAtomPosition(mi) - mcp.GetConformer().GetAtomPosition(newmi)).LengthSq()\n    delta2 += d\nprint('core RMSD:',math.sqrt(delta2/len(m_match)))\n\ncore RMSD: 0.12659186987312163\n\n\nMuch better!\n\ndrawit((mh,mcp))\n\n\n        You appear to be running in JupyterLab (or JavaScript failed to load for some other reason).  You need to install the 3dmol extension: \n        jupyter labextension install jupyterlab_3dmol"
  },
  {
    "objectID": "posts/2021-07-06-simulating-counts.html",
    "href": "posts/2021-07-06-simulating-counts.html",
    "title": "Simulating count fingerprints",
    "section": "",
    "text": "Many of the RDKit’s fingerprints are available as either bit vectors or count vectors. Bit vectors track whether or not features appear in a molecule while count vectors track the number of times each feature appears. It seems intuitive that a count vector is a better representation of similarity than bit vectors, but we often use bit vector representations for computational expediency - bit vectors require less memory and are much faster to operate on.\nWhat impact does this using bit vectors have on computed similarity values and the ordering of similarities? This notebook attempts to provide at least a partial answer to that question and also examines a strategy for simulating counts using bit vectors. I look at the following fingerprints: - Morgan 2 - Topological Torsion - Atom Pair - RDKit\nAnd I use two sets of compunds: - Random pairs of compounds taken from this blog post - Pairs of “related compounds” taken from this blog post"
  },
  {
    "objectID": "posts/2021-07-06-simulating-counts.html#bit-vector-similarity-vs-count-based-similarity",
    "href": "posts/2021-07-06-simulating-counts.html#bit-vector-similarity-vs-count-based-similarity",
    "title": "Simulating count fingerprints",
    "section": "Bit vector similarity vs count-based similarity",
    "text": "Bit vector similarity vs count-based similarity\nLet’s start with two molecules where this makes a big difference:\n\nThe calculated similarity with MFP2 and counts is 0.6 while with bits it’s 0.29. That’s easy to understand since with the bit-based fingerprints the long alkyl chains don’t make the large ontribution to the similarity that they do when using counts.\nTo demonstrate that this isn’t all about long chains, here’s another pair where there’s a significant difference:\n\nIn this case the count-based similarity is 0.59 while with bits it’s 0.35.\nThose were a couple of anecdotes, but let’s look at the differences across the entire datasets:\n\nHere I’ve plotted bit-based similarity vs count-based similarity and included statistics on the correlation in the title. The left plot is for the random compound pairs and the right plot is for the related compound pairs. There are significant differences in similarity here, with the bit vector similarities being consistently lower than the count-based equivalent, but it’s worth pointing out that the rankings of the similarities (as measured by the Spearman rank-order correlation values) are reasonably equivalent, particularly for the related compound pairs.\nThe equivalent plots for the RDKit fingerprint show the same qualitative behavior with the difference that bit vector similarities tend to be higher than count based similarities:"
  },
  {
    "objectID": "posts/2021-07-06-simulating-counts.html#simulating-counts",
    "href": "posts/2021-07-06-simulating-counts.html#simulating-counts",
    "title": "Simulating count fingerprints",
    "section": "Simulating counts",
    "text": "Simulating counts\nThe RDKit has a simple mechanism for simulating counts using bit vectors: set multiple bits for each feature where the number of bits set is determined by the count. The approach uses a fixed number of potential bits which each have a threshold value; if the count for the feature exceeds the threshold value then the corresponding bit is set. Here’s a schematic illustration for count simulation with four bits and the thresholds 1, 2, 4, and 8:\n\nThe example shown, with the first two bits set for feature N, is what we’d get if feature N is set either 2 or 3 times in a molecule. Note that we aren’t just using a binary representation of the count itself. In that case a feature which is present one time in the first molecule, representation 1000, and two times in the second molecule, representation 0100, would contribute zero to the overall similarity. That’s not desirable.\nNote that since the count simulation approach uses multiple bits per feature, it decreases the effective length of the fingerprint by a factor equal to the number of bits used. With the default setting of four bits per feature a 2048 bit fingerprint will have the same number of bit collisions as a 512 bit fingerprint without count simulation. This becomes more relevant the more bits a fingerprint tends to set. For example using count simulation to calculate similarity with the RDKit fingerprint, which sets a large number of bits, actually decreases the correlation with the similarity calculated with count vectors (see below for the plot) unless I also increase the overall length of the fingerprint."
  },
  {
    "objectID": "posts/2021-07-06-simulating-counts.html#results-and-discussion",
    "href": "posts/2021-07-06-simulating-counts.html#results-and-discussion",
    "title": "Simulating count fingerprints",
    "section": "Results and discussion",
    "text": "Results and discussion\nHere’s a summary of the results for the fingerprints I examine here\n\nRandom pairs\n\n\n\n\n\n\n\n\n\n\n\n\n\nFingerprint\nbits Spearman r\nbits MAE\nbits RMSE\ncount-simulation Spearman r\ncount-simulation MAE\ncount-simulation RMSE\nNote\n\n\n\n\nMorgan 2\n0.84\n0.097\n0.10\n0.90\n0.024\n0.036\n\n\n\nTopological torsions\n0.92\n0.026\n0.051\n0.98\n0.018\n0.029\n\n\n\nTopological torsions\n0.92\n0.026\n0.051\n0.99\n0.010\n0.021\n8192 bits for count simulation\n\n\nAtom pairs\n0.82\n0.031\n0.049\n0.90\n0.055\n0.066\n\n\n\nAtom pairs\n0.82\n0.031\n0.049\n0.96\n0.014\n0.023\n8192 bits for count simulation\n\n\nRDKit\n0.83\n0.079\n0.10\n0.94\n0.029\n0.045\n8192 bits for count simulation\n\n\n\n\n\nRelated pairs\n\n\n\n\n\n\n\n\n\n\n\n\n\nFingerprint\nbits Spearman r\nbits MAE\nbits RMSE\ncount-simulation Spearman r\ncount-simulation MAE\ncount-simulation RMSE\nNote\n\n\n\n\nMorgan 2\n0.94\n0.043\n0.062\n0.98\n0.019\n0.028\n\n\n\nTopological torsions\n0.90\n0.050\n0.079\n0.98\n0.021\n0.035\n\n\n\nTopological torsions\n0.90\n0.050\n0.079\n0.98\n0.018\n0.032\n8192 bits for count simulation\n\n\nAtom pairs\n0.91\n0.043\n0.067\n0.97\n0.052\n0.063\n\n\n\nAtom pairs\n0.91\n0.043\n0.067\n0.98\n0.020\n0.032\n8192 bits for count simulation\n\n\nRDKit\n0.91\n0.077\n0.11\n0.98\n0.034\n0.053\n8192 bits for count simulation\n\n\n\nUsing the count simulation strategies does improve the match between similarities calculated with bit vectors and those calculated with count vectors. The differences are statistically significant (results not shown here) and large enough to potentially be meaningful. MAE and RMSE values for the various fingerprints typically decrease by at least a factor of two and Spearman rank-order correlation in general increases quite a bit. These conclusions hold for both randomly paired molecules and related pairs with more dramatic differences seen at the lower ends of the similarity scale (the random pairs).\nNote that this analysis focuses solely on similarity. The extra information added by doing count simulation will most likely also influence the performance of machine learning models built using these fingerprints. But that’s for a future blog post.\nThe code to reproduce all of this, along with more plots, is below.\n\nfrom rdkit import Chem\nfrom rdkit.Chem import rdFingerprintGenerator\nfrom rdkit.Chem import rdMolDescriptors\nfrom rdkit import DataStructs\nfrom rdkit.Chem import Draw\nfrom rdkit.Chem.Draw import IPythonConsole\nfrom rdkit.Chem import rdDepictor\nrdDepictor.SetPreferCoordGen(True)\nimport numpy as np\nfrom scipy.stats import spearmanr\nfrom sklearn.metrics import median_absolute_error, mean_squared_error\nimport rdkit\nprint(rdkit.__version__)\n%pylab inline\n\n2021.09.1pre\nPopulating the interactive namespace from numpy and matplotlib"
  },
  {
    "objectID": "posts/2021-07-06-simulating-counts.html#some-technical-notes",
    "href": "posts/2021-07-06-simulating-counts.html#some-technical-notes",
    "title": "Simulating count fingerprints",
    "section": "Some technical notes:",
    "text": "Some technical notes:\n\nNote that this notebook uses a couple of features which did not work properly until the v2021.03.4 of the RDKit (which will be released in July).\nCount simulation is only generally available when working with the “new” fingerprint generators, so those are used throughout this notebook.\nCount simulation is used by default for atom pair and topological torsion fingerprints, both with the “new” fingerprint generators and the older fingerprinting functions."
  },
  {
    "objectID": "posts/2021-07-06-simulating-counts.html#construct-the-dataset.",
    "href": "posts/2021-07-06-simulating-counts.html#construct-the-dataset.",
    "title": "Simulating count fingerprints",
    "section": "Construct the dataset.",
    "text": "Construct the dataset.\nStart with our standard similarity comparison set:\n\nimport gzip\nwith gzip.open('../data/chembl21_25K.pairs.txt.gz','rt') as inf:\n    ls = [x.split() for x in inf.readlines()]\nms = [(Chem.MolFromSmiles(x[1]),Chem.MolFromSmiles(x[3])) for x in ls]\n\nThat’s weighted towards lower similarity values, get some pairs from the related compounds set:\n\nimport pickle\nfrom collections import namedtuple\nMCSRes=namedtuple('MCSRes',('smarts','numAtoms','numMols','avgNumMolAtoms','mcsTime'))\n\ndata = pickle.load(open('../data/scaffolds_revisited_again.simplified.pkl','rb'))\ndata2 = pickle.load(open('../data/scaffolds_expanded.simplified.pkl','rb'))\ndata += data2\n\n# keep only sets where the MCS was at least 50% of the average number of atoms:\nkeep = [x for x in data if x[2].numAtoms>=np.mean(x[2].avgNumMolAtoms)/2]\nlen(keep)\n\nimport random\nrandom.seed(0xf00d)\nrelated_pairs = []\n# keep only molecules matching the MCS:\nfor i,tpl in enumerate(keep):\n    assay,smis,mcs,svg = tpl\n    patt = Chem.MolFromSmarts(mcs.smarts)\n    smis = [(x,y) for x,y in smis if Chem.MolFromSmiles(y).HasSubstructMatch(patt)]\n    ssmis = smis[:]\n    random.shuffle(ssmis)\n    related_pairs.extend([(x[0],x[1],y[0],y[1]) for x,y in zip(smis,ssmis)][:10])\nprint(f'{len(related_pairs)} related pairs')\nrelated_ms = [(Chem.MolFromSmiles(x[1]),Chem.MolFromSmiles(x[3])) for x in related_pairs]\n\n10470 related pairs\n\n\n\nlen(ms)\n\n25000\n\n\n\nimport random\nrandom.seed(0xf00d)\nindices = list(range(len(ms)))\nrandom.shuffle(indices)\nrandom_pairs = [ms[x] for x in indices[:5000]]\nindices = list(range(len(related_ms)))\nrandom.shuffle(indices)\nrelated_pairs = [related_ms[x] for x in indices[:5000]]"
  },
  {
    "objectID": "posts/2021-07-06-simulating-counts.html#performance-of-similarity-comparisons",
    "href": "posts/2021-07-06-simulating-counts.html#performance-of-similarity-comparisons",
    "title": "Simulating count fingerprints",
    "section": "Performance of similarity comparisons",
    "text": "Performance of similarity comparisons\n\nfpgen = rdFingerprintGenerator.GetMorganGenerator(radius=2,fpSize=2048,countSimulation=False)\nbv_pairs = [(fpgen.GetFingerprint(x[0]),fpgen.GetFingerprint(x[1])) for x in random_pairs]\ncv_pairs = [(fpgen.GetCountFingerprint(x[0]),fpgen.GetCountFingerprint(x[1])) for x in random_pairs]\n\n\n%timeit _ = [DataStructs.TanimotoSimilarity(x,y) for x,y in bv_pairs]\n\n5.06 ms ± 75 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)\n\n\n\n%timeit _ = [DataStructs.TanimotoSimilarity(x,y) for x,y in cv_pairs]\n\n8.37 ms ± 160 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)\n\n\nNot a huge difference there, but what about a fingerprint which sets a much larger number of bits?\n\nfpgen = rdFingerprintGenerator.GetRDKitFPGenerator(fpSize=2048,countSimulation=False)\nbv_pairs = [(fpgen.GetFingerprint(x[0]),fpgen.GetFingerprint(x[1])) for x in random_pairs]\ncv_pairs = [(fpgen.GetCountFingerprint(x[0]),fpgen.GetCountFingerprint(x[1])) for x in random_pairs]\n\n\n%timeit _ = [DataStructs.TanimotoSimilarity(x,y) for x,y in bv_pairs]\n\n6.22 ms ± 404 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)\n\n\n\n%timeit _ = [DataStructs.TanimotoSimilarity(x,y) for x,y in cv_pairs]\n\n189 ms ± 1.53 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)\n\n\nHere the performance difference is quite noticeable."
  },
  {
    "objectID": "posts/2021-07-06-simulating-counts.html#morgan-2",
    "href": "posts/2021-07-06-simulating-counts.html#morgan-2",
    "title": "Simulating count fingerprints",
    "section": "Morgan 2",
    "text": "Morgan 2\n\nfpgen1 = rdFingerprintGenerator.GetMorganGenerator(radius=2,fpSize=2048,countSimulation=False)\nfpsims = [DataStructs.TanimotoSimilarity(fpgen1.GetFingerprint(x[0]),fpgen1.GetFingerprint(x[1])) for x in ms]\ncountsims = [DataStructs.TanimotoSimilarity(fpgen1.GetCountFingerprint(x[0]),fpgen1.GetCountFingerprint(x[1])) for x in ms]\nrelated_fpsims = [DataStructs.TanimotoSimilarity(fpgen1.GetFingerprint(x[0]),fpgen1.GetFingerprint(x[1])) for x in related_ms]\nrelated_countsims = [DataStructs.TanimotoSimilarity(fpgen1.GetCountFingerprint(x[0]),fpgen1.GetCountFingerprint(x[1])) for x in related_ms]\n\n\nfpgen2 = rdFingerprintGenerator.GetMorganGenerator(radius=2,fpSize=2048,countSimulation=True)\nfpsims_countsim = [DataStructs.TanimotoSimilarity(fpgen2.GetFingerprint(x[0]),fpgen2.GetFingerprint(x[1])) for x in ms]\nrelated_fpsims_countsim = [DataStructs.TanimotoSimilarity(fpgen2.GetFingerprint(x[0]),fpgen2.GetFingerprint(x[1])) for x in related_ms]\n\n\ndelts = sorted([(countsims[i]-fpsims[i],i) for i in range(len(fpsims))])\nprint(delts[:5])\nprint(delts[-5:])\n\n[(-0.20329670329670324, 12408), (-0.19358178053830222, 14793), (-0.19191919191919193, 126), (-0.17673378076062635, 1391), (-0.17493796526054584, 13034)]\n[(0.31300539083557954, 20013), (0.3151412702245835, 12445), (0.3157622739018088, 13430), (0.3207792207792208, 4381), (0.37206896551724133, 11692)]\n\n\n\nidx = 13430\nprint(f'Count: {countsims[idx]:.2f}, Bits: {fpsims[idx]:.2f}, Simulated counts: {fpsims_countsim[idx]:.2f}')\nDraw.MolsToGridImage(ms[idx],subImgSize=(350,250),molsPerRow=2)\n\nCount: 0.60, Bits: 0.29, Simulated counts: 0.42\n\n\n\n\n\n\ndelts = sorted([(related_countsims[i]-related_fpsims[i],i) for i in range(len(related_fpsims))])\nprint(delts[:5])\nprint(delts[-5:])\n\n[(-0.26508684133058585, 4359), (-0.24506749740394607, 1322), (-0.2321428571428572, 7602), (-0.21353383458646613, 10080), (-0.20879676440849337, 3804)]\n[(0.24318181818181822, 1962), (0.24456938410426782, 1961), (0.24456938410426782, 1969), (0.2455492835432045, 1963), (0.273972602739726, 7774)]\n\n\n\nidx = 1969\nprint(f'Count: {related_countsims[idx]:.2f}, Bits: {related_fpsims[idx]:.2f}, Simulated counts: {related_fpsims_countsim[idx]:.2f}')\nDraw.MolsToGridImage(related_ms[idx],subImgSize=(350,250),molsPerRow=2)\n\nCount: 0.59, Bits: 0.35, Simulated counts: 0.52\n\n\n\n\n\n\nidx = 4359\nprint(f'Count: {related_countsims[idx]:.2f}, Bits: {related_fpsims[idx]:.2f}, Simulated counts: {related_fpsims_countsim[idx]:.2f}')\nDraw.MolsToGridImage(related_ms[idx],subImgSize=(350,250),molsPerRow=2)\n\nCount: 0.39, Bits: 0.65, Simulated counts: 0.51\n\n\n\n\n\n\nfigsize(18,9)\nsubplot(1,2,1)\ny,x = fpsims,countsims\nhexbin(x,y,cmap='Blues',bins='log');\nplot((0,1),(0,1),'k');\nxlabel('count')\nylabel('bits');\nsr,p = spearmanr(x,y)\nmae = median_absolute_error(x,y)\nrmse = sqrt(mean_squared_error(x,y))\ntitle(f'Random pairs, Morgan2 spearman r={sr:.3f} MAE={mae:.3f} RMSE={rmse:.3f}');\n\nsubplot(1,2,2)\ny,x = related_fpsims,related_countsims\nhexbin(x,y,cmap='Blues',bins='log');\nplot((0,1),(0,1),'k');\nxlabel('count')\nylabel('bits');\nsr,p = spearmanr(x,y)\nmae = median_absolute_error(x,y)\nrmse = sqrt(mean_squared_error(x,y))\ntitle(f'Related pairs, Morgan2 spearman r={sr:.3f} MAE={mae:.3f} RMSE={rmse:.3f}');\n\n\n\n\n\nfigsize(18,9)\nsubplot(1,2,1)\nx,y = countsims,fpsims_countsim\nhexbin(x,y,cmap='Blues',bins='log');\nplot((0,1),(0,1),'k');\nylabel('count simulation')\nxlabel('count');\nsr,p = spearmanr(x,y)\nmae = median_absolute_error(x,y)\nrmse = sqrt(mean_squared_error(x,y))\ntitle(f'Random pairs, Morgan2 spearman r={sr:.3f} MAE={mae:.3f} RMSE={rmse:.3f}');\n\nsubplot(1,2,2)\nx,y = related_countsims,related_fpsims_countsim\nhexbin(x,y,cmap='Blues',bins='log');\nplot((0,1),(0,1),'k');\nylabel('count simulation')\nxlabel('count');\nsr,p = spearmanr(x,y)\nmae = median_absolute_error(x,y)\nrmse = sqrt(mean_squared_error(x,y))\ntitle(f'Related pairs, Morgan2 spearman r={sr:.3f} MAE={mae:.3f} RMSE={rmse:.3f}');\n\n\n\n\n\nfpgen3 = rdFingerprintGenerator.GetMorganGenerator(radius=2,fpSize=8192,countSimulation=True)\nfpsims_countsim2 = [DataStructs.TanimotoSimilarity(fpgen3.GetFingerprint(x[0]),fpgen3.GetFingerprint(x[1])) for x in ms]\nrelated_fpsims_countsim2 = [DataStructs.TanimotoSimilarity(fpgen3.GetFingerprint(x[0]),fpgen3.GetFingerprint(x[1])) for x in related_ms]\n\n\nfigsize(18,9)\nsubplot(1,2,1)\nx,y = countsims,fpsims_countsim2\nhexbin(x,y,cmap='Blues',bins='log');\nplot((0,1),(0,1),'k');\nylabel('count simulation 8192')\nxlabel('count');\nsr,p = spearmanr(x,y)\nmae = median_absolute_error(x,y)\nrmse = sqrt(mean_squared_error(x,y))\ntitle(f'Random pairs, Morgan2 spearman r={sr:.3f} MAE={mae:.3f} RMSE={rmse:.3f}');\n\nsubplot(1,2,2)\nx,y = related_countsims,related_fpsims_countsim2\nhexbin(x,y,cmap='Blues',bins='log');\nplot((0,1),(0,1),'k');\nylabel('count simulation 8192')\nxlabel('count');\nsr,p = spearmanr(x,y)\nmae = median_absolute_error(x,y)\nrmse = sqrt(mean_squared_error(x,y))\ntitle(f'Related pairs, Morgan2 spearman r={sr:.3f} MAE={mae:.3f} RMSE={rmse:.3f}');"
  },
  {
    "objectID": "posts/2021-07-06-simulating-counts.html#topological-torsions",
    "href": "posts/2021-07-06-simulating-counts.html#topological-torsions",
    "title": "Simulating count fingerprints",
    "section": "Topological Torsions",
    "text": "Topological Torsions\n\nfpgen1 = rdFingerprintGenerator.GetTopologicalTorsionGenerator(fpSize=2048,countSimulation=False)\nfpsims = [DataStructs.TanimotoSimilarity(fpgen1.GetFingerprint(x[0]),fpgen1.GetFingerprint(x[1])) for x in ms]\ncountsims = [DataStructs.TanimotoSimilarity(fpgen1.GetCountFingerprint(x[0]),fpgen1.GetCountFingerprint(x[1])) for x in ms]\nrelated_fpsims = [DataStructs.TanimotoSimilarity(fpgen1.GetFingerprint(x[0]),fpgen1.GetFingerprint(x[1])) for x in related_ms]\nrelated_countsims = [DataStructs.TanimotoSimilarity(fpgen1.GetCountFingerprint(x[0]),fpgen1.GetCountFingerprint(x[1])) for x in related_ms]\nfpgen2 = rdFingerprintGenerator.GetTopologicalTorsionGenerator(fpSize=2048,countSimulation=True)\nfpsims_countsim = [DataStructs.TanimotoSimilarity(fpgen2.GetFingerprint(x[0]),fpgen2.GetFingerprint(x[1])) for x in ms]\nrelated_fpsims_countsim = [DataStructs.TanimotoSimilarity(fpgen2.GetFingerprint(x[0]),fpgen2.GetFingerprint(x[1])) for x in related_ms]\n\n\nfigsize(18,9)\nsubplot(1,2,1)\ny,x = fpsims,countsims\nhexbin(x,y,cmap='Blues',bins='log');\nplot((0,1),(0,1),'k');\nxlabel('count')\nylabel('bits');\nsr,p = spearmanr(x,y)\nmae = median_absolute_error(x,y)\nrmse = sqrt(mean_squared_error(x,y))\ntitle(f'Random pairs, TT spearman r={sr:.3f} MAE={mae:.3f} RMSE={rmse:.3f}');\nsubplot(1,2,2)\ny,x = related_fpsims,related_countsims\nhexbin(x,y,cmap='Blues',bins='log');\nplot((0,1),(0,1),'k');\nxlabel('count')\nylabel('bits');\nsr,p = spearmanr(x,y)\nmae = median_absolute_error(x,y)\nrmse = sqrt(mean_squared_error(x,y))\ntitle(f'Related pairs, TT spearman r={sr:.3f} MAE={mae:.3f} RMSE={rmse:.3f}');\n\n\n\n\n\nfigsize(18,9)\nsubplot(1,2,1)\nx,y = countsims,fpsims_countsim\nhexbin(x,y,cmap='Blues',bins='log');\nplot((0,1),(0,1),'k');\nylabel('count simulation')\nxlabel('count');\nsr,p = spearmanr(x,y)\nmae = median_absolute_error(x,y)\nrmse = sqrt(mean_squared_error(x,y))\ntitle(f'Random pairs, TT spearman r={sr:.3f} MAE={mae:.3f} RMSE={rmse:.3f}');\n\nsubplot(1,2,2)\nx,y = related_countsims,related_fpsims_countsim\nhexbin(x,y,cmap='Blues',bins='log');\nplot((0,1),(0,1),'k');\nylabel('count simulation')\nxlabel('count');\nsr,p = spearmanr(x,y)\nmae = median_absolute_error(x,y)\nrmse = sqrt(mean_squared_error(x,y))\ntitle(f'Related pairs, TT spearman r={sr:.3f} MAE={mae:.3f} RMSE={rmse:.3f}');\n\n\n\n\n\nfpgen3 = rdFingerprintGenerator.GetTopologicalTorsionGenerator(fpSize=8192,countSimulation=True)\nfpsims_countsim2 = [DataStructs.TanimotoSimilarity(fpgen3.GetFingerprint(x[0]),fpgen3.GetFingerprint(x[1])) for x in ms]\nrelated_fpsims_countsim2 = [DataStructs.TanimotoSimilarity(fpgen3.GetFingerprint(x[0]),fpgen3.GetFingerprint(x[1])) for x in related_ms]\nfigsize(18,9)\nsubplot(1,2,1)\nx,y = countsims,fpsims_countsim2\nhexbin(x,y,cmap='Blues',bins='log');\nplot((0,1),(0,1),'k');\nylabel('count simulation 8192')\nxlabel('count');\nsr,p = spearmanr(x,y)\nmae = median_absolute_error(x,y)\nrmse = sqrt(mean_squared_error(x,y))\ntitle(f'Random pairs, TT spearman r={sr:.3f} MAE={mae:.3f} RMSE={rmse:.3f}');\n\nsubplot(1,2,2)\nx,y = related_countsims,related_fpsims_countsim2\nhexbin(x,y,cmap='Blues',bins='log');\nplot((0,1),(0,1),'k');\nylabel('count simulation 8192')\nxlabel('count');\nsr,p = spearmanr(x,y)\nmae = median_absolute_error(x,y)\nrmse = sqrt(mean_squared_error(x,y))\ntitle(f'Related pairs, TT spearman r={sr:.3f} MAE={mae:.3f} RMSE={rmse:.3f}');"
  },
  {
    "objectID": "posts/2021-07-06-simulating-counts.html#atom-pairs",
    "href": "posts/2021-07-06-simulating-counts.html#atom-pairs",
    "title": "Simulating count fingerprints",
    "section": "Atom pairs",
    "text": "Atom pairs\n\nfpgen1 = rdFingerprintGenerator.GetAtomPairGenerator(fpSize=2048,countSimulation=False)\nfpsims = [DataStructs.TanimotoSimilarity(fpgen1.GetFingerprint(x[0]),fpgen1.GetFingerprint(x[1])) for x in ms]\ncountsims = [DataStructs.TanimotoSimilarity(fpgen1.GetCountFingerprint(x[0]),fpgen1.GetCountFingerprint(x[1])) for x in ms]\nrelated_fpsims = [DataStructs.TanimotoSimilarity(fpgen1.GetFingerprint(x[0]),fpgen1.GetFingerprint(x[1])) for x in related_ms]\nrelated_countsims = [DataStructs.TanimotoSimilarity(fpgen1.GetCountFingerprint(x[0]),fpgen1.GetCountFingerprint(x[1])) for x in related_ms]\n\nfpgen2 = rdFingerprintGenerator.GetAtomPairGenerator(fpSize=2048,countSimulation=True)\nfpsims_countsim = [DataStructs.TanimotoSimilarity(fpgen2.GetFingerprint(x[0]),fpgen2.GetFingerprint(x[1])) for x in ms]\nrelated_fpsims_countsim = [DataStructs.TanimotoSimilarity(fpgen2.GetFingerprint(x[0]),fpgen2.GetFingerprint(x[1])) for x in related_ms]\n\n\nfigsize(18,9)\nsubplot(1,2,1)\ny,x = fpsims,countsims\nhexbin(x,y,cmap='Blues',bins='log');\nplot((0,1),(0,1),'k');\nxlabel('count')\nylabel('bits');\nsr,p = spearmanr(x,y)\nmae = median_absolute_error(x,y)\nrmse = sqrt(mean_squared_error(x,y))\ntitle(f'Random pairs, AP spearman r={sr:.3f} MAE={mae:.3f} RMSE={rmse:.3f}');\n\nsubplot(1,2,2)\ny,x = related_fpsims,related_countsims\nhexbin(x,y,cmap='Blues',bins='log');\nplot((0,1),(0,1),'k');\nxlabel('count')\nylabel('bits');\nsr,p = spearmanr(x,y)\nmae = median_absolute_error(x,y)\nrmse = sqrt(mean_squared_error(x,y))\ntitle(f'Related pairs, AP spearman r={sr:.3f} MAE={mae:.3f} RMSE={rmse:.3f}');\n\n\n\n\n\nfigsize(18,9)\nsubplot(1,2,1)\nx,y = countsims,fpsims_countsim\nhexbin(x,y,cmap='Blues',bins='log');\nplot((0,1),(0,1),'k');\nylabel('count simulation')\nxlabel('count');\nsr,p = spearmanr(x,y)\nmae = median_absolute_error(x,y)\nrmse = sqrt(mean_squared_error(x,y))\ntitle(f'Random pairs, AP spearman r={sr:.3f} MAE={mae:.3f} RMSE={rmse:.3f}');\n\nsubplot(1,2,2)\nx,y = related_countsims,related_fpsims_countsim\nhexbin(x,y,cmap='Blues',bins='log');\nplot((0,1),(0,1),'k');\nylabel('count simulation')\nxlabel('count');\nsr,p = spearmanr(x,y)\nmae = median_absolute_error(x,y)\nrmse = sqrt(mean_squared_error(x,y))\ntitle(f'Related pairs, AP spearman r={sr:.3f} MAE={mae:.3f} RMSE={rmse:.3f}');\n\n\n\n\n\nfpgen3 = rdFingerprintGenerator.GetAtomPairGenerator(fpSize=8192,countSimulation=True)\nfpsims_countsim2 = [DataStructs.TanimotoSimilarity(fpgen3.GetFingerprint(x[0]),fpgen3.GetFingerprint(x[1])) for x in ms]\nrelated_fpsims_countsim2 = [DataStructs.TanimotoSimilarity(fpgen3.GetFingerprint(x[0]),fpgen3.GetFingerprint(x[1])) for x in related_ms]\n\n\nfigsize(18,9)\nsubplot(1,2,1)\nx,y = countsims,fpsims_countsim2\nhexbin(x,y,cmap='Blues',bins='log');\nplot((0,1),(0,1),'k');\nylabel('count simulation 8192')\nxlabel('count');\nsr,p = spearmanr(x,y)\nmae = median_absolute_error(x,y)\nrmse = sqrt(mean_squared_error(x,y))\ntitle(f'Random pairs, AP spearman r={sr:.3f} MAE={mae:.3f} RMSE={rmse:.3f}');\n\n\nsubplot(1,2,2)\nx,y = related_countsims,related_fpsims_countsim2\nhexbin(x,y,cmap='Blues',bins='log');\nplot((0,1),(0,1),'k');\nylabel('count simulation 8192')\nxlabel('count');\nsr,p = spearmanr(x,y)\nmae = median_absolute_error(x,y)\nrmse = sqrt(mean_squared_error(x,y))\ntitle(f'Related pairs, AP spearman r={sr:.3f} MAE={mae:.3f} RMSE={rmse:.3f}');"
  },
  {
    "objectID": "posts/2021-07-06-simulating-counts.html#rdkit-fingerprint",
    "href": "posts/2021-07-06-simulating-counts.html#rdkit-fingerprint",
    "title": "Simulating count fingerprints",
    "section": "RDKit Fingerprint",
    "text": "RDKit Fingerprint\n\nfpgen1 = rdFingerprintGenerator.GetRDKitFPGenerator(fpSize=2048,countSimulation=False)\nfpsims = [DataStructs.TanimotoSimilarity(fpgen1.GetFingerprint(x[0]),fpgen1.GetFingerprint(x[1])) for x in ms]\ncountsims = [DataStructs.TanimotoSimilarity(fpgen1.GetCountFingerprint(x[0]),fpgen1.GetCountFingerprint(x[1])) for x in ms]\nrelated_fpsims = [DataStructs.TanimotoSimilarity(fpgen1.GetFingerprint(x[0]),fpgen1.GetFingerprint(x[1])) for x in related_ms]\nrelated_countsims = [DataStructs.TanimotoSimilarity(fpgen1.GetCountFingerprint(x[0]),fpgen1.GetCountFingerprint(x[1])) for x in related_ms]\n\nfpgen2 = rdFingerprintGenerator.GetRDKitFPGenerator(fpSize=2048,countSimulation=True)\nfpsims_countsim = [DataStructs.TanimotoSimilarity(fpgen2.GetFingerprint(x[0]),fpgen2.GetFingerprint(x[1])) for x in ms]\nrelated_fpsims_countsim = [DataStructs.TanimotoSimilarity(fpgen2.GetFingerprint(x[0]),fpgen2.GetFingerprint(x[1])) for x in related_ms]\n\n\nfigsize(18,9)\n\nsubplot(1,2,1)\ny,x = fpsims,countsims\nhexbin(x,y,cmap='Blues',bins='log');\nplot((0,1),(0,1),'k');\nxlabel('count')\nylabel('bits');\nsr,p = spearmanr(x,y)\nmae = median_absolute_error(x,y)\nrmse = sqrt(mean_squared_error(x,y))\ntitle(f'Random pairs, RDKit spearman r={sr:.3f} MAE={mae:.3f} RMSE={rmse:.3f}');\n\nsubplot(1,2,2)\ny,x = related_fpsims,related_countsims\nhexbin(x,y,cmap='Blues',bins='log');\nplot((0,1),(0,1),'k');\nxlabel('count')\nylabel('bits');\nsr,p = spearmanr(x,y)\nmae = median_absolute_error(x,y)\nrmse = sqrt(mean_squared_error(x,y))\ntitle(f'Related pairs, RDKit spearman r={sr:.3f} MAE={mae:.3f} RMSE={rmse:.3f}');\n\n\n\n\n\nfigsize(18,9)\n\nsubplot(1,2,1)\nx,y = countsims,fpsims_countsim\nhexbin(x,y,cmap='Blues',bins='log');\nplot((0,1),(0,1),'k');\nylabel('count simulation')\nxlabel('count');\nsr,p = spearmanr(x,y)\nmae = median_absolute_error(x,y)\nrmse = sqrt(mean_squared_error(x,y))\ntitle(f'Random pairs, RDKit spearman r={sr:.3f} MAE={mae:.3f} RMSE={rmse:.3f}');\n\nsubplot(1,2,2)\nx,y = related_countsims,related_fpsims_countsim\nhexbin(x,y,cmap='Blues',bins='log');\nplot((0,1),(0,1),'k');\nylabel('count simulation')\nxlabel('count');\nsr,p = spearmanr(x,y)\nmae = median_absolute_error(x,y)\nrmse = sqrt(mean_squared_error(x,y))\ntitle(f'Related pairs, RDKit spearman r={sr:.3f} MAE={mae:.3f} RMSE={rmse:.3f}');\n\n\n\n\nThis is terrible, but I suspect that has to do with the number of bits set by RDKit fingerprints just totally overloading things.\n\nfpgen3 = rdFingerprintGenerator.GetRDKitFPGenerator(fpSize=8192,countSimulation=True)\nfpsims_countsim2 = [DataStructs.TanimotoSimilarity(fpgen3.GetFingerprint(x[0]),fpgen3.GetFingerprint(x[1])) for x in ms]\nrelated_fpsims_countsim2 = [DataStructs.TanimotoSimilarity(fpgen3.GetFingerprint(x[0]),fpgen3.GetFingerprint(x[1])) for x in related_ms]\n\nfigsize(18,9)\nsubplot(1,2,1)\nx,y = countsims,fpsims_countsim2\nhexbin(x,y,cmap='Blues',bins='log');\nplot((0,1),(0,1),'k');\nylabel('count simulation 8192')\nxlabel('count');\nsr,p = spearmanr(x,y)\nmae = median_absolute_error(x,y)\nrmse = sqrt(mean_squared_error(x,y))\ntitle(f'Random pairs, RDKit spearman r={sr:.3f} MAE={mae:.3f} RMSE={rmse:.3f}');\n\nsubplot(1,2,2)\nx,y = related_countsims,related_fpsims_countsim2\nhexbin(x,y,cmap='Blues',bins='log');\nplot((0,1),(0,1),'k');\nylabel('count simulation 8192')\nxlabel('count');\nsr,p = spearmanr(x,y)\nmae = median_absolute_error(x,y)\nrmse = sqrt(mean_squared_error(x,y))\ntitle(f'Related pairs, RDKit spearman r={sr:.3f} MAE={mae:.3f} RMSE={rmse:.3f}');\n\n\n\n\nThat’s way better"
  },
  {
    "objectID": "posts/2023-02-24-using-feature-maps.html",
    "href": "posts/2023-02-24-using-feature-maps.html",
    "title": "Using Feature Maps",
    "section": "",
    "text": "This is a revised and updated version of an older post.\nThis post provides a short demonstration of how to use the RDKit’s feature map implementation to score aligned 3D conformations against each other based on the overlap of their pharmacophoric features. The idea of the feature map is not a new one and there are numerous publications on the topic. These two come closest to describing the RDKit implementation:\n\nPutta, S., Landrum, G. A. & Penzotti, J. E. “Conformation mining: An algorithm for finding biologically relevant conformations.” J. Med. Chem. 48, 3313–3318 (2005). http://pubs.acs.org/doi/abs/10.1021/jm049066l\nLandrum, G. A., Penzotti, J. E. & Putta, S. “Feature-map vectors: a new class of informative descriptors for computational drug discovery.” J. Comput. Aided. Mol. Des. 20, 751–762 (2007). https://link.springer.com/article/10.1007/s10822-006-9085-8\n\n\nfrom rdkit.Chem import AllChem\nfrom rdkit import Chem\nfrom rdkit.Chem.Draw import IPythonConsole\nIPythonConsole.ipython_3d = True\nfrom rdkit.Chem import Draw\nimport time\nprint(time.asctime())\nfrom rdkit import rdBase\nprint(rdBase.rdkitVersion)\n\nFri Feb 24 09:44:30 2023\n2022.09.4\n\n\nFor this post we’ll use a set of three 5HT-3 ligands.\n\nsmis = ['CC(OC(=O)c1c[nH]c2ccccc12)C1CCCCN1C',\n 'CN1CCOc2c(C(=O)NC3CC4CCC(C3)N4C)cc(Cl)cc21',\n 'CN1CC2CCC1CC2n1nnc2ccc(Cl)cc2c1=O']\nms = [Chem.MolFromSmiles(x) for x in smis]\nDraw.MolsToGridImage(ms)\n\n\n\n\nStart by generating a conformation for each:\n\nms = [Chem.AddHs(m) for m in ms]\nps = AllChem.ETKDGv3()\nps.randomSeed = 0xf00d  # we seed the RNG so that this is reproducible\nfor m in ms:\n    AllChem.EmbedMolecule(m,ps)\n\nTo get sensible scores for the feature maps, we need to start from aligned structures. For this example we’ll just use the RDKit’s Open3D Align implementation:\n\nfrom rdkit.Chem import rdMolAlign\no3d = rdMolAlign.GetO3A(ms[1],ms[0])\no3d.Align()\n\n0.2892771161742461\n\n\n\no3d = rdMolAlign.GetO3A(ms[2],ms[0])\no3d.Align()\n\n0.5564120832536971\n\n\n\nimport py3Dmol\ndef drawit(ms, p=None, confId=-1, removeHs=True,colors=('cyanCarbon','redCarbon','blueCarbon')):\n        if p is None:\n            p = py3Dmol.view(width=400, height=400)\n        p.removeAllModels()\n        for i,m in enumerate(ms):\n            if removeHs:\n                m = Chem.RemoveHs(m)\n            IPythonConsole.addMolToView(m,p,confId=confId)\n        for i,m in enumerate(ms):\n            p.setStyle({'model':i,},\n                            {'stick':{'colorscheme':colors[i%len(colors)]}})\n        p.zoomTo()\n        return p.show()\n\n\ndrawit(ms)\n\n\n        You appear to be running in JupyterLab (or JavaScript failed to load for some other reason).  You need to install the 3dmol extension: \n        jupyter labextension install jupyterlab_3dmol\n        \n\n\n\nNow let’s build a feature map.\nWe need to start by building a FeatureFactory object which defines the set of pharmacophore features being used. We’ll use this to find features on the molecules.\n\nimport os\nfrom rdkit import RDConfig\nfrom rdkit.Chem.FeatMaps import FeatMaps\nfdef = AllChem.BuildFeatureFactory(os.path.join(RDConfig.RDDataDir,'BaseFeatures.fdef'))\nprint(fdef.GetFeatureFamilies())\n\n('Donor', 'Acceptor', 'NegIonizable', 'PosIonizable', 'ZnBinder', 'Aromatic', 'Hydrophobe', 'LumpedHydrophobe')\n\n\nWe also need the parameters for the points used to make up the feature map. The feature points are defined by - a FeatProfile - Gaussian, Triangle, or Box. Gaussian is the default. - a width - the precise meaning is determined by the profile, but this is the sigma factor for the Gaussian. The default value is 1.0. - a cutoff radius - Feature-feature overlaps at a distance longer than this will not be considered. The default is 2.5.\nHere we’ll take the defaults.\n\nfmParams = {}\nfor k in fdef.GetFeatureFamilies():\n    fparams = FeatMaps.FeatMapParams()\n    fmParams[k] = fparams\n\nNext go through and find the features on each molecule. We’ll only consider a subset of the features defined by the FeatureFactory. In “real” use we’d more likely use a FeatureFactory that only defines the features we are interested in, but this example of how to limit the features returned may still be interesting:\n\nkeep = ('Donor','Acceptor','NegIonizable','PosIonizable','Aromatic')\nfeatLists = []\nfor m in ms:\n    rawFeats = fdef.GetFeaturesForMol(m)\n    # filter that list down to only include the ones we're intereted in \n    featLists.append([f for f in rawFeats if f.GetFamily() in keep])\n\nLet’s look at the features:\n\nimport py3Dmol\nfrom rdkit.Chem.Features.ShowFeats import _featColors as featColors\ndef colorToHex(rgb):\n    rgb = [f'{int(255*x):x}' for x in rgb]\n    return '0x'+''.join(rgb)\ndef drawit(m, feats, p=None, confId=-1, removeHs=True):\n        if p is None:\n            p = py3Dmol.view(width=400, height=400)\n        p.removeAllModels()\n        if removeHs:\n            m = Chem.RemoveHs(m)\n        IPythonConsole.addMolToView(m,p,confId=confId)\n        for feat in feats:\n            pos = feat.GetPos()\n            clr = featColors.get(feat.GetFamily(),(.5,.5,.5))\n            p.addSphere({'center':{'x':pos.x,'y':pos.y,'z':pos.z},'radius':.5,'color':colorToHex(clr)});\n        p.zoomTo()\n        return p.show()\n\n\ndrawit(ms[0],featLists[0])\n\n\n        You appear to be running in JupyterLab (or JavaScript failed to load for some other reason).  You need to install the 3dmol extension: \n        jupyter labextension install jupyterlab_3dmol\n        \n\n\n\n\ndrawit(ms[1],featLists[1])\n\n\n        You appear to be running in JupyterLab (or JavaScript failed to load for some other reason).  You need to install the 3dmol extension: \n        jupyter labextension install jupyterlab_3dmol\n        \n\n\n\n\ndrawit(ms[2],featLists[2])\n\n\n        You appear to be running in JupyterLab (or JavaScript failed to load for some other reason).  You need to install the 3dmol extension: \n        jupyter labextension install jupyterlab_3dmol\n        \n\n\n\nThe fact that this one has neither acceptors nor an aromatic feature in the second planar six-ring indicates that we should take a look at the feature definitions. That’s a topic for another blog post.\nNow it’s straightforward to create FeatMap objects from the feature lists:\n\nfms = [FeatMaps.FeatMap(feats = x,weights=[1]*len(x),params=fmParams) for x in featLists]\n\nWe can, of course, draw a feature map as well. In these simple cases the feature maps look the same as drawing all of the molecule’s features:\n\ndef drawFeatMap(m, fMap, p=None, confId=-1, removeHs=True):\n        if p is None:\n            p = py3Dmol.view(width=400, height=400)\n        p.removeAllModels()\n        if removeHs:\n            m = Chem.RemoveHs(m)\n        IPythonConsole.addMolToView(m,p,confId=confId)\n        for feat in fMap.GetFeatures():\n            pos = feat.GetPos()\n            clr = featColors.get(feat.GetFamily(),(.5,.5,.5))\n            p.addSphere({'center':{'x':pos.x,'y':pos.y,'z':pos.z},'radius':feat.weight*.5,'color':colorToHex(clr)});\n        p.zoomTo()\n        return p.show()\n\n\ndrawFeatMap(ms[0],fms[0])\n\n\n        You appear to be running in JupyterLab (or JavaScript failed to load for some other reason).  You need to install the 3dmol extension: \n        jupyter labextension install jupyterlab_3dmol\n        \n\n\n\nNow let’s look at scoring the features from each molecule against the feature map. Since scores are affected by the number of features in each FeatMap, we’ll normalize here using the number of features in the molecule with less features.\n\nfms[0].ScoreFeats(fms[1].GetFeatures())/min(fms[0].GetNumFeatures(),fms[1].GetNumFeatures())\n\n0.31955076703314267\n\n\n\nfms[0].ScoreFeats(fms[2].GetFeatures())/min(fms[0].GetNumFeatures(),fms[2].GetNumFeatures())\n\n0.815994417450649\n\n\n\nfms[1].ScoreFeats(fms[2].GetFeatures())/min(fms[1].GetNumFeatures(),fms[2].GetNumFeatures())\n\n0.12773080957394894\n\n\nAn aside: since the weights on the features in FeatMap are all 1.0, the scoring is symmetric:\n\nfms[2].ScoreFeats(fms[1].GetFeatures())/min(fms[0].GetNumFeatures(),fms[2].GetNumFeatures())\n\n0.12773080957394894\n\n\nThe ScoreFeats() method can also generate a feature map vector: the breakdown of the score by the contributions of individual features in the feature map.\n\nscoreVect = [0]*fms[2].GetNumFeatures()\nfms[2].ScoreFeats(featLists[1],mapScoreVect=scoreVect)\nscoreVect\n\n[0.0, 0.47597567297942583, 0.0, 0.03494756531636994]\n\n\n\nscoreVect = [0]*fms[2].GetNumFeatures()\nfms[2].ScoreFeats(featLists[0],mapScoreVect=scoreVect)\nscoreVect\n\n[0.900252447002704, 0.4636038094112722, 0.900252447002704, 0.999868966385916]\n\n\nFeature map vectors can also be used as descriptors for machine learning, as shown in the second reference mentioned above. If I find a good example system I’ll try and do a blog post on that as well.\nHopefully others find this brief introduction to the RDKit’s FeatMap implementation useful."
  },
  {
    "objectID": "posts/2020-01-30-finding-regioisomers.html",
    "href": "posts/2020-01-30-finding-regioisomers.html",
    "title": "Finding regioisomers",
    "section": "",
    "text": "This is one that came up recently on the mailing list that I thought made for a good example to demonstrate how to write Python to do some more advanced structural searches with the RDKit.\n\nfrom rdkit import Chem\nfrom rdkit.Chem import Draw\nfrom rdkit.Chem.Draw import IPythonConsole\nimport rdkit\nprint(rdkit.__version__)\n\n2019.09.3\n\n\nRDKit WARNING: [05:43:19] Enabling RDKit 2019.09.3 jupyter extensions\n\n\nMy paraphrasing of the problem: Alexis wanted to be able to do the equivalent of a substructure search that finds all aromatic rings that have both Cl and Br substituents. So he wanted to be able to match the first two of these, but not the second:\n\nms = [Chem.MolFromSmiles(x) for x in 'Clc1c(Br)cccc1 Clc1cc(Br)ccc1 Clc1cccc2c1c(Br)ccc2'.split()]\nDraw.MolsToGridImage(ms,legends='match match no-match'.split())\n\n\n\n\nIt’s really non-trivial to do this with SMARTS since it has no way to express that two atoms should be in the same ring without making the ring explicit in the SMARTS. I was able to come up with this SMARTS, which works, but is unwieldy (at best):\n\np = Chem.MolFromSmarts('Cl[c;$(c1(Cl)c(Br)cccc1),$(c1(Cl)cc(Br)ccc1),$(c1(Cl)ccc(Br)cc1)]')\nprint([m.HasSubstructMatch(p) for m in ms])\n\n[True, True, False]\n\n\nSo that does what we want, but it only handles six rings where every atom is a C. That second part is easy enough to change in the SMARTS, but handling other ring sizes starts to make the SMARTS really long.\nA more difficult problem is that, because we use recursive SMARTS, we can’t get the atoms matching the query. The pattern I used above would only return the Cl atom and the C atom it’s connected to. I’m not sure Alexis even wanted to do that, but by this point I was interested in the problem and decided to write some Python to solve the problem flexibly.\nHere we go.\nBefore introducing the code and showing what it can do, a quick intro on the two pieces of functionality I’m going to be using from Python’s itertools module. These are really useful.\nLet’s start with using itertools to flatten a sequence of sequences:\n\nimport itertools\nseqs = [[1,2,3],['a','b'],[10,20]]\nlist(itertools.chain.from_iterable(seqs))\n\n[1, 2, 3, 'a', 'b', 10, 20]\n\n\nAnd to generate all the permutations of combinations of those sequences:\n\nlist(itertools.product(*seqs))\n\n[(1, 'a', 10),\n (1, 'a', 20),\n (1, 'b', 10),\n (1, 'b', 20),\n (2, 'a', 10),\n (2, 'a', 20),\n (2, 'b', 10),\n (2, 'b', 20),\n (3, 'a', 10),\n (3, 'a', 20),\n (3, 'b', 10),\n (3, 'b', 20)]\n\n\nOk, that’s the background, let’s define the functions we’ll use:\n\nimport itertools\ndef getAromaticRings(mol):\n    \"\"\" generator returning all aromatic rings (=only aromatic bonds) in a molecule \n    \n    Parameters\n    ----------\n    mol : Mol\n\n    Yields\n    ------\n    set\n        IDs of the atoms in an aromatic ring\n    \n    \"\"\"\n    ri = mol.GetRingInfo()\n    for ring in ri.BondRings():\n        ats = set()\n        isArom = True\n        for bi in ring:\n            bnd = mol.GetBondWithIdx(bi)\n            if not bnd.GetIsAromatic():\n                isArom = False\n                break\n            ats.add(bnd.GetBeginAtomIdx())\n            ats.add(bnd.GetEndAtomIdx())\n        if isArom:\n            yield ats\n\ndef getSharedRings(mol,queries,rings=None,excludeQueries=None):\n    \"\"\" generator returning all rings that contain all the atoms defined in queries \n        the first atom matching each query should be in the ring\n\n    Parameters\n    ----------\n    mol : Mol\n    queries : sequence of Mols\n    rings : list/tuple/set of list/tuple/sets, optional\n        sequence of rings defined by sequences of atom ids\n        If this isn't provided, all of the molecule's rings will be used\n    excludeQueries : sequence of Mols, optional\n        any ring containing an atom matching the first atom in any of these queries\n        will be excluded\n\n    Yields\n    -------\n    set\n       containing atom IDs for a matching ring\n\n    \"\"\"\n    if rings is None:\n        rings = mol.GetRingInfo().AtomRings()\n    alreadySeen = []\n    rings = [set(x) for x in rings]\n    matchSets = [[x[0] for x in mol.GetSubstructMatches(q)] for q in queries]\n    if excludeQueries is not None:\n        exclude = [[x[0] for x in mol.GetSubstructMatches(q)] for q in excludeQueries]\n        # flatten the lists of matches into a set:\n        exclude = set(itertools.chain.from_iterable(exclude))\n    else:\n        exclude = set()\n    for combo in itertools.product(*matchSets):\n        scombo = set(combo)\n        if len(scombo) < len(combo):\n            # degenerate:\n            continue\n        for ring in rings:\n            if ring in alreadySeen:\n                continue\n            if scombo.issubset(ring) and exclude.isdisjoint(ring):\n                alreadySeen.append(ring)\n                yield ring\n\ndef drawMolWithRings(mol,rings):\n    \"\"\" draws a molecule with a set of rings highlighted\n    \n    Parameters\n    ----------\n    mol : Mol\n    rings : list/tuple/set of list/tuple/sets\n        sequence of rings defined by sequences of atom IDs\n\n    Returns\n    -------\n    Image\n\n    \"\"\"\n    bondsToHighlight=[]\n    for bnd in mol.GetBonds():\n        keep = False\n        ats = set([bnd.GetBeginAtomIdx(),bnd.GetEndAtomIdx()])\n        for ring in rings:\n            if ats.issubset(ring):\n                keep = True\n                break\n        if keep:\n            bondsToHighlight.append(bnd.GetIdx())\n    highlightAtoms = list(itertools.chain.from_iterable(rings))\n\n    tmol = Draw.PrepareMolForDrawing(mol)\n    d2d = Draw.MolDraw2DCairo(300, 250)\n    d2d.DrawMolecule(tmol, highlightAtoms=highlightAtoms, \n                     highlightBonds = bondsToHighlight)\n    d2d.FinishDrawing()\n    return Draw._drawerToImage(d2d)\n\nThis is the molecule we’ll work with:\n\nmol = Chem.MolFromSmiles('c1c(Cl)cc(Br)c2c1CCc3c2cc(Cl)c4c3CCC(Cl)C4Br')\nmol\n\n\n\n\nShow what the getAromaticRings() function returns here:\n\nrings = list(getAromaticRings(mol))\nrings\n\n[{0, 1, 3, 4, 6, 7}, {10, 11, 12, 13, 15, 16}]\n\n\nWe can use drawMolWithRings() to highlight those atoms:\n\ndrawMolWithRings(mol,rings)\n\n\n\n\nNow let’s look at Alexis’ question: find all the aromatic rings that have a Cl and a Br attached:\n\nmatches = list(getSharedRings(mol,[Chem.MolFromSmarts(sma) for sma in ('[a]-Cl','[a]-Br')],\n                              rings=getAromaticRings(mol)))\nprint(matches)\ndrawMolWithRings(mol,matches)\n\n[{0, 1, 3, 4, 6, 7}]\n\n\n\n\n\nWhat about aromatic rings that have both a Cl and an aliphatic C attached?\n\nmatches = list(getSharedRings(mol,[Chem.MolFromSmarts(sma) for sma in ('[a]-Cl','[a]-C')],\n                             rings=getAromaticRings(mol)))\nprint(matches)\ndrawMolWithRings(mol,matches)\n\n[{0, 1, 3, 4, 6, 7}, {16, 10, 11, 12, 13, 15}]\n\n\n\n\n\nWhat about just finding any rings (not just aromatic) that have both Cl and Br connected?\nHere we just drop the rings argument to getSharedRings(), it will use all of the molecule’s rings:\n\nmatches = list(getSharedRings(mol,[Chem.MolFromSmarts(sma) for sma in ('[*]-Cl','[*]-Br')]))\nprint(matches)\ndrawMolWithRings(mol,matches)\n\n[{0, 1, 3, 4, 6, 7}, {15, 16, 17, 18, 19, 21}]\n\n\n\n\n\nWe can also find any rings that have a Cl, but not a Br:\n\nmatches = list(getSharedRings(mol,[Chem.MolFromSmarts(sma) for sma in ('[*]-Cl',)],\n                              excludeQueries=[Chem.MolFromSmarts(sma) for sma in ('[*]-Br',)]))\nprint(matches)\ndrawMolWithRings(mol,matches)\n\n[{10, 11, 12, 13, 15, 16}]\n\n\n\n\n\nWe aren’t limited to just six membered rings, of course. Go back to the original query for aromatic rings with both Cl and Br attached:\n\nmol = Chem.MolFromSmiles('Clc1[nH]c(Br)c(c2ccc(Cl)c(Br)c2)c1')\nmatches = list(getSharedRings(mol,[Chem.MolFromSmarts(sma) for sma in ('[*]-Cl','[*]-Br')],\n                              rings=getAromaticRings(mol)))\nprint(matches)\ndrawMolWithRings(mol,matches)\n\n[{1, 2, 3, 5, 14}, {6, 7, 8, 9, 11, 13}]\n\n\n\n\n\nWhat about aromatic rings that have both Cl and Br attached, but that don’t contain a heteroatom?\n\nmol = Chem.MolFromSmiles('Clc1[nH]c(Br)c(c2ccc(Cl)c(Br)c2)c1')\nmatches = list(getSharedRings(mol,[Chem.MolFromSmarts(sma) for sma in ('[*]-Cl','[*]-Br')],\n                              rings=getAromaticRings(mol),\n                              excludeQueries=[Chem.MolFromSmarts(sma) for sma in ('[a;!#6]',)]))\nprint(matches)\ndrawMolWithRings(mol,matches)\n\n[{6, 7, 8, 9, 11, 13}]\n\n\n\n\n\nHopefully there’s some useful stuff in here for you!"
  },
  {
    "objectID": "posts/2022-06-22-variability-of-pmi-descriptors.html",
    "href": "posts/2022-06-22-variability-of-pmi-descriptors.html",
    "title": "Variability of PMI descriptors",
    "section": "",
    "text": "Earlier this year Axel asked about the differences in PMI (princile moments of inertia) values between different stereoisomers of the same molecule. I guessed, but wasn’t sure, that the differences arising from different stereoisomers would be small relative to those arising from inter-conformer variability in the structure.\nThis post looks into that question.\n\nfrom rdkit import Chem\nfrom rdkit.Chem import rdDistGeom\nfrom rdkit.Chem import rdMolDescriptors\nfrom rdkit.Chem import Descriptors\nfrom rdkit.Chem import rdDepictor\nrdDepictor.SetPreferCoordGen(True)\nfrom rdkit.Chem.Draw import IPythonConsole\nfrom rdkit.Chem import Draw\nimport numpy as np\nimport rdkit\nprint(rdkit.__version__)\n%pylab inline\n\n2022.03.2\n%pylab is deprecated, use %matplotlib inline and import the required libraries.\nPopulating the interactive namespace from numpy and matplotlib\n\n\nStart by reading in 50 molecules from the platinum dataset which have at least one chiral center.\nNote that as of the 2022.03.3 release of the RDKit the explicit call to AssignStereochemistryFrom3D() is no longer necessary for molecules which have 3D conformers. We changed the default behavior so that this function is called whenever a molecule has a 3D conformer.\n\nwith Chem.SDMolSupplier('../data/platinum_dataset_2017_01.sdf',removeHs=False) as suppl:\n    ms = []\n    while len(ms)<50:\n        m = next(suppl)\n        if not m:\n            continue\n        Chem.AssignStereochemistryFrom3D(m)\n        if len(Chem.FindMolChiralCenters(m))<1:\n            continue\n        ms.append(m)\n\nLook at the number of chiral centers present in each molecule\n\nfigsize(6,6)\nhist([len(Chem.FindPotentialStereo(m)) for m in ms],bins=20);\nxlabel('num chiral centers')\nylabel('count');\n\n\n\n\n\ninter-conformer variability for a single stereoisomer\nStart by generating 100 conformers for each of our molecules.\nWe will only generate conformers which match the stereochemistry of the input structure (this is the default RDKit behavior).\n\nps = rdDistGeom.srETKDGv3()\nps.numThreads = 6\nps.randomSeed = 0xf00d\nps.pruneRmsThresh = 0.5\n\nfor m in ms:\n    rdDistGeom.EmbedMultipleConfs(m,100,ps)\n\nGenerate the three PMI descriptors for each conformer of each molecule (note that PMI1 is the smallest principle moment).\n\naccum = []\nfor m in ms:\n    confs = m.GetConformers()\n    d = []\n    for conf in confs:\n        d.append((rdMolDescriptors.CalcPMI1(m,confId=conf.GetId()),\n        rdMolDescriptors.CalcPMI2(m,confId=conf.GetId()),\n        rdMolDescriptors.CalcPMI3(m,confId=conf.GetId())))\n    accum.append(np.array(d))\n\nLook at the inter-conformer variability, as measured by the relative standard deviation, of the three descriptors\n\nfigsize(9,6)\nmeans = np.array([np.average(mat,axis=0) for mat in accum])\nstds = np.array([np.std(mat,axis=0) for mat in accum])\nrel_stds = stds/means\nhist(rel_stds,bins=10,label=('PMI1','PMI2','PMI3'));\nlegend();\ntitle('inter-conformer variation, single stereoisomer')\nxlabel('relative std dev');\n\n\n\n\nAnd let’s look at the standard deviations themselves:\n\nfigsize(9,6)\nhist(stds,bins=10,label=('PMI1','PMI2','PMI3'));\nlegend();\ntitle('inter-conformer variation, single stereoisomer')\nxlabel('std dev');\n\n\n\n\n\n\nVariability across conformers and stereoisomers\n\nm2s = [Chem.Mol(m) for m in ms]\n\n\nps = rdDistGeom.srETKDGv3()\nps.numThreads = 6\nps.randomSeed = 0xf00d\nps.pruneRmsThresh = 0.5\nps.enforceChirality = False\n\nfor m in m2s:\n    rdDistGeom.EmbedMultipleConfs(m,100,ps)\n\n\naccum2 = []\nfor m in m2s:\n    confs = m.GetConformers()\n    d = []\n    for conf in confs:\n        d.append((rdMolDescriptors.CalcPMI1(m,confId=conf.GetId()),\n        rdMolDescriptors.CalcPMI2(m,confId=conf.GetId()),\n        rdMolDescriptors.CalcPMI3(m,confId=conf.GetId())))\n    accum2.append(np.array(d))\n\n\nfigsize(9,6)\nmeans2 = np.array([np.average(mat,axis=0) for mat in accum2])\nstds2 = np.array([np.std(mat,axis=0) for mat in accum2])\nrel_stds2 = stds2/means2\nhist(rel_stds2,bins=10,label=('PMI1','PMI2','PMI3'));\nlegend();\ntitle('inter-conformer variation, multiple stereoisomers')\nxlabel('relative std dev');\n\n\n\n\n\n\nCompare the single stereisomer variability to the multiple stereoisomer variability\nFirst make sure that the means don’t actually change\n\nfigsize(6,6)\nscatter((means)[:,0],(means2)[:,0],label='PMI1');\nscatter((means)[:,1],(means2)[:,1],label='PMI2');\nscatter((means)[:,2],(means2)[:,2],label='PMI3');\n\nylabel('multiple stereoisomers')\nxlabel('single stereoisomer');\ntitle('mean')\nlegend()\nplot((0,25000),(0,25000),'k');\n\n\n\n\nThat looks good\n\nfigsize(6,6)\n\nscatter((stds/means)[:,0],(stds2/means2)[:,0],label='PMI1');\nscatter((stds/means)[:,1],(stds2/means2)[:,1],label='PMI2');\nscatter((stds/means)[:,2],(stds2/means2)[:,2],label='PMI3');\n\nylabel('multiple stereoisomers')\nxlabel('single stereoisomer');\ntitle('relative std dev')\nlegend()\nplot((0,0.35),(0,0.35),'k');\n\n\n\n\nSo, at least for this set of 50 molecules, it looks like the answer to Axel’s question is that the differences in PMI which arise from differing stereoisomers are small relative to the differences between conformers.\nLet’s still dig into the results a little bit. Which molecule(s) have the highest deviation for each of the moments?\n\nindices = (argmax((stds2/means2)[:,0]-(stds/means)[:,0]),\\\nargmax((stds2/means2)[:,1]-(stds/means)[:,1]),\\\nargmax((stds2/means2)[:,2]-(stds/means)[:,2]))\nindices\n\n(13, 13, 37)\n\n\nLet’s look at those two molecules\n\nIPythonConsole.molSize = 350,350\nIPythonConsole.drawOptions.addAtomIndices = True\n\nmaxdevs = [Chem.RemoveHs(Chem.Mol(ms[x])) for x in (13,37)]\nfor md in maxdevs:\n           rdDepictor.Compute2DCoords(md)\nDraw.MolsToGridImage(maxdevs,subImgSize=(350,350),molsPerRow=2)\n\n\n\n\nJust to be sure, check which atoms can be stereo:\n\nChem.AssignStereochemistry(maxdevs[0],force=True,flagPossibleStereoCenters=True)\nfor atom in maxdevs[0].GetAtoms():\n    if atom.HasProp('_ChiralityPossible'):\n        print(atom.GetIdx())\n\n11\n16\n\n\nLook at one of the conformers:\n\nIPythonConsole.ipython_3d = True\nms[13]\n\n\n        You appear to be running in JupyterLab (or JavaScript failed to load for some other reason).  You need to install the 3dmol extension: \n        jupyter labextension install jupyterlab_3dmol"
  },
  {
    "objectID": "posts/2023-01-23-colliding-bits-iii-expanded.html",
    "href": "posts/2023-01-23-colliding-bits-iii-expanded.html",
    "title": "Colliding bits III, expanded",
    "section": "",
    "text": "This is an updated and expanded version of an old post\nI looked at the number of collisions in Morgan fingerprints in an earlier post. The topic came up again in discussions about the recent post on Morgan fingerprint stats, which used a much larger data set.\nHere I repeat the earlier collision analysis using a dataset of 4 million compounds and look at a number of different fingerprint types – Morgan fingeprints of various radii, RDKit fingerprints, atom pair fingerprints, and topological torsion fingerprints– folded to a set of different sizes – 64, 128, 256, 512, 1K, 2K, 4K, 8K, 16K.\nAfter evaluating the number of collisions, I look at the impact that fingerprint size has on computed similarity values.\nTL;DR version: The conclusions match what I observed before, there are a fair number of collisions at fingerprint sizes below 4K. As you would expect, fingerprints with more bits set have more collisions.\nHere’s a table with some of the comparisons between Tanimoto similarities calculated with folded fingerprint and those with unfolded fingerprints (the full table is towards the end of the post). In the table d refers to the difference between similarities calculated with the folded and unfolded (=“no” collisions) fingerprint at a particular size. Positive values of d indicate that the similarity with the folded fingerprint is higher than that with the unfolded fingerprint. SpearmanR is the Spearman correlation coefficient between the folded and unfolded similarities.\n\n\n\nnBits\nfingerprint\nSpearmanR\nmean(d)\nstd(d)\n90% |d|\n\n\n\n\n16384\nmfp1\n1.000\n0.00023\n0.0025\n0\n\n\n16384\nmfp2\n0.999\n0.00085\n0.0036\n0.0034\n\n\n16384\nmfp3\n0.999\n0.0014\n0.0038\n0.0056\n\n\n16384\nrdk5\n1.000\n0.0054\n0.0046\n0.012\n\n\n16384\nhashap\n0.997\n0.0066\n0.0072\n0.016\n\n\n16384\nhashtt\n0.999\n0.0024\n0.0074\n0.011\n\n\n1024\nmfp1\n0.989\n0.0067\n0.016\n0.028\n\n\n1024\nmfp2\n0.990\n0.014\n0.016\n0.036\n\n\n1024\nmfp3\n0.987\n0.022\n0.017\n0.044\n\n\n1024\nrdk5\n0.981\n0.085\n0.049\n0.15\n\n\n1024\nhashap\n0.874\n0.1\n0.051\n0.17\n\n\n1024\nhashtt\n0.983\n0.025\n0.026\n0.061\n\n\n512\nmfp1\n0.980\n0.013\n0.021\n0.044\n\n\n512\nmfp2\n0.979\n0.028\n0.023\n0.059\n\n\n512\nmfp3\n0.972\n0.044\n0.026\n0.078\n\n\n512\nrdk5\n0.929\n0.16\n0.09\n0.28\n\n\n512\nhashap\n0.702\n0.19\n0.083\n0.3\n\n\n512\nhashtt\n0.967\n0.046\n0.037\n0.096\n\n\n128\nmfp1\n0.918\n0.049\n0.043\n0.11\n\n\n128\nmfp2\n0.897\n0.11\n0.054\n0.18\n\n\n128\nmfp3\n0.839\n0.17\n0.066\n0.25\n\n\n128\nrdk5\n0.528\n0.42\n0.2\n0.68\n\n\n128\nhashap\n0.343\n0.42\n0.12\n0.57\n\n\n128\nhashtt\n0.828\n0.17\n0.085\n0.28\n\n\n64\nmfp1\n0.832\n0.099\n0.064\n0.18\n\n\n64\nmfp2\n0.771\n0.2\n0.083\n0.31\n\n\n64\nmfp3\n0.642\n0.31\n0.1\n0.44\n\n\n64\nrdk5\n0.235\n0.5\n0.22\n0.77\n\n\n64\nhashap\n0.158\n0.51\n0.13\n0.65\n\n\n64\nhashtt\n0.672\n0.28\n0.12\n0.43\n\n\n\nDown to a fingerprint size of 1024 bits all the fingerprints except hashap have an R of >0.90 and comparatively low deviations (last column). With the very small 128 bit fingerprints only the mfp1 and mfp2 (both of which don’t set many bits) are showing halfway decent performance, and with 64bit fingerprints the deviations are large for all fingerprint types (though the R values for mfp1 and mfp2 are surprisingly high).\nThere are a number of things worth further exploration here, but those will be other blog posts.\n\nfrom rdkit import Chem,DataStructs\nimport time,random,gzip,pickle,copy\nimport numpy as np\nfrom collections import defaultdict\nfrom rdkit.Chem import Draw\nfrom rdkit.Chem import rdFingerprintGenerator\nfrom rdkit.Chem.Draw import IPythonConsole\nfrom rdkit import DataStructs\nimport rdkit\n%pylab inline\nplt.style.use('tableau-colorblind10')\nplt.rcParams['font.size'] = '14'\nprint(rdkit.__version__)\nimport time\nprint(time.asctime())\n\n%pylab is deprecated, use %matplotlib inline and import the required libraries.\nPopulating the interactive namespace from numpy and matplotlib\n2022.09.1\nWed Jan 18 13:22:54 2023\n\n\n/localhome/glandrum/.conda/envs/py310_rdkit/lib/python3.10/site-packages/IPython/core/magics/pylab.py:162: UserWarning: pylab import has clobbered these variables: ['random', 'copy']\n`%matplotlib` prevents importing * from pylab and numpy\n  warn(\"pylab import has clobbered these variables: %s\"  % clobbered +\n\n\n\nGenerating the data\nFor test data I’ll use the 4 million random compounds from PubChem with <=50 heavy atoms. I constructed the set of compounds by downloading the full pubchem compound set (on 8 Jan, 2023), and picking 10 million random lines using an awk script.\n\nfilen='/localhome/glandrum/Datasets/PubChem/pubchem_compound_random_10000000.txt.gz'\n\nLoop over the molecules and build fingerprints of multiple radii and folded lengths.\n\ngens = [('mfp1',lambda fpsize: rdFingerprintGenerator.GetMorganGenerator(radius=1,fpSize=fpsize)),\n        ('mfp2',lambda fpsize: rdFingerprintGenerator.GetMorganGenerator(radius=2,fpSize=fpsize)),\n         ('mfp3',lambda fpsize: rdFingerprintGenerator.GetMorganGenerator(radius=3,fpSize=fpsize)),\n         ('rdk5',lambda fpsize: rdFingerprintGenerator.GetRDKitFPGenerator(maxPath=5,fpSize=fpsize)),\n         ('hashap',lambda fpsize: rdFingerprintGenerator.GetAtomPairGenerator(fpSize=fpsize)),\n         ('hashtt',lambda fpsize: rdFingerprintGenerator.GetTopologicalTorsionGenerator(fpSize=fpsize)),\n         ]\n\n\nfrom rdkit import RDLogger\nRDLogger.DisableLog('rdApp.*')\nimport copy\nhistory={} # we will use this to see how quickly the results converge\ncounts=defaultdict(lambda:defaultdict(int))\nt1 = time.time()\ni = 0\nwith gzip.open(filen,'rb') as inf:\n    for inl in inf:\n        try:\n            nm,smi = inl.strip().split()\n        except:\n            break\n        m = Chem.MolFromSmiles(smi)\n        if m is None or m.GetNumHeavyAtoms()>50:\n            continue\n        i+=1\n        for nm,fpg in gens:\n            fpgen = fpg(1024) # doesn't matter here\n            onbits=len(fpgen.GetSparseFingerprint(m).GetOnBits())\n            counts[nm][onbits]+=1\n            for l in 64,128,256,512,1024,2048,4096,8192,16384:\n                fpnm = f'{nm}-{l}'\n                fpgen = fpg(l)\n                dbits = onbits-fpgen.GetFingerprint(m).GetNumOnBits()\n                counts[fpnm][dbits]+=1\n        if not i%50000:\n            t2 = time.time()\n            print(f\"Done {i} in {t2-t1:.2f} sec\")\n        if not i%100000:\n            history[i] = copy.deepcopy(counts)\n        if i>=4000000:\n            break\n\nDone 50000 in 214.60 sec\nDone 100000 in 475.92 sec\nDone 150000 in 790.69 sec\nDone 200000 in 1065.40 sec\nDone 250000 in 1350.49 sec\nDone 300000 in 1663.03 sec\nDone 350000 in 1979.41 sec\nDone 400000 in 2289.94 sec\nDone 450000 in 2584.58 sec\nDone 500000 in 2889.27 sec\nDone 550000 in 3156.72 sec\nDone 600000 in 3416.83 sec\nDone 650000 in 3673.20 sec\nDone 700000 in 3930.41 sec\nDone 750000 in 4232.50 sec\nDone 800000 in 4518.37 sec\nDone 850000 in 4788.19 sec\nDone 900000 in 5080.44 sec\nDone 950000 in 5272.51 sec\nDone 1000000 in 5507.97 sec\nDone 1050000 in 5831.47 sec\nDone 1100000 in 6124.22 sec\nDone 1150000 in 6405.13 sec\nDone 1200000 in 6699.62 sec\nDone 1250000 in 7004.17 sec\nDone 1300000 in 7264.67 sec\nDone 1350000 in 7525.13 sec\nDone 1400000 in 7779.24 sec\nDone 1450000 in 8045.30 sec\nDone 1500000 in 8314.90 sec\nDone 1550000 in 8643.98 sec\nDone 1600000 in 8978.91 sec\nDone 1650000 in 9292.37 sec\nDone 1700000 in 9596.19 sec\nDone 1750000 in 9854.10 sec\nDone 1800000 in 10134.48 sec\nDone 1850000 in 10407.01 sec\nDone 1900000 in 10729.17 sec\nDone 1950000 in 11005.57 sec\nDone 2000000 in 11183.76 sec\nDone 2050000 in 11527.20 sec\nDone 2100000 in 11831.40 sec\nDone 2150000 in 12141.98 sec\nDone 2200000 in 12413.20 sec\nDone 2250000 in 12708.59 sec\nDone 2300000 in 12979.10 sec\nDone 2350000 in 13263.71 sec\nDone 2400000 in 13504.37 sec\nDone 2450000 in 13755.21 sec\nDone 2500000 in 13974.78 sec\nDone 2550000 in 14282.01 sec\nDone 2600000 in 14586.37 sec\nDone 2650000 in 14844.31 sec\nDone 2700000 in 15153.73 sec\nDone 2750000 in 15473.13 sec\nDone 2800000 in 15783.14 sec\nDone 2850000 in 16093.12 sec\n\n\n\ncounts.keys()\n\ndict_keys(['mfp1', 'mfp1-64', 'mfp1-128', 'mfp1-256', 'mfp1-512', 'mfp1-1024', 'mfp1-2048', 'mfp1-4096', 'mfp1-8192', 'mfp1-16384', 'mfp2', 'mfp2-64', 'mfp2-128', 'mfp2-256', 'mfp2-512', 'mfp2-1024', 'mfp2-2048', 'mfp2-4096', 'mfp2-8192', 'mfp2-16384', 'mfp3', 'mfp3-64', 'mfp3-128', 'mfp3-256', 'mfp3-512', 'mfp3-1024', 'mfp3-2048', 'mfp3-4096', 'mfp3-8192', 'mfp3-16384', 'rdk5', 'rdk5-64', 'rdk5-128', 'rdk5-256', 'rdk5-512', 'rdk5-1024', 'rdk5-2048', 'rdk5-4096', 'rdk5-8192', 'rdk5-16384', 'hashap', 'hashap-64', 'hashap-128', 'hashap-256', 'hashap-512', 'hashap-1024', 'hashap-2048', 'hashap-4096', 'hashap-8192', 'hashap-16384', 'hashtt', 'hashtt-64', 'hashtt-128', 'hashtt-256', 'hashtt-512', 'hashtt-1024', 'hashtt-2048', 'hashtt-4096', 'hashtt-8192', 'hashtt-16384'])\n\n\n\npickle.dump(dict(counts),gzip.open('../data/fp_collision_counts.pkl.gz','wb+'))\n\n\nfor k,d in history.items():\n    history[k] = dict(d)\npickle.dump(dict(history),gzip.open('../data/fp_collision_counts.history.pkl.gz','wb+'))\n\n\nwith gzip.open('../data/fp_collision_counts.pkl.gz','rb') as inf:\n    counts = pickle.load(inf)\nwith gzip.open('../data/fp_collision_counts.history.pkl.gz','rb') as inf:\n    history = pickle.load(inf)\n\n\n\nQuantifying the number of collisions\nNow plot histograms of the numbers of collisions along with the distributions of the number of bits set in the non-folded FPs\n\nallCounts = (16384, 8192,4096,2048,1024,) #512,256,128,64)\n\nfigure(figsize=(16,5*len(allCounts)))\n\npidx=1\n#----------------------------\nfor nbits in allCounts:\n    subplot(len(allCounts),2,pidx)\n    pidx+=1\n    maxCollisions = max(counts[f'mfp3-{allCounts[-1]}'].keys())+1\n    d1=np.zeros(maxCollisions,int)\n    for k,v in counts[f'mfp1-{nbits}'].items():\n        d1[k]=v\n    d2=np.zeros(maxCollisions,int)\n    for k,v in counts[f'mfp2-{nbits}'].items():\n        d2[k]=v\n    d3=np.zeros(maxCollisions,int)\n    for k,v in counts[f'mfp3-{nbits}'].items():\n        d3[k]=v\n    barWidth=.25\n    locs = np.array(range(maxCollisions))\n\n    bar(locs,d1,barWidth,label=\"r=1\")\n    bar(locs+barWidth,d2,barWidth,label=\"r=2\")\n    bar(locs+2*barWidth,d3,barWidth,label=\"r=3\")\n    \n    #_=hist((d1,d2,d3),bins=20,log=True,label=(\"r=1\",\"r=2\",\"r=3\"))\n    title('%d bits'%nbits)\n    _=yscale(\"log\")\n    _=legend()\n    if nbits == allCounts[-1]:\n        xlabel('num collisions')\n    \n    subplot(len(allCounts),2,pidx)\n    pidx+=1\n    itms = list(sorted(counts['mfp1'].items()))\n    plot([x for x,y in itms],[y for x,y in itms],'.-',label=\n        \"r=1\")\n    itms = list(sorted(counts['mfp2'].items()))\n    plot([x for x,y in itms],[y for x,y in itms],'.-',label=\n        \"r=2\")\n    itms = list(sorted(counts['mfp3'].items()))\n    plot([x for x,y in itms],[y for x,y in itms],'.-',label=\n        \"r=3\")\n    if nbits == allCounts[-1]:\n        _=xlabel(\"num bits set\")\n    _=ylabel(\"count\")\n    _=legend()\n    \n    \n\n\n\n\nSo, there are definitely some collisions, particularly with radius 3 fingerprints with 1K bits.\nThe bimodal character of the mfp2 and mfp3 fingerprints is worth following up on: that wasn’t observed in the earlier post, which used a set of compounds from ZINC\nLook the short Morgan fingerprints\n\nallCounts = (512,256,128,64)\n\nfigure(figsize=(16,5*len(allCounts)))\n\npidx=1\n#----------------------------\nfor nbits in allCounts:\n    subplot(len(allCounts),2,pidx)\n    pidx+=1\n    maxCollisions = max(counts[f'mfp3-{allCounts[-1]}'].keys())+1\n    d1=np.zeros(maxCollisions,int)\n    for k,v in counts[f'mfp1-{nbits}'].items():\n        d1[k]=v\n    d2=np.zeros(maxCollisions,int)\n    for k,v in counts[f'mfp2-{nbits}'].items():\n        d2[k]=v\n    d3=np.zeros(maxCollisions,int)\n    for k,v in counts[f'mfp3-{nbits}'].items():\n        d3[k]=v\n    barWidth=.25\n    locs = np.array(range(maxCollisions))\n\n    bar(locs,d1,barWidth,label=\"r=1\")\n    bar(locs+barWidth,d2,barWidth,label=\"r=2\")\n    bar(locs+2*barWidth,d3,barWidth,label=\"r=3\")\n    \n    #_=hist((d1,d2,d3),bins=20,log=True,label=(\"r=1\",\"r=2\",\"r=3\"))\n    title('%d bits'%nbits)\n    _=yscale(\"log\")\n    _=legend()\n    if nbits == allCounts[-1]:\n        xlabel('num collisions')\n\n    subplot(len(allCounts),2,pidx)\n    pidx+=1\n    itms = list(sorted(counts['mfp1'].items()))\n    plot([x for x,y in itms],[y for x,y in itms],'.-',label=\n        \"r=1\")\n    itms = list(sorted(counts['mfp2'].items()))\n    plot([x for x,y in itms],[y for x,y in itms],'.-',label=\n        \"r=2\")\n    itms = list(sorted(counts['mfp3'].items()))\n    plot([x for x,y in itms],[y for x,y in itms],'.-',label=\n        \"r=3\")\n    if nbits == allCounts[-1]:\n        _=xlabel(\"num bits set\")\n    _=ylabel(\"count\")\n    _=legend()\n    \n    \n\n\n\n\nLook at the other fingerprint types. We’ll do this a little differently because of the scales.\nStart with the number of bits set:\n\nfigsize(8,5)\n\nitms = list(sorted(counts['hashtt'].items()))\nplot([x for x,y in itms],[y for x,y in itms],'.-',label=\n    \"hashtt\")\nitms = list(sorted(counts['hashap'].items()))\nplot([x for x,y in itms],[y for x,y in itms],'.-',label=\n    \"hashap\")\nitms = list(sorted(counts['rdk5'].items()))\nplot([x for x,y in itms],[y for x,y in itms],'.-',label=\n    \"rdk5\")\nif nbits == allCounts[-1]:\n    _=xlabel(\"num bits set\")\n_=ylabel(\"count\")\n_=legend()\n    \n    \n\n\n\n\nBoth the hashap and hadhtt distributions show more than one peak. Another thing to follow up on…\n\nallCounts = (16384, 8192,4096,2048,1024,) #512,256,128,64)\n\nfigure(figsize=(16,5*len(allCounts)))\n\npidx=1\n#----------------------------\nfor nbits in allCounts:\n    for fpt in ('hashtt','hashap','rdk5'):\n        subplot(len(allCounts),3,pidx)\n        pidx+=1\n        maxCollisions = max(counts[f'{fpt}-{allCounts[-1]}'].keys())+1\n        d1=np.zeros(maxCollisions,int)\n        for k,v in counts[f'{fpt}-{nbits}'].items():\n            d1[k]=v\n        barWidth=.25\n        locs = np.array(range(maxCollisions))\n\n        bar(locs,d1,barWidth,label=fpt)    \n        title(f'{fpt}-{nbits}')\n        _=yscale(\"log\")\n        _=legend()\n        if nbits == allCounts[-1]:\n            xlabel('num collisions')\n\n\n\n\nThe topological torsion FPs don’t have a huge number of collisions, but both atom pair and RDKit fingerprints really do have collisions, as one would expect given the number of set bits.\nLook at the percentage of compounds with <= a particular number of collisions\n\nbcounts = (64,128,256,512,1024,2048,4096,8192,16384)\nccounts = list(range(11))\n\n\nrow = ('length','fingerprint',)+tuple(str(x) for x in ccounts)\ndivider = ['-'*len(k) for k in row]\nprint('| '+' | '.join(row)+' |')\nprint('| '+' | '.join(divider)+' |')\n\nfor bc in reversed(bcounts):\n    for nm,fpg in gens:\n        row = [str(bc),nm]\n        fpn = f'{nm}-{bc}'\n        nmols = np.sum(np.fromiter((x for x in counts[fpn].values()),int))\n        accum = 0\n        for ccount in ccounts:\n            accum += counts[fpn].get(ccount,0)\n            row.append(f'{accum/nmols:.3f}')\n        print('| '+' | '.join(row)+' |')\n            \n\n| length | fingerprint | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |\n| ------ | ----------- | - | - | - | - | - | - | - | - | - | - | -- |\n| 16384 | mfp1 | 0.991 | 1.000 | 1.000 | 1.000 | 1.000 | 1.000 | 1.000 | 1.000 | 1.000 | 1.000 | 1.000 |\n| 16384 | mfp2 | 0.956 | 0.999 | 1.000 | 1.000 | 1.000 | 1.000 | 1.000 | 1.000 | 1.000 | 1.000 | 1.000 |\n| 16384 | mfp3 | 0.900 | 0.993 | 1.000 | 1.000 | 1.000 | 1.000 | 1.000 | 1.000 | 1.000 | 1.000 | 1.000 |\n| 16384 | rdk5 | 0.181 | 0.332 | 0.460 | 0.566 | 0.654 | 0.724 | 0.780 | 0.826 | 0.863 | 0.892 | 0.916 |\n| 16384 | hashap | 0.335 | 0.519 | 0.651 | 0.746 | 0.816 | 0.867 | 0.905 | 0.931 | 0.950 | 0.964 | 0.974 |\n| 16384 | hashtt | 0.898 | 0.988 | 0.999 | 1.000 | 1.000 | 1.000 | 1.000 | 1.000 | 1.000 | 1.000 | 1.000 |\n| 8192 | mfp1 | 0.969 | 1.000 | 1.000 | 1.000 | 1.000 | 1.000 | 1.000 | 1.000 | 1.000 | 1.000 | 1.000 |\n| 8192 | mfp2 | 0.906 | 0.994 | 1.000 | 1.000 | 1.000 | 1.000 | 1.000 | 1.000 | 1.000 | 1.000 | 1.000 |\n| 8192 | mfp3 | 0.808 | 0.974 | 0.997 | 1.000 | 1.000 | 1.000 | 1.000 | 1.000 | 1.000 | 1.000 | 1.000 |\n| 8192 | rdk5 | 0.076 | 0.177 | 0.266 | 0.346 | 0.420 | 0.486 | 0.545 | 0.597 | 0.645 | 0.687 | 0.725 |\n| 8192 | hashap | 0.295 | 0.467 | 0.594 | 0.692 | 0.766 | 0.822 | 0.865 | 0.897 | 0.921 | 0.939 | 0.952 |\n| 8192 | hashtt | 0.825 | 0.971 | 0.996 | 0.999 | 1.000 | 1.000 | 1.000 | 1.000 | 1.000 | 1.000 | 1.000 |\n| 4096 | mfp1 | 0.950 | 0.998 | 1.000 | 1.000 | 1.000 | 1.000 | 1.000 | 1.000 | 1.000 | 1.000 | 1.000 |\n| 4096 | mfp2 | 0.829 | 0.980 | 0.998 | 1.000 | 1.000 | 1.000 | 1.000 | 1.000 | 1.000 | 1.000 | 1.000 |\n| 4096 | mfp3 | 0.673 | 0.922 | 0.985 | 0.997 | 1.000 | 1.000 | 1.000 | 1.000 | 1.000 | 1.000 | 1.000 |\n| 4096 | rdk5 | 0.034 | 0.077 | 0.122 | 0.166 | 0.210 | 0.254 | 0.296 | 0.336 | 0.375 | 0.412 | 0.447 |\n| 4096 | hashap | 0.156 | 0.270 | 0.370 | 0.455 | 0.529 | 0.592 | 0.646 | 0.693 | 0.733 | 0.768 | 0.798 |\n| 4096 | hashtt | 0.765 | 0.951 | 0.992 | 0.999 | 1.000 | 1.000 | 1.000 | 1.000 | 1.000 | 1.000 | 1.000 |\n| 2048 | mfp1 | 0.740 | 0.975 | 0.998 | 1.000 | 1.000 | 1.000 | 1.000 | 1.000 | 1.000 | 1.000 | 1.000 |\n| 2048 | mfp2 | 0.564 | 0.874 | 0.971 | 0.994 | 0.999 | 1.000 | 1.000 | 1.000 | 1.000 | 1.000 | 1.000 |\n| 2048 | mfp3 | 0.385 | 0.720 | 0.892 | 0.963 | 0.988 | 0.996 | 0.999 | 1.000 | 1.000 | 1.000 | 1.000 |\n| 2048 | rdk5 | 0.017 | 0.037 | 0.058 | 0.080 | 0.101 | 0.124 | 0.146 | 0.169 | 0.191 | 0.214 | 0.236 |\n| 2048 | hashap | 0.076 | 0.132 | 0.185 | 0.235 | 0.281 | 0.323 | 0.362 | 0.397 | 0.429 | 0.459 | 0.487 |\n| 2048 | hashtt | 0.662 | 0.900 | 0.974 | 0.994 | 0.999 | 1.000 | 1.000 | 1.000 | 1.000 | 1.000 | 1.000 |\n| 1024 | mfp1 | 0.674 | 0.942 | 0.992 | 0.999 | 1.000 | 1.000 | 1.000 | 1.000 | 1.000 | 1.000 | 1.000 |\n| 1024 | mfp2 | 0.393 | 0.728 | 0.898 | 0.965 | 0.989 | 0.997 | 0.999 | 1.000 | 1.000 | 1.000 | 1.000 |\n| 1024 | mfp3 | 0.207 | 0.476 | 0.694 | 0.835 | 0.917 | 0.960 | 0.981 | 0.991 | 0.996 | 0.998 | 0.999 |\n| 1024 | rdk5 | 0.007 | 0.017 | 0.026 | 0.037 | 0.047 | 0.057 | 0.067 | 0.077 | 0.088 | 0.098 | 0.109 |\n| 1024 | hashap | 0.037 | 0.066 | 0.095 | 0.122 | 0.148 | 0.174 | 0.199 | 0.223 | 0.246 | 0.269 | 0.291 |\n| 1024 | hashtt | 0.448 | 0.724 | 0.872 | 0.944 | 0.977 | 0.991 | 0.996 | 0.999 | 0.999 | 1.000 | 1.000 |\n| 512 | mfp1 | 0.501 | 0.835 | 0.956 | 0.989 | 0.998 | 1.000 | 1.000 | 1.000 | 1.000 | 1.000 | 1.000 |\n| 512 | mfp2 | 0.184 | 0.445 | 0.671 | 0.824 | 0.911 | 0.957 | 0.980 | 0.991 | 0.996 | 0.999 | 0.999 |\n| 512 | mfp3 | 0.074 | 0.209 | 0.371 | 0.527 | 0.662 | 0.767 | 0.844 | 0.899 | 0.936 | 0.960 | 0.976 |\n| 512 | rdk5 | 0.004 | 0.009 | 0.013 | 0.018 | 0.024 | 0.029 | 0.035 | 0.040 | 0.046 | 0.051 | 0.056 |\n| 512 | hashap | 0.013 | 0.025 | 0.037 | 0.050 | 0.063 | 0.077 | 0.091 | 0.105 | 0.119 | 0.133 | 0.147 |\n| 512 | hashtt | 0.286 | 0.537 | 0.721 | 0.839 | 0.911 | 0.951 | 0.973 | 0.985 | 0.992 | 0.996 | 0.998 |\n| 256 | mfp1 | 0.312 | 0.659 | 0.864 | 0.952 | 0.984 | 0.995 | 0.999 | 1.000 | 1.000 | 1.000 | 1.000 |\n| 256 | mfp2 | 0.060 | 0.186 | 0.348 | 0.511 | 0.653 | 0.764 | 0.846 | 0.902 | 0.939 | 0.963 | 0.978 |\n| 256 | mfp3 | 0.022 | 0.066 | 0.134 | 0.220 | 0.314 | 0.409 | 0.500 | 0.584 | 0.659 | 0.726 | 0.783 |\n| 256 | rdk5 | 0.003 | 0.005 | 0.007 | 0.009 | 0.011 | 0.014 | 0.016 | 0.019 | 0.021 | 0.024 | 0.027 |\n| 256 | hashap | 0.004 | 0.007 | 0.010 | 0.013 | 0.017 | 0.021 | 0.025 | 0.030 | 0.034 | 0.039 | 0.045 |\n| 256 | hashtt | 0.105 | 0.234 | 0.373 | 0.501 | 0.612 | 0.706 | 0.782 | 0.842 | 0.887 | 0.920 | 0.944 |\n| 128 | mfp1 | 0.117 | 0.324 | 0.546 | 0.726 | 0.846 | 0.918 | 0.958 | 0.980 | 0.991 | 0.996 | 0.998 |\n| 128 | mfp2 | 0.015 | 0.049 | 0.106 | 0.184 | 0.275 | 0.373 | 0.469 | 0.560 | 0.642 | 0.714 | 0.777 |\n| 128 | mfp3 | 0.007 | 0.018 | 0.036 | 0.062 | 0.095 | 0.136 | 0.183 | 0.235 | 0.290 | 0.345 | 0.399 |\n| 128 | rdk5 | 0.002 | 0.002 | 0.003 | 0.004 | 0.005 | 0.006 | 0.007 | 0.008 | 0.009 | 0.010 | 0.011 |\n| 128 | hashap | 0.002 | 0.003 | 0.005 | 0.006 | 0.008 | 0.010 | 0.012 | 0.014 | 0.016 | 0.018 | 0.021 |\n| 128 | hashtt | 0.035 | 0.079 | 0.139 | 0.208 | 0.283 | 0.357 | 0.429 | 0.497 | 0.561 | 0.620 | 0.675 |\n| 64 | mfp1 | 0.024 | 0.083 | 0.179 | 0.302 | 0.435 | 0.564 | 0.677 | 0.771 | 0.843 | 0.896 | 0.932 |\n| 64 | mfp2 | 0.004 | 0.011 | 0.025 | 0.044 | 0.072 | 0.107 | 0.149 | 0.199 | 0.254 | 0.312 | 0.371 |\n| 64 | mfp3 | 0.003 | 0.006 | 0.011 | 0.017 | 0.026 | 0.037 | 0.050 | 0.066 | 0.084 | 0.105 | 0.129 |\n| 64 | rdk5 | 0.001 | 0.002 | 0.002 | 0.002 | 0.003 | 0.003 | 0.004 | 0.004 | 0.005 | 0.005 | 0.006 |\n| 64 | hashap | 0.001 | 0.002 | 0.003 | 0.004 | 0.004 | 0.005 | 0.006 | 0.007 | 0.008 | 0.009 | 0.010 |\n| 64 | hashtt | 0.016 | 0.034 | 0.059 | 0.092 | 0.132 | 0.177 | 0.227 | 0.279 | 0.331 | 0.382 | 0.431 |\n\n\nNotice that the high-density fingerprints - rdk5 and hashap - have collisions for the majority of the compounds even with a 16K fingerprint.\n\n\nImpact on similarity\nNow that we have a sense of how many collisions there are, lets look at the impact those collisions have on molecular similarity.\nAs a data set we’ll use a set of 50000 pairs of ChEMBL30 molecules with a similarity of at least 0.55 using a count-based morgan fingerprint with radius 1 (MFP1). The jupyter notebook used to generate this data can be found here.\n\npairs = []\nfor l in gzip.open('../data/chembl30_50K.mfp1.pairs.txt.gz','rt'):\n    l = l.split('\\t')\n    pairs.append([Chem.MolFromSmiles(l[1]),Chem.MolFromSmiles(l[3])])\n\n\nsims = defaultdict(list)\nfor nm,fpgen in gens:\n    print(f'Doing {nm}')\n    fpg = fpgen(1024) # size is irrelevant here\n    for m1,m2 in pairs:\n        fp1 = fpg.GetSparseFingerprint(m1)\n        fp2 = fpg.GetSparseFingerprint(m2)\n        sims[nm].append(DataStructs.TanimotoSimilarity(fp1,fp2))\n    for l in 64,128,256,512,1024,2048,4096,8192,16384:\n        fpn = f'{nm}-{l}'\n        fpg = fpgen(l)\n        for m1,m2 in pairs:\n            fp1 = fpg.GetFingerprint(m1)\n            fp2 = fpg.GetFingerprint(m2)\n            sims[fpn].append(DataStructs.TanimotoSimilarity(fp1,fp2))\n\nDoing mfp1\nDoing mfp2\nDoing mfp3\nDoing rdk5\nDoing hashap\nDoing hashtt\n\n\n\npickle.dump(dict(sims),gzip.open('../data/fp_collision_sims.pkl.gz','wb+'))\n\n\nsims = pickle.load(gzip.open('../data/fp_collision_sims.pkl.gz','rb'))\n\n\nrads = (1,2,3)\nbcounts = (64,128,256,512,1024,2048,4096,8192,16384)\nfigsize(3*6,len(bcounts)*6)\n\nplt = 1\nfor i,cnt in enumerate(reversed(bcounts)):\n    for j,rad in enumerate(rads):\n        subplot(len(bcounts),3,plt)\n        plt += 1\n        plot((0,1),(0,1),'k-')\n        hexbin(sims[f'mfp{rad}'],sims[f'mfp{rad}-{cnt}'],bins='log')\n        xlabel('no collisions')\n        ylabel(f'{cnt} bits')\n        title(f'radius = {rad}')\n\n\n\n\n\nbcounts = (64,128,256,512,1024,2048,4096,8192,16384)\nfigsize(3*6,len(bcounts)*6)\n\nplt = 1\nfor i,cnt in enumerate(reversed(bcounts)):\n    for j,nm in enumerate(('hashtt','hashap','rdk5')):\n        subplot(len(bcounts),3,plt)\n        plt += 1\n        plot((0,1),(0,1),'k-')\n        hexbin(sims[f'{nm}'],sims[f'{nm}-{cnt}'],bins='log')       \n        xlabel('no collisions')\n        ylabel(f'{cnt} bits')\n        title(f'{nm}')\n\n\n\n\nDo a statistical comparison of the similarity distributions\n\nfrom scipy.stats import spearmanr\n\nrow = ('nBits','fingerprint','SpearmanR','mean(d)','std(d)','90% \\\\|d\\\\|')\ndivider = ['-'*len(k) for k in row]\nprint('| '+' | '.join(row)+' |')\nprint('| '+' | '.join(divider)+' |')\n        \n\nrads = (1,2,3)\nbcounts = (64,128,256,512,1024,2048,4096,8192,16384)\nfor i,cnt in enumerate(reversed(bcounts)):\n    for j,(nm,fpg) in enumerate(gens):\n        d1 = numpy.array(sims[nm])\n        d2 = numpy.array(sims[f'{nm}-{cnt}'])\n        delt = d2-d1\n        row = [str(cnt),nm,f'{spearmanr(d1,d2).correlation:.3f}',f'{np.mean(delt):.2g}',\n               f'{np.std(delt):.2g}',f'{np.quantile(np.abs(delt),0.9):.2g}']\n        print('| '+' | '.join(row)+' |')\n\n| nBits | fingerprint | SpearmanR | mean(d) | std(d) | 90% \\|d\\| |\n| ----- | ----------- | --------- | ------- | ------ | --------- |\n| 16384 | mfp1 | 1.000 | 0.00023 | 0.0025 | 0 |\n| 16384 | mfp2 | 0.999 | 0.00085 | 0.0036 | 0.0034 |\n| 16384 | mfp3 | 0.999 | 0.0014 | 0.0038 | 0.0056 |\n| 16384 | rdk5 | 1.000 | 0.0054 | 0.0046 | 0.012 |\n| 16384 | hashap | 0.997 | 0.0066 | 0.0072 | 0.016 |\n| 16384 | hashtt | 0.999 | 0.0024 | 0.0074 | 0.011 |\n| 8192 | mfp1 | 0.999 | 0.00089 | 0.005 | 0 |\n| 8192 | mfp2 | 0.999 | 0.0017 | 0.0051 | 0.007 |\n| 8192 | mfp3 | 0.999 | 0.0027 | 0.0054 | 0.011 |\n| 8192 | rdk5 | 0.999 | 0.011 | 0.008 | 0.022 |\n| 8192 | hashap | 0.996 | 0.0089 | 0.0084 | 0.02 |\n| 8192 | hashtt | 0.997 | 0.0046 | 0.01 | 0.019 |\n| 4096 | mfp1 | 0.998 | 0.0016 | 0.0069 | 0.0079 |\n| 4096 | mfp2 | 0.998 | 0.0033 | 0.0073 | 0.014 |\n| 4096 | mfp3 | 0.997 | 0.0054 | 0.0077 | 0.016 |\n| 4096 | rdk5 | 0.998 | 0.022 | 0.014 | 0.041 |\n| 4096 | hashap | 0.988 | 0.022 | 0.015 | 0.042 |\n| 4096 | hashtt | 0.996 | 0.0068 | 0.013 | 0.024 |\n| 2048 | mfp1 | 0.993 | 0.0042 | 0.013 | 0.02 |\n| 2048 | mfp2 | 0.995 | 0.0069 | 0.012 | 0.023 |\n| 2048 | mfp3 | 0.994 | 0.011 | 0.012 | 0.027 |\n| 2048 | rdk5 | 0.995 | 0.044 | 0.026 | 0.08 |\n| 2048 | hashap | 0.956 | 0.05 | 0.029 | 0.088 |\n| 2048 | hashtt | 0.993 | 0.011 | 0.016 | 0.034 |\n| 1024 | mfp1 | 0.989 | 0.0067 | 0.016 | 0.028 |\n| 1024 | mfp2 | 0.990 | 0.014 | 0.016 | 0.036 |\n| 1024 | mfp3 | 0.987 | 0.022 | 0.017 | 0.044 |\n| 1024 | rdk5 | 0.981 | 0.085 | 0.049 | 0.15 |\n| 1024 | hashap | 0.874 | 0.1 | 0.051 | 0.17 |\n| 1024 | hashtt | 0.983 | 0.025 | 0.026 | 0.061 |\n| 512 | mfp1 | 0.980 | 0.013 | 0.021 | 0.044 |\n| 512 | mfp2 | 0.979 | 0.028 | 0.023 | 0.059 |\n| 512 | mfp3 | 0.972 | 0.044 | 0.026 | 0.078 |\n| 512 | rdk5 | 0.929 | 0.16 | 0.09 | 0.28 |\n| 512 | hashap | 0.702 | 0.19 | 0.083 | 0.3 |\n| 512 | hashtt | 0.967 | 0.046 | 0.037 | 0.096 |\n| 256 | mfp1 | 0.962 | 0.026 | 0.029 | 0.065 |\n| 256 | mfp2 | 0.954 | 0.057 | 0.035 | 0.1 |\n| 256 | mfp3 | 0.932 | 0.087 | 0.041 | 0.14 |\n| 256 | rdk5 | 0.785 | 0.28 | 0.15 | 0.48 |\n| 256 | hashap | 0.539 | 0.3 | 0.11 | 0.43 |\n| 256 | hashtt | 0.921 | 0.092 | 0.057 | 0.17 |\n| 128 | mfp1 | 0.918 | 0.049 | 0.043 | 0.11 |\n| 128 | mfp2 | 0.897 | 0.11 | 0.054 | 0.18 |\n| 128 | mfp3 | 0.839 | 0.17 | 0.066 | 0.25 |\n| 128 | rdk5 | 0.528 | 0.42 | 0.2 | 0.68 |\n| 128 | hashap | 0.343 | 0.42 | 0.12 | 0.57 |\n| 128 | hashtt | 0.828 | 0.17 | 0.085 | 0.28 |\n| 64 | mfp1 | 0.832 | 0.099 | 0.064 | 0.18 |\n| 64 | mfp2 | 0.771 | 0.2 | 0.083 | 0.31 |\n| 64 | mfp3 | 0.642 | 0.31 | 0.1 | 0.44 |\n| 64 | rdk5 | 0.235 | 0.5 | 0.22 | 0.77 |\n| 64 | hashap | 0.158 | 0.51 | 0.13 | 0.65 |\n| 64 | hashtt | 0.672 | 0.28 | 0.12 | 0.43 |"
  },
  {
    "objectID": "posts/2022-01-04-number-of-unique-fp-bits.html",
    "href": "posts/2022-01-04-number-of-unique-fp-bits.html",
    "title": "The number of unique fingerprint bits",
    "section": "",
    "text": "How many molecules do we need to add before we’ve seen all the bits?\nI did an updated post last year looking at the average number of bits set per molecule by the various fingerprinting algorithms in the RDKit.\nThis one explores a couple of related topics: 1. If we look at a large set of organic molecules, how many different atom environments (as defined by the individual fingerprints) do we observe? 2. How quickly does this number converge with the number of compounds considered?\nObviously the answer to these questions is extremely dependent on the set of molecules you use. For this post I will use a set of around six million random molecules from Zinc20’s “in-stock” set. The six million included all have less than 50 heavy atoms after being salt stripped.\nThe experiment itself could hardly be simpler: read in the molecules, generate fingerprints, and keep track of the unique bits set as a function of number of molecules considered. For this analysis I limit myself to fingerprints which have not been “folded” to fit into a particular bit length (with the exception of the Avalon FP, which currently only supports generating folded forms).\nThe code and raw data are below, here are the curves showing the saturation behavior for the various fingerprints: \nNote that the saturation behavior of the avalon fingerprint here is an artifact of the fact that the fingerprint being used was only 9192 bits long (yes, I made a typo when I entered the value in the script to generate the data); 9185 of those bits end up being set.\nFor a bit more resolution, here’s a table with the number of unique bits set per fingerprint in that set of 6 million, the number of new bits found in the last 100K of the 6 million, as well as how many molecules needed to be considered to reach 90, 95, and 99% of the number of unique bits:\n\n\n\n\n\n\n\n\n\n\n\n\n# unique bits\n# in last 100K\n0.90\n0.95\n0.99\n\n\n\n\nFeatMorgan0\n15\n0\nN/A\nN/A\nN/A\n\n\nFeatMorgan1\n1621\n2\n2760000\n4080000\n5460000\n\n\nFeatMorgan2\n116975\n464\n4000000\n4870000\n5750000\n\n\nFeatMorgan3\n1350464\n7478\n4400000\n5130000\n5810000\n\n\nMorgan0\n143\n0\n2850000\n4080000\n5080000\n\n\nMorgan1\n19428\n67\n3870000\n4750000\n5720000\n\n\nMorgan2\n575817\n2941\n4320000\n5080000\n5790000\n\n\nMorgan3\n3606676\n22970\n4580000\n5240000\n5830000\n\n\nRDKit5\n131029\n347\n3490000\n4600000\n5690000\n\n\nRDKit6\n538500\n1627\n3600000\n4680000\n5700000\n\n\nRDKit7\n1989958\n6897\n3740000\n4760000\n5720000\n\n\nRDKit-linear5\n49852\n136\n3400000\n4520000\n5680000\n\n\nRDKit-linear6\n133904\n402\n3480000\n4570000\n5690000\n\n\nRDKit-linear7\n315293\n1032\n3570000\n4640000\n5700000\n\n\nap-counts\n16585\n18\n2470000\n3840000\n5410000\n\n\navalon\n9185\n0\n20000\n70000\n490000\n\n\ntt-counts\n20723\n49\n3530000\n4570000\n5640000\n\n\n\nTo help with the interpretation of this: a total of 131029 unique bits were found for the RDKit5 fingerprint in the set of 6 million molecules and 95% of those bits had been found after looking at 4.6 million molecules. The last 100K molecules added 347 new bits.\nThe thing that I find most interesting (and somewhat surprising) about these results is how far we are from having encountered “all” of the bits; new bits are being encountered for almost all of the fingerprint types even after 5.9 million molecules have been encountered. I can probably still wave my hands and estimate the order-of-magnitude number of distinct bits for each of the FP types in the full set of ~14 million substances in the ZINC20 “in-stock” set. Here’s a few of those estimates: - FeatMorgan2: 120-150K - FeatMorgan3: 1.4-1.6 million - Morgan1: 20-25K - Morgan2: 600-700K - Morgan3: 3.6-4.0 million\nThese are also rough lower bounds on the number of atom environments in those compounds (it’s a lower bound due to the possibility of hash collisions causing multiple atom environments to hash to the same fingerprint bit).\n\nAside: it’s worth mentioning that this, of course, isn’t the first time someone has looked at this topic. I don’t normally include references for blog posts, but this paper from the PubChem team is a nice look at the atom environments in the (huge) PubChem dataset: http://www.jcheminf.com/content/7/1/41\n\nThe rest of the post has the code for generating the data and doing the analysis.\n\nfrom rdkit import Chem,DataStructs\nimport time,random,gzip,pickle,copy\nimport numpy as np\nfrom collections import Counter,defaultdict\nfrom rdkit.Chem import Draw\nfrom rdkit.Chem import rdMolDescriptors\nfrom rdkit.Chem.MolStandardize import rdMolStandardize\nfrom rdkit.Avalon import pyAvalonTools\nfrom rdkit.Chem.Draw import IPythonConsole\nfrom rdkit import DataStructs\nfrom rdkit import rdBase\nfrom rdkit import RDLogger\n%pylab inline\n\nprint(rdBase.rdkitVersion)\nimport time\nprint(time.asctime())\n\nPopulating the interactive namespace from numpy and matplotlib\n2021.09.3\nTue Jan  4 13:17:00 2022\n\n\n/home/glandrum/miniconda3/envs/rdkit_blog/lib/python3.9/site-packages/IPython/core/magics/pylab.py:159: UserWarning: pylab import has clobbered these variables: ['random', 'copy']\n`%matplotlib` prevents importing * from pylab and numpy\n  warn(\"pylab import has clobbered these variables: %s\"  % clobbered +\n\n\n\ntry:\n    import ipyparallel as ipp\n    rc = ipp.Client()\n    dview = rc[:]\n    dview.execute('from rdkit import Chem')\n    dview.execute('from rdkit import Descriptors')\n    dview.execute('from rdkit.Chem import rdMolDescriptors')\n    dview.execute('from rdkit.Avalon import pyAvalonTools')\nexcept:\n    print(\"could not use ipyparallel\")\n    dview = None\n\nHere’s my local copy of the ~14 million “in stock” compounds I grabbed from ZINC (this file is too big for github):\n\nfilen='/scratch/RDKit_git/LocalData/Zinc20/purchasable/zinc20_instock.pkl.shuffled.gz'\n\nLoop over the molecules, strip salts, skip anything with more than 50 atoms, and build fingerprints for all the others.\nThe fingerprints I generate for this analysis are: - Sparse Morgan with radii 1, 2, and 3 - Sparse FeatureMorgan with radii 1, 2, and 3 - Sparse RDKit with maxPath 5, 6, and 7 - Sparse RDKit, no branches, with maxPath 5, 6, and 7 - Avalon BitVect - Sparse Atom Pairs - Sparse Topological Torsions\nAll of the BitVect fingerprints are 4096 bits long\n\nimport copy\nfrom collections import defaultdict\nhistoryf = gzip.open('../data/fp_bit_counts.history.pkl.gz','wb+')\nRDLogger.DisableLog('rdApp.info')\nfrm = rdMolStandardize.LargestFragmentChooser()\ncounts=defaultdict(list)\naccum=defaultdict(set)\nt1 = time.time()\nwith gzip.open(filen,'rb') as inf:\n    i = 0\n    ms = []\n    while 1:\n        try:\n            m,nm = pickle.load(inf)\n        except EOFError:\n            break\n        if not m:\n            continue\n        # strip salts:\n        m = frm.choose(m)\n        if m.GetNumHeavyAtoms()>50: \n            continue\n        ms.append(m)\n        i+=1\n        if len(ms)>=10000:\n            for v in 0,1,2,3:\n                k = ('Morgan',v)\n                cnts = dview.map_sync(lambda x,v=v:set(rdMolDescriptors.GetMorganFingerprint(x,v).GetNonzeroElements().keys()),\n                                     ms)\n                for obc in cnts:\n                    accum[k].update(obc)\n                counts[k].append((i,len(accum[k])))\n            for v in 0,1,2,3:\n                k = ('FeatMorgan',v)\n                cnts = dview.map_sync(lambda x,v=v:set(rdMolDescriptors.GetMorganFingerprint(x,v,useFeatures=True).GetNonzeroElements().keys()),\n                                     ms)\n                for obc in cnts:\n                    accum[k].update(obc)\n                counts[k].append((i,len(accum[k])))\n            for v in 5,6,7:\n                k = ('RDKit',v)\n                cnts = dview.map_sync(lambda x,v=v:set(Chem.UnfoldedRDKFingerprintCountBased(x,maxPath=v).GetNonzeroElements().keys()),\n                                      ms)\n                for obc in cnts:\n                    accum[k].update(obc)\n                counts[k].append((i,len(accum[k])))\n            for v in 5,6,7:\n                k = ('RDKit-linear',v)\n                cnts = dview.map_sync(lambda x,v=v:set(Chem.UnfoldedRDKFingerprintCountBased(x,maxPath=v,branchedPaths=False).GetNonzeroElements().keys()),\n                                      ms)\n                for obc in cnts:\n                    accum[k].update(obc)\n                counts[k].append((i,len(accum[k])))\n\n            k = ('avalon',-1)\n            cnts = dview.map_sync(lambda x:set(pyAvalonTools.GetAvalonFP(x,nBits=9192).GetOnBits()),\n                                  ms)\n            for obc in cnts:\n                accum[k].update(obc)\n            counts[k].append((i,len(accum[k])))\n            \n            k = ('ap-counts',-1)\n            cnts = dview.map_sync(lambda x:set(rdMolDescriptors.GetAtomPairFingerprint(x).GetNonzeroElements().keys()),\n                                  ms)\n            for obc in cnts:\n                accum[k].update(obc)\n            counts[k].append((i,len(accum[k])))\n            k = ('tt-counts',-1)\n            cnts = dview.map_sync(lambda x:set(rdMolDescriptors.GetTopologicalTorsionFingerprint(x).GetNonzeroElements().keys()),\n                                  ms)\n            for obc in cnts:\n                accum[k].update(obc)\n            counts[k].append((i,len(accum[k])))\n            ms = []\n            \n        if not i%50000:\n            t2 = time.time()\n            print(\"Done %d in %.2f sec\"%(i,t2-t1))\n        if not i%500000:\n            pickle.dump(dict(counts),historyf)\n            pickle.dump(dict(accum),historyf)\n        if i>=5500000:\n            break\n\n\nwith gzip.open('../data/fp_bit_counts.history.pkl.gz','wb+') as outf:\n    pickle.dump(dict(counts),outf)\n    pickle.dump(dict(accum),outf)\n        \n\n\nwith gzip.open('../data/fp_bit_counts.history.pkl.gz','rb') as inf:\n    counts = pickle.load(inf)\n\nNow plot the distributions of the number of bits set\nWe have a few extra data points, let’s stick to the first 6 million molecules\n\nfor k,v in counts.items():\n    v = [x for x in v if x[0]<6000000]\n    counts[k] = v\n\n\nmorgan_ks = [x for x in sorted(counts.keys()) if x[0] =='Morgan']\nfeatmorgan_ks = [x for x in sorted(counts.keys()) if x[0] =='FeatMorgan']\nrdkit_ks = [x for x in sorted(counts.keys()) if x[0] == 'RDKit']\nrdkitlin_ks = [x for x in sorted(counts.keys()) if x[0] == 'RDKit-linear']\n\nfigure(figsize=(15,20))\n\npidx=1\nsubplot(3,2,pidx)\nfor n,r in rdkit_ks:\n    cnts = counts[(n,r)]\n    \n    plot([x for x,y in cnts],[y for x,y in cnts],label=\n        f\"r={r}\")\n_=title(\"RDKit\")\n_=ylabel(\"unique bits observed\")\n_=xlabel(\"num molecules\")\n_=legend()\n\npidx=2\nsubplot(3,2,pidx)\nfor n,r in rdkitlin_ks:\n    cnts = counts[(n,r)]\n    \n    plot([x for x,y in cnts],[y for x,y in cnts],label=\n        f\"r={r}\")\n_=title(\"RDKit linear\")\n_=ylabel(\"unique bits observed\")\n_=xlabel(\"num molecules\")\n_=legend()\n\n\n\npidx=3\nsubplot(3,2,pidx)\nfor n,r in morgan_ks:\n    cnts = counts[(n,r)]\n    \n    plot([x for x,y in cnts],[y for x,y in cnts],label=\n        f\"r={r}\")\n_=title(\"Morgan\")\n_=ylabel(\"unique bits observed\")\n_=xlabel(\"num molecules\")\n_=legend()\n\npidx=4\nsubplot(3,2,pidx)\nfor n,r in featmorgan_ks:\n    cnts = counts[(n,r)]\n    \n    plot([x for x,y in cnts],[y for x,y in cnts],label=\n        f\"r={r}\")\n_=title(\"FeatMorgan\")\n_=ylabel(\"unique bits observed\")\n_=xlabel(\"num molecules\")\n_=legend()\n\npidx+=1\nsubplot(3,2,pidx)\nfor k in counts.keys():\n    if k[0].startswith('Morgan') or k[0].startswith('FeatMorgan') or k[0].startswith('RDKit'):\n        continue\n    pidx+=1\n    cnts = counts[k]\n    plot([x for x,y in cnts],[y for x,y in cnts],label=k[0])\n_=title('others')\n_=ylabel(\"unique bits observed\")\n_=xlabel(\"num molecules\")\n_=legend()\n   \ntight_layout();\n\n\n\n\nMabye better to plot those on a log scale?\n\nmorgan_ks = [x for x in sorted(counts.keys()) if x[0] =='Morgan']\nfeatmorgan_ks = [x for x in sorted(counts.keys()) if x[0] =='FeatMorgan']\nrdkit_ks = [x for x in sorted(counts.keys()) if x[0] == 'RDKit']\nrdkitlin_ks = [x for x in sorted(counts.keys()) if x[0] == 'RDKit-linear']\n\nfigure(figsize=(15,20))\n\npidx=1\nsubplot(3,2,pidx)\nfor n,r in rdkit_ks:\n    cnts = counts[(n,r)]\n    \n    plot([x for x,y in cnts],[y for x,y in cnts],label=\n        f\"r={r}\")\n_=title(\"RDKit\")\n_=ylabel(\"unique bits observed\")\n_=xlabel(\"num molecules\")\n_=yscale('log')\n_=legend()\n\npidx=2\nsubplot(3,2,pidx)\nfor n,r in rdkitlin_ks:\n    cnts = counts[(n,r)]\n    \n    plot([x for x,y in cnts],[y for x,y in cnts],label=\n        f\"r={r}\")\n_=title(\"RDKit linear\")\n_=ylabel(\"unique bits observed\")\n_=xlabel(\"num molecules\")\n_=yscale('log')\n_=legend()\n\n\n\npidx=3\nsubplot(3,2,pidx)\nfor n,r in morgan_ks:\n    cnts = counts[(n,r)]\n    \n    plot([x for x,y in cnts],[y for x,y in cnts],label=\n        f\"r={r}\")\n_=title(\"Morgan\")\n_=ylabel(\"unique bits observed\")\n_=xlabel(\"num molecules\")\n_=yscale('log')\n_=legend()\n\npidx=4\nsubplot(3,2,pidx)\nfor n,r in featmorgan_ks:\n    cnts = counts[(n,r)]\n    \n    plot([x for x,y in cnts],[y for x,y in cnts],label=\n        f\"r={r}\")\n_=title(\"FeatMorgan\")\n_=ylabel(\"unique bits observed\")\n_=xlabel(\"num molecules\")\n_=yscale('log')\n_=legend()\n\npidx+=1\nsubplot(3,2,pidx)\nfor k in counts.keys():\n    if k[0].startswith('Morgan') or k[0].startswith('FeatMorgan') or k[0].startswith('RDKit'):\n        continue\n    pidx+=1\n    cnts = counts[k]\n    plot([x for x,y in cnts],[y for x,y in cnts],label=k[0])\n_=title('others')\n_=ylabel(\"unique bits observed\")\n_=yscale('log')\n_=xlabel(\"num molecules\")\n_=legend()\n\ntight_layout();\n\n\n\n\nNotes: - FeatMorgan with r=0 is super boring since there are only 15 types observed and 14 of them appear within the first 10K compounds (the last appears after around 1.2 million compounds). By way of comparison, there are 143 different Morgan0 types observed and the last of those doesn’t show up until after about 5.1 million compounds. - The Avalon fingerprint was 9192 bits long and it ends up setting all essentially of those bits (9185). It probably would have been better to run this with a longer fingerprint.\nHow many compounds do we need to look at in order to see particular fractions of the total number of bits there?\n\nbins = (0.9,0.95,0.99)\nprint('|',' '*15,'|','# unique bits','|','# in last 100K','|',' | '.join(f'{x:7.2f}' for x in bins),'|')\nprint('|','-'*15,'|','-'*13,'|','-'*14,'|',' | '.join('-'*7 for x in bins),'|')\nfor k,cnts in sorted(counts.items()):\n    label = ''.join(str(x) for x in k if x!=-1)\n    maxv = cnts[-1][1]\n    last100K = cnts[-1][1] - cnts[-11][1]\n    if label=='FeatMorgan0':\n        accum = ' | '.join([f'{\"N/A\":7s}']*3)\n    else:\n        accum = []\n        for bin in bins:\n            for idx in range(len(cnts),0,-1):\n                if cnts[idx-1][1]<bin*maxv:\n                    accum.append(cnts[idx-1][0])\n                    break\n        accum = ' | '.join(f'{x:7d}' for x in accum)\n    print('|',f'{label:15s}','|',f'{maxv:13d}','|',f'{last100K:14d}','|',accum,'|')\n\n|                 | # unique bits | # in last 100K |    0.90 |    0.95 |    0.99 |\n| --------------- | ------------- | -------------- | ------- | ------- | ------- |\n| FeatMorgan0     |            15 |              0 | N/A     | N/A     | N/A     |\n| FeatMorgan1     |          1621 |              2 | 2760000 | 4080000 | 5460000 |\n| FeatMorgan2     |        116975 |            464 | 4000000 | 4870000 | 5750000 |\n| FeatMorgan3     |       1350464 |           7478 | 4400000 | 5130000 | 5810000 |\n| Morgan0         |           143 |              0 | 2850000 | 4080000 | 5080000 |\n| Morgan1         |         19428 |             67 | 3870000 | 4750000 | 5720000 |\n| Morgan2         |        575817 |           2941 | 4320000 | 5080000 | 5790000 |\n| Morgan3         |       3606676 |          22970 | 4580000 | 5240000 | 5830000 |\n| RDKit5          |        131029 |            347 | 3490000 | 4600000 | 5690000 |\n| RDKit6          |        538500 |           1627 | 3600000 | 4680000 | 5700000 |\n| RDKit7          |       1989958 |           6897 | 3740000 | 4760000 | 5720000 |\n| RDKit-linear5   |         49852 |            136 | 3400000 | 4520000 | 5680000 |\n| RDKit-linear6   |        133904 |            402 | 3480000 | 4570000 | 5690000 |\n| RDKit-linear7   |        315293 |           1032 | 3570000 | 4640000 | 5700000 |\n| ap-counts       |         16585 |             18 | 2470000 | 3840000 | 5410000 |\n| avalon          |          9185 |              0 |   20000 |   70000 |  490000 |\n| tt-counts       |         20723 |             49 | 3530000 | 4570000 | 5640000 |\n\n\nWhat fraction of the overall number of bits appear in the last 100K compounds?\n\nbins = (0.9,0.95,0.99)\nfor k,cnts in sorted(counts.items()):\n    label = ''.join(str(x) for x in k if x!=-1)\n    maxv = cnts[-1][1]\n    last100K = cnts[-1][1] - cnts[-11][1]\n    print(label,last100K/maxv)\n\nFeatMorgan0 0.0\nFeatMorgan1 0.0012338062924120913\nFeatMorgan2 0.003966659542637315\nFeatMorgan3 0.005537356049476328\nMorgan0 0.0\nMorgan1 0.0034486308420835906\nMorgan2 0.005107525481185863\nMorgan3 0.006368745071639371\nRDKit5 0.0026482687038747147\nRDKit6 0.003021355617455896\nRDKit7 0.0034659022954253308\nRDKit-linear5 0.0027280751023028163\nRDKit-linear6 0.003002150794599116\nRDKit-linear7 0.00327314593092774\nap-counts 0.0010853180584865843\navalon 0.0\ntt-counts 0.002364522511219418"
  },
  {
    "objectID": "posts/2020-01-25-trying-the-tautomer-canonicalization-code.html",
    "href": "posts/2020-01-25-trying-the-tautomer-canonicalization-code.html",
    "title": "Trying out the new tautomer canonicalization code",
    "section": "",
    "text": "During the 2018 RDKit Google Summer of Code (GSoC) project to port MolVS to C++, doing the tautomer enumeration and canonicalization were stretch goals. Susan actually managed to complete the tautomer enumeration, but since canonicalization wasn’t complete, we didn’t publicize this particularly widely. As part of the work for the 2020.03 release, I implemented Matt’s canonicalization scheme and we recently merged that into the RDKit core. Since this is a topic that may be contentious, and since making changes to the canonicalization algorithm post-release will have be done very deliberately, I’d like to collect some feedback before we do the release in a couple of months.\nThe implementation attempts to exactly duplicate what is currently being done in MolVS. Here’s how Matt describes the process in the MolVS documentation:\nThe scoring scheme: - aromatic ring (defined by all bonds being aromatic) consisting entirely of carbons: 250 points - other aromatic rings : 100 points - a set of substructures are scored (if present). Here’s the current (as of this writing) set of substructures and their associated scores (these are defined here):\nThe highest scoring tautomer is selected. In the event of ties, the tautomer with the lexicographically smaller canonical SMILES is picked.\nIf this is something you feel strongly about, please try the code out and see what you think. If you see behavior you really don’t like, or that you think is a bug, please add a comment to the associated issue in github: https://github.com/rdkit/rdkit/issues/2908 (preferred) or reply to the thread that I will create on the rdkit-discuss mailing list.\nRemember that the goal of the exercise here is not to produce the “best” tautomer, but to produce a canonical one (always the same result for molecules which are tautomerically equivalent). We hope that this is also reasonable - in that it doesn’t make a chemist’s eyes burn - but that’s not the primary goal."
  },
  {
    "objectID": "posts/2020-01-25-trying-the-tautomer-canonicalization-code.html#so-how-can-you-try-it-out",
    "href": "posts/2020-01-25-trying-the-tautomer-canonicalization-code.html#so-how-can-you-try-it-out",
    "title": "Trying out the new tautomer canonicalization code",
    "section": "So how can you try it out?",
    "text": "So how can you try it out?\nThis is C++ code, so you need an RDKit build done from the github master. I’ve done conda builds and made them available for people to try.\nAt the moment I’ve only built the beta version for python 3.7 on linux and windows. If you would like to do some testing on the Mac, let me know and I can do a build there too.\nHere’s how to setup a conda environment to use the beta:\n% conda create -n py37_tautomer_beta python=3.7 jupyter\n% conda activate py37_tautomer_beta\n% conda install -c rdkit/label/beta rdkit\nOk, let’s look at some examples:\n\nfrom rdkit import Chem\nfrom rdkit.Chem.Draw import IPythonConsole\nfrom rdkit.Chem import Draw\nimport rdkit\nprint(rdkit.__version__)\n\n2020.03.1dev1\n\n\nRDKit WARNING: [11:00:33] Enabling RDKit 2020.03.1dev1 jupyter extensions\n\n\n\nfrom rdkit.Chem.MolStandardize import rdMolStandardize\n\n\nenumerator = rdMolStandardize.TautomerEnumerator()\n\n\nm = Chem.MolFromSmiles('Oc1c(cccc3)c3nc2ccncc12')\nm\n\n\n\n\nGet the canonical tautomer:\n\nenumerator.Canonicalize(m)\n\n\n\n\nThe canonicalizer starts by enumerating a molecule’s tautomers. If you want to see those, you can use the Enumerate() method:\n\ntauts = enumerator.Enumerate(m)\nDraw.MolsToGridImage(tauts)\n\n\n\n\nI find this function, which reorders the list of tautomers so that the canonical one is in the first position, really useful:\n\ndef reorderTautomers(m):\n    enumerator = rdMolStandardize.TautomerEnumerator()\n    canon = enumerator.Canonicalize(m)\n    csmi = Chem.MolToSmiles(canon)\n    res = [canon]\n    tauts = enumerator.Enumerate(m)\n    smis = [Chem.MolToSmiles(x) for x in tauts]\n    stpl = sorted((x,y) for x,y in zip(smis,tauts) if x!=csmi)\n    res += [y for x,y in stpl]\n    return res\n\nSo now we can display all the tautomers found for a molecule. The first one drawn is the canonical one:\n\nDraw.MolsToGridImage(reorderTautomers(m))\n\n\n\n\n\nDraw.MolsToGridImage(reorderTautomers(Chem.MolFromSmiles('CN=c1nc[nH]cc1')))\n\n\n\n\n\nDraw.MolsToGridImage(reorderTautomers(Chem.MolFromSmiles('CC=CO')))\n\n\n\n\nAs an aside, it’s worth noticing that double bond stereochemistry is removed in all tautomers if the double bond is involved in the tautomerization:\n\nm = Chem.MolFromSmiles('C/C=C(/O)F')\ntauts = reorderTautomers(m)\nprint('Original SMILES:',Chem.MolToSmiles(m))\nprint('Tautomers (canonical first):',[Chem.MolToSmiles(x) for x in tauts])\n\nOriginal SMILES: C/C=C(/O)F\nTautomers (canonical first): ['CCC(=O)F', 'CC=C(O)F']"
  },
  {
    "objectID": "posts/2021-11-26-highlighting-changed-bonds-in-reactions.html",
    "href": "posts/2021-11-26-highlighting-changed-bonds-in-reactions.html",
    "title": "Highlighting changing atoms and bonds in reactions",
    "section": "",
    "text": "A while ago there was a question on Twitter about highlighting the bonds which changed in a reaction. I put together a quick bit of example code to answer that question and made a note to do a blog post on the topic. I’m finally getting around to doing that blog post.\nFair warning: This one is heavy on code and light on words. :-)\n\nfrom rdkit import Chem\nfrom rdkit.Chem import Draw\nfrom rdkit.Chem.Draw import IPythonConsole\nfrom rdkit.Chem import rdChemReactions\nimport rdkit\nprint(rdkit.__version__)\n\n2021.09.2\n\n\nHere’s something similar to the reaction from the question:\n\nrxn1 = rdChemReactions.ReactionFromRxnBlock('''$RXN\n\n      Mrv2102  111820212128\n\n  2  1\n$MOL\n\n  Mrv2102 11182121282D          \n\n 13 13  0  0  0  0            999 V2000\n   -7.5723    2.6505    0.0000 C   0  0  0  0  0  0  0  0  0  1  0  0\n   -6.8579    2.2380    0.0000 O   0  0  0  0  0  0  0  0  0  2  0  0\n   -6.8580    1.4130    0.0000 C   0  0  0  0  0  0  0  0  0  3  0  0\n   -6.1435    1.0004    0.0000 O   0  0  0  0  0  0  0  0  0  4  0  0\n   -7.5725    1.0005    0.0000 C   0  0  0  0  0  0  0  0  0  5  0  0\n   -7.5725    0.1755    0.0000 N   0  0  0  0  0  0  0  0  0  6  0  0\n   -8.2869   -0.2369    0.0000 C   0  0  0  0  0  0  0  0  0  7  0  0\n   -8.2870   -1.0620    0.0000 C   0  0  0  0  0  0  0  0  0  8  0  0\n   -9.0015   -1.4745    0.0000 C   0  0  0  0  0  0  0  0  0  9  0  0\n   -9.0015   -2.2995    0.0000 C   0  0  0  0  0  0  0  0  0 10  0  0\n   -8.2870   -2.7120    0.0000 C   0  0  0  0  0  0  0  0  0 11  0  0\n   -7.5726   -2.2995    0.0000 C   0  0  0  0  0  0  0  0  0 12  0  0\n   -7.5726   -1.4745    0.0000 C   0  0  0  0  0  0  0  0  0 13  0  0\n  1  2  1  0  0  0  0\n  2  3  1  0  0  0  0\n  3  4  2  0  0  0  0\n  3  5  1  0  0  0  0\n  5  6  1  0  0  0  0\n  6  7  2  0  0  0  0\n  7  8  1  0  0  0  0\n  8  9  1  0  0  0  0\n  8 13  2  0  0  0  0\n  9 10  2  0  0  0  0\n 10 11  1  0  0  0  0\n 11 12  2  0  0  0  0\n 12 13  1  0  0  0  0\nM  END\n$MOL\n\n  Mrv2102 11182121282D          \n\n 12 11  0  0  0  0            999 V2000\n   -3.7934    0.7703    0.0000 C   0  0  0  0  0  0  0  0  0 14  0  0\n   -3.0790    1.1828    0.0000 C   0  0  0  0  0  0  0  0  0 15  0  0\n   -2.3645    0.7703    0.0000 C   0  0  0  0  0  0  0  0  0 16  0  0\n   -3.7934   -0.0547    0.0000 C   0  0  0  0  0  0  0  0  0 17  0  0\n   -4.5078   -0.4672    0.0000 O   0  0  0  0  0  0  0  0  0 18  0  0\n   -3.0789   -0.4671    0.0000 O   0  0  0  0  0  0  0  0  0 19  0  0\n   -1.6500    1.1828    0.0000 O   0  0  0  0  0  0  0  0  0 20  0  0\n   -2.3645   -0.0547    0.0000 O   0  0  0  0  0  0  0  0  0 21  0  0\n   -3.0788   -1.2922    0.0000 C   0  0  0  0  0  0  0  0  0 22  0  0\n   -1.6500   -0.4672    0.0000 C   0  0  0  0  0  0  0  0  0 23  0  0\n   -2.3644   -1.7046    0.0000 C   0  0  0  0  0  0  0  0  0 24  0  0\n   -1.6500   -1.2922    0.0000 C   0  0  0  0  0  0  0  0  0 25  0  0\n  1  2  2  0  0  0  0\n  1  4  1  0  0  0  0\n  2  3  1  0  0  0  0\n  3  7  2  0  0  0  0\n  3  8  1  0  0  0  0\n  4  5  2  0  0  0  0\n  4  6  1  0  0  0  0\n  6  9  1  0  0  0  0\n  8 10  1  0  0  0  0\n  9 11  1  0  0  0  0\n 10 12  1  0  0  0  0\nM  END\n$MOL\n\n  Mrv2102 11182121282D          \n\n 25 26  0  0  0  0            999 V2000\n    5.1328    0.9532    0.0000 C   0  0  0  0  0  0  0  0  0  5  0  0\n    5.8002    0.4683    0.0000 N   0  0  0  0  0  0  0  0  0  6  0  0\n    5.5453   -0.3163    0.0000 C   0  0  0  0  0  0  0  0  0  7  0  0\n    4.7203   -0.3163    0.0000 C   0  0  0  0  0  0  0  0  0 14  0  0\n    4.4654    0.4683    0.0000 C   0  0  0  0  0  0  0  0  0 15  0  0\n    5.1328    1.7782    0.0000 C   0  0  0  0  0  0  0  0  0  3  0  0\n    3.6807    0.7232    0.0000 C   0  0  0  0  0  0  0  0  0 16  0  0\n    4.2354   -0.9838    0.0000 C   0  0  0  0  0  0  0  0  0 17  0  0\n    6.0302   -0.9838    0.0000 C   0  0  0  0  0  0  0  0  0  8  0  0\n    6.8507   -0.8975    0.0000 C   0  0  0  0  0  0  0  0  0  9  0  0\n    7.3356   -1.5650    0.0000 C   0  0  0  0  0  0  0  0  0 10  0  0\n    7.0001   -2.3187    0.0000 C   0  0  0  0  0  0  0  0  0 11  0  0\n    6.1796   -2.4049    0.0000 C   0  0  0  0  0  0  0  0  0 12  0  0\n    5.6947   -1.7375    0.0000 C   0  0  0  0  0  0  0  0  0 13  0  0\n    3.4149   -0.8975    0.0000 O   0  0  0  0  0  0  0  0  0 18  0  0\n    4.5709   -1.7375    0.0000 O   0  0  0  0  0  0  0  0  0 19  0  0\n    4.0860   -2.4049    0.0000 C   0  0  0  0  0  0  0  0  0 22  0  0\n    3.2655   -2.3187    0.0000 C   0  0  0  0  0  0  0  0  0 24  0  0\n    3.5092    1.5302    0.0000 O   0  0  0  0  0  0  0  0  0 20  0  0\n    3.0676    0.1712    0.0000 O   0  0  0  0  0  0  0  0  0 21  0  0\n    2.2830    0.4261    0.0000 C   0  0  0  0  0  0  0  0  0 23  0  0\n    1.6699   -0.1259    0.0000 C   0  0  0  0  0  0  0  0  0 25  0  0\n    5.8473    2.1907    0.0000 O   0  0  0  0  0  0  0  0  0  4  0  0\n    4.4183    2.1907    0.0000 O   0  0  0  0  0  0  0  0  0  2  0  0\n    4.4183    3.0157    0.0000 C   0  0  0  0  0  0  0  0  0  1  0  0\n  1  2  1  0  0  0  0\n  2  3  1  0  0  0  0\n  3  4  1  0  0  0  0\n  4  5  1  0  0  0  0\n  1  5  1  0  0  0  0\n  1  6  1  0  0  0  0\n  5  7  1  0  0  0  0\n  4  8  1  0  0  0  0\n  3  9  1  0  0  0  0\n 10 11  2  0  0  0  0\n 11 12  1  0  0  0  0\n 12 13  2  0  0  0  0\n 13 14  1  0  0  0  0\n  9 10  1  0  0  0  0\n  9 14  2  0  0  0  0\n  8 15  2  0  0  0  0\n  8 16  1  0  0  0  0\n 16 17  1  0  0  0  0\n 17 18  1  0  0  0  0\n  7 19  2  0  0  0  0\n  7 20  1  0  0  0  0\n 20 21  1  0  0  0  0\n 21 22  1  0  0  0  0\n  6 23  2  0  0  0  0\n  6 24  1  0  0  0  0\n 24 25  1  0  0  0  0\nM  END\n''')\n\nLet’s take a look at the reaction:\n\nIPythonConsole.molSize = (600,250)\nIPythonConsole.highlightByReactant = True\nrxn1\n\n\n\n\nWe can ask the reaction to tell us which atoms in the reactants are modified in the reaction:\n\nrxn1.Initialize()\nrxn1.GetReactingAtoms()\n\n((4, 5, 6), (0, 1))\n\n\nThe information about which atoms react is enough to figure out which bonds change, but we have to do some additional work for this:\n\nfrom collections import namedtuple\nAtomInfo = namedtuple('AtomInfo',('mapnum','reactant','reactantAtom','product','productAtom'))\ndef map_reacting_atoms_to_products(rxn,reactingAtoms):\n    ''' figures out which atoms in the products each mapped atom in the reactants maps to '''\n    res = []\n    for ridx,reacting in enumerate(reactingAtoms):\n        reactant = rxn.GetReactantTemplate(ridx)\n        for raidx in reacting:\n            mapnum = reactant.GetAtomWithIdx(raidx).GetAtomMapNum()\n            foundit=False\n            for pidx,product in enumerate(rxn.GetProducts()):\n                for paidx,patom in enumerate(product.GetAtoms()):\n                    if patom.GetAtomMapNum()==mapnum:\n                        res.append(AtomInfo(mapnum,ridx,raidx,pidx,paidx))\n                        foundit = True\n                        break\n                    if foundit:\n                        break\n    return res\ndef get_mapped_neighbors(atom):\n    ''' test all mapped neighbors of a mapped atom'''\n    res = {}\n    amap = atom.GetAtomMapNum()\n    if not amap:\n        return res\n    for nbr in atom.GetNeighbors():\n        nmap = nbr.GetAtomMapNum()\n        if nmap:\n            if amap>nmap:\n                res[(nmap,amap)] = (atom.GetIdx(),nbr.GetIdx())\n            else:\n                res[(amap,nmap)] = (nbr.GetIdx(),atom.GetIdx())\n    return res\n\nBondInfo = namedtuple('BondInfo',('product','productAtoms','productBond','status'))\ndef find_modifications_in_products(rxn):\n    ''' returns a 2-tuple with the modified atoms and bonds from the reaction '''\n    reactingAtoms = rxn.GetReactingAtoms()\n    amap = map_reacting_atoms_to_products(rxn,reactingAtoms)\n    res = []\n    seen = set()\n    # this is all driven from the list of reacting atoms:\n    for _,ridx,raidx,pidx,paidx in amap:\n        reactant = rxn.GetReactantTemplate(ridx)\n        ratom = reactant.GetAtomWithIdx(raidx)\n        product = rxn.GetProductTemplate(pidx)\n        patom = product.GetAtomWithIdx(paidx)\n\n        rnbrs = get_mapped_neighbors(ratom)\n        pnbrs = get_mapped_neighbors(patom)\n        for tpl in pnbrs:\n            pbond = product.GetBondBetweenAtoms(*pnbrs[tpl])\n            if (pidx,pbond.GetIdx()) in seen:\n                continue\n            seen.add((pidx,pbond.GetIdx()))\n            if not tpl in rnbrs:\n                # new bond in product\n                res.append(BondInfo(pidx,pnbrs[tpl],pbond.GetIdx(),'New'))\n            else:\n                # present in both reactants and products, check to see if it changed\n                rbond = reactant.GetBondBetweenAtoms(*rnbrs[tpl])\n                if rbond.GetBondType()!=pbond.GetBondType():\n                    res.append(BondInfo(pidx,pnbrs[tpl],pbond.GetIdx(),'Changed'))\n    return amap,res\n\nLet’s look at what that function returns for our reaction:\n\natms,bnds = find_modifications_in_products(rxn1)\nprint(atms)\nprint(bnds)\n\n[AtomInfo(mapnum=5, reactant=0, reactantAtom=4, product=0, productAtom=0), AtomInfo(mapnum=6, reactant=0, reactantAtom=5, product=0, productAtom=1), AtomInfo(mapnum=7, reactant=0, reactantAtom=6, product=0, productAtom=2), AtomInfo(mapnum=14, reactant=1, reactantAtom=0, product=0, productAtom=3), AtomInfo(mapnum=15, reactant=1, reactantAtom=1, product=0, productAtom=4)]\n[BondInfo(product=0, productAtoms=(4, 0), productBond=4, status='New'), BondInfo(product=0, productAtoms=(2, 1), productBond=1, status='Changed'), BondInfo(product=0, productAtoms=(3, 2), productBond=2, status='New'), BondInfo(product=0, productAtoms=(4, 3), productBond=3, status='Changed')]\n\n\nFinally, define the funciton which we’ll use to draw the product molecule with highlights shown for bonds and atoms involved in the reaction:\n\nfrom IPython.display import Image\ndef draw_product_with_modified_bonds(rxn,atms,bnds,productIdx=None,showAtomMaps=False):\n    if productIdx is None:\n        pcnts = [x.GetNumAtoms() for x in rxn.GetProducts()]\n        largestProduct = list(sorted(zip(pcnts,range(len(pcnts))),reverse=True))[0][1]\n        productIdx = largestProduct\n    d2d = Draw.rdMolDraw2D.MolDraw2DCairo(350,300)\n    pmol = Chem.Mol(rxn.GetProductTemplate(productIdx))\n    Chem.SanitizeMol(pmol)\n    if not showAtomMaps:\n        for atom in pmol.GetAtoms():\n            atom.SetAtomMapNum(0)\n    bonds_to_highlight=[]\n    highlight_bond_colors={}\n    atoms_seen = set()\n    for binfo in bnds:\n        if binfo.product==productIdx and binfo.status=='New':\n            bonds_to_highlight.append(binfo.productBond)\n            atoms_seen.update(binfo.productAtoms)\n            highlight_bond_colors[binfo.productBond] = (1,.4,.4)\n        if binfo.product==productIdx and binfo.status=='Changed':\n            bonds_to_highlight.append(binfo.productBond)\n            atoms_seen.update(binfo.productAtoms)\n            highlight_bond_colors[binfo.productBond] = (.4,.4,1)\n    atoms_to_highlight=set()\n    for ainfo in atms:\n        if ainfo.product != productIdx or ainfo.productAtom in atoms_seen:\n            continue\n        atoms_to_highlight.add(ainfo.productAtom)\n\n    d2d.drawOptions().useBWAtomPalette()\n    d2d.drawOptions().continuousHighlight=False\n    d2d.drawOptions().highlightBondWidthMultiplier = 24\n    d2d.drawOptions().setHighlightColour((.9,.9,0))\n    d2d.drawOptions().fillHighlights=False\n    atoms_to_highlight.update(atoms_seen)\n    d2d.DrawMolecule(pmol,highlightAtoms=atoms_to_highlight,highlightBonds=bonds_to_highlight,\n                     highlightBondColors=highlight_bond_colors)\n    d2d.FinishDrawing()\n    return d2d.GetDrawingText()\n\nNow we can draw the highlighted product molecule:\n\nImage(draw_product_with_modified_bonds(rxn1,atms,bnds))\n\n\n\n\nLet’s look at some other reactions. I will use the SI data from\n\nimport pandas as pd\ndf = pd.read_csv('../data/reaction_data_ci6b00564/dataSetB.csv')\ndf.head()\n\n\n\n\n\n  \n    \n      \n      rxn_Class\n      patentID\n      rxnSmiles_Mapping_NameRxn\n      reactantSet_NameRxn\n      NameRxn_Mapping_Complete\n      rxnSmiles_Mapping_IndigoTK\n      reactantSet_IndigoTK\n      IndigoTK_Mapping_Complete\n      rxnSmiles_IndigoAutoMapperKNIME\n      reactantSet_IndigoAutoMapperKNIME\n      IndigoAutoMapperKNIME_Mapping_Complete\n    \n  \n  \n    \n      0\n      6\n      US05849732\n      C.CCCCCC.CO.O=C(OCc1ccccc1)[NH:1][CH2:2][CH2:3...\n      set([3, 4])\n      True\n      C(OC([NH:11][CH2:12][CH2:13][CH2:14][CH2:15][C...\n      set([0, 2])\n      True\n      C.CCCCCC.CO.[CH3:10][O:11][C:12]([C@@H:14]([NH...\n      set([3, 4])\n      True\n    \n    \n      1\n      2\n      US20120114765A1\n      O[C:1](=[O:2])[c:3]1[cH:4][c:5]([N+:6](=[O:7])...\n      set([0, 1])\n      True\n      [Cl:1][c:2]1[cH:3][n:4][cH:5][c:6]([Cl:20])[c:...\n      set([0, 1])\n      True\n      [NH2:1][c:2]1[c:11]2[c:6]([cH:7][n:8][cH:9][cH...\n      set([0, 1])\n      True\n    \n    \n      2\n      1\n      US08003648B2\n      Cl.O=[CH:1][c:2]1[cH:3][cH:4][c:5](-[c:6]2[n:7...\n      set([1, 3])\n      True\n      [CH2:1]([NH:3][CH2:4][CH3:5])[CH3:2].C([BH3-])...\n      set([0, 3])\n      True\n      [CH3:1][CH2:2][NH:3][CH2:4][CH3:5].[CH3:6][c:7...\n      set([0, 1])\n      True\n    \n    \n      3\n      1\n      US09045475B2\n      CC(=O)O[BH-](OC(C)=O)OC(C)=O.ClCCl.O=[C:1]([CH...\n      set([2, 3])\n      True\n      [nH:1]1[c:5]2[n:6][cH:7][c:8]([O:10][c:11]3[cH...\n      set([0, 3])\n      True\n      CC(O[BH-](OC(=O)C)OC(=O)C)=O.[CH3:14][C:15]1([...\n      set([1, 3])\n      True\n    \n    \n      4\n      2\n      US08188098B2\n      CCN(C(C)C)C(C)C.ClCCl.Cl[C:1](=[O:2])[O:3][CH:...\n      set([2, 5])\n      True\n      Cl[C:2]([O:4][CH:5]1[CH2:9][CH2:8][CH2:7][CH2:...\n      set([0, 2])\n      True\n      CCN(C(C)C)C(C)C.[CH3:10][CH2:11][O:12][c:13]1[...\n      set([1, 4])\n      True\n    \n  \n\n\n\n\n\nrxnclass = 1\nclass_smis = df[df['rxn_Class']==rxnclass].rxnSmiles_Mapping_NameRxn.to_list()\nrxn = rdChemReactions.ReactionFromSmarts(class_smis[3],useSmiles=True)\nrxn.Initialize()\natms,bnds = find_modifications_in_products(rxn)\nprint(atms)\nprint(bnds)\nImage(draw_product_with_modified_bonds(rxn,atms,bnds))\n\n[AtomInfo(mapnum=1, reactant=3, reactantAtom=1, product=0, productAtom=0), AtomInfo(mapnum=7, reactant=4, reactantAtom=0, product=0, productAtom=6)]\n[BondInfo(product=0, productAtoms=(6, 0), productBond=5, status='New')]\n\n\n\n\n\n\nrxnclass = 4\nclass_smis = df[df['rxn_Class']==rxnclass].rxnSmiles_Mapping_NameRxn.to_list()\nrxn = rdChemReactions.ReactionFromSmarts(class_smis[1],useSmiles=True)\nrxn.Initialize()\natms,bnds = find_modifications_in_products(rxn)\nprint(atms)\nprint(bnds)\nImage(draw_product_with_modified_bonds(rxn,atms,bnds))\n\n[AtomInfo(mapnum=1, reactant=1, reactantAtom=1, product=0, productAtom=0), AtomInfo(mapnum=2, reactant=1, reactantAtom=2, product=0, productAtom=9), AtomInfo(mapnum=16, reactant=2, reactantAtom=0, product=0, productAtom=18), AtomInfo(mapnum=17, reactant=2, reactantAtom=1, product=0, productAtom=16), AtomInfo(mapnum=19, reactant=2, reactantAtom=3, product=0, productAtom=15)]\n[BondInfo(product=0, productAtoms=(9, 0), productBond=8, status='Changed'), BondInfo(product=0, productAtoms=(18, 0), productBond=18, status='New'), BondInfo(product=0, productAtoms=(15, 9), productBond=14, status='New'), BondInfo(product=0, productAtoms=(16, 18), productBond=17, status='Changed'), BondInfo(product=0, productAtoms=(15, 16), productBond=15, status='Changed')]\n\n\n\n\n\nLook at an example where there are no changed bonds in the products but where there is a changed atom:\n\nrxnclass = 7\nclass_smis = df[df['rxn_Class']==rxnclass].rxnSmiles_Mapping_NameRxn.to_list()\nrxn = rdChemReactions.ReactionFromSmarts(class_smis[1],useSmiles=True)\nrxn.Initialize()\natms,bnds = find_modifications_in_products(rxn)\nprint(atms)\nprint(bnds)\nImage(draw_product_with_modified_bonds(rxn,atms,bnds))\n\n[AtomInfo(mapnum=1, reactant=1, reactantAtom=1, product=0, productAtom=0)]\n[]"
  },
  {
    "objectID": "posts/2023-01-05-rgd-edge-cases.html",
    "href": "posts/2023-01-05-rgd-edge-cases.html",
    "title": "R-Group Decomposition: Edge Cases",
    "section": "",
    "text": "This is an updated version of an earlier post.\nThe RDKit’s code for doing R-group decomposition (RGD) is quite flexible but also rather “undocumented”. Thanks to that fact, you may not be aware of some of the cool stuff that’s there. This post is an attempt to at least begin to remedy that by looking at some of the edge cases that come up while doing RGD.\nI have another post coming in the near future which is a bit more of a tutorial, but here we’ll look at a number of difficult/interesting problems that arise all the time when doing RGD on real-world datasets:\n\nHandling symmetric cores\nHandling stereochemistry\nHandling sidechains that attach to the core at more than one point\nHandling multiple scaffolds or variable scaffolds\n\nSome of these problems are really tricky to solve perfectly, so please expect that there will be bugs (particularly in the code for handling symmetrization). If you find something that seems wrong, please do file a bug report, ideally with the exact code and structures that you used.\nThe code in this blog post behaves correctly with v2019.09.1 and later of the RDKit. Older versions have bugs that generate different results for some of the examples here.\n\nimport pandas as pd\nfrom rdkit import Chem\nfrom rdkit.Chem.Draw import IPythonConsole\nfrom rdkit.Chem import Draw\nfrom rdkit.Chem import rdDepictor\nfrom rdkit.Chem import PandasTools\nIPythonConsole.ipython_useSVG=True\nfrom rdkit.Chem import rdRGroupDecomposition\nfrom rdkit import RDLogger\nRDLogger.DisableLog('rdApp.warning')\nimport rdkit\nprint(rdkit.__version__)\n\n2022.09.1\n\n\n\nPandasTools.RenderImagesInAllDataFrames()\n\n\nBasics: a symmetric core\nLet’s start with an easy example that has a symmetric core. In this case R1 and R5 are symmetry equivalent as are R2 and R4):\n\nscaffold = Chem.MolFromSmiles('[*:1]c1c([*:2])c([*:3])c([*:4])c([*:5])n1')\nscaffold\n\n\n\n\n \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHere are some molecules that share that scaffold. We’ve provided the atoms in different orders to make sure that’s properly handled by the RGD code.\n\nmols = [Chem.MolFromSmiles(smi) for smi in 'c1c(F)cccn1 c1c(Cl)c(C)ccn1 c1c(O)cccn1 c1c(F)c(C)ccn1 c1cc(Cl)c(F)cn1'.split()]\nDraw.MolsToGridImage(mols,molsPerRow=4)\n\n\n\n\nDo a version where we provide a scaffold without the R labels to start with:\n\nscaffold = Chem.MolFromSmiles('c1ccccn1')\nscaffold\n\n\n\n\n \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ngroups,_ = rdRGroupDecomposition.RGroupDecompose([scaffold],mols,asSmiles=False,asRows=False) \nPandasTools.RGroupDecompositionToFrame(groups,mols,include_core=True)\n\n\n\n\n\n  \n    \n      \n      Mol\n      Core\n      R1\n      R2\n    \n  \n  \n    \n      0\n      \n      \n      \n      \n    \n    \n      1\n      \n      \n      \n      \n    \n    \n      2\n      \n      \n      \n      \n    \n    \n      3\n      \n      \n      \n      \n    \n    \n      4\n      \n      \n      \n      \n    \n  \n\n\n\n\nThose labels were automatically assigned and they aren’t consistent with what we had above. Notice, however, that the symmetry in the scaffold has been properly handled.\nIf we care about the R group labels, We can explicitly label the side chains:\n\n# note: there's a bug in RDKit 2019.03.3 and 2019.03.4 that causes this to generate different\n# results with those versions\nscaffold = Chem.MolFromSmiles('c1c([*:2])c([*:3])ccn1')\ngroups,_ = rdRGroupDecomposition.RGroupDecompose([scaffold],mols,asSmiles=False,asRows=False) \nPandasTools.RGroupDecompositionToFrame(groups,mols,include_core=True)\n\n\n\n\n\n  \n    \n      \n      Mol\n      Core\n      R2\n      R3\n    \n  \n  \n    \n      0\n      \n      \n      \n      \n    \n    \n      1\n      \n      \n      \n      \n    \n    \n      2\n      \n      \n      \n      \n    \n    \n      3\n      \n      \n      \n      \n    \n    \n      4\n      \n      \n      \n      \n    \n  \n\n\n\n\nWe’ve just been looking at compound images since that’s a bit more readable. Here’s what the raw output from the function looks like:\n\ngroups,_ = rdRGroupDecomposition.RGroupDecompose([scaffold],mols,asSmiles=True,asRows=False) \nprint(groups)\n\n{'Core': ['c1cc([*:3])c([*:2])cn1', 'c1cc([*:3])c([*:2])cn1', 'c1cc([*:3])c([*:2])cn1', 'c1cc([*:3])c([*:2])cn1', 'c1cc([*:3])c([*:2])cn1'], 'R2': ['F[*:2]', 'Cl[*:2]', 'O[*:2]', 'F[*:2]', 'F[*:2]'], 'R3': ['[H][*:3]', 'C[*:3]', '[H][*:3]', 'C[*:3]', 'Cl[*:3]']}\n\n\nWe can also get that in a row-oriented format:\n\ngroups,_ = rdRGroupDecomposition.RGroupDecompose([scaffold],mols,asSmiles=True,asRows=True) \nprint(groups)\n\n[{'Core': 'c1cc([*:3])c([*:2])cn1', 'R2': 'F[*:2]', 'R3': '[H][*:3]'}, {'Core': 'c1cc([*:3])c([*:2])cn1', 'R2': 'Cl[*:2]', 'R3': 'C[*:3]'}, {'Core': 'c1cc([*:3])c([*:2])cn1', 'R2': 'O[*:2]', 'R3': '[H][*:3]'}, {'Core': 'c1cc([*:3])c([*:2])cn1', 'R2': 'F[*:2]', 'R3': 'C[*:3]'}, {'Core': 'c1cc([*:3])c([*:2])cn1', 'R2': 'F[*:2]', 'R3': 'Cl[*:3]'}]\n\n\n\n\nStereochemistry\nMaking sure that the sidechains are labelled correctly on chiral centers can be a bit trickier.\nHere’s a set of molecules we’ll be using. Some have a chiral center, some don’t. There are a few that have sidechains with dual attachment points (i.e. rings). We’ll look at those in the next section.\n\nmols = [x for x in Chem.SDMolSupplier('../data/rgd_chiral.sdf')]\nDraw.MolsToGridImage(mols,molsPerRow=4)\n\n\n\n\nRemove the examples with “ring” sidechains. We’ll get to those later\n\nq = Chem.MolFromSmarts('[R2]')\nmols = [x for x in mols if not x.HasSubstructMatch(q)]\nDraw.MolsToGridImage(mols,molsPerRow=4)\n\n\n\n\nWe’ll define two scaffolds, the first with a chiral center, the second without. In this case we will add explicit markers for the substituents. This is currently (v2019.09) necessary to properly handle atomic chirality.\n\nscaffold = Chem.MolFromSmiles('[*:1]C1([*:2])OCCC=C1')\nchiral_scaffold = Chem.MolFromSmiles('[*:1][C@]1([*:2])OCCC=C1')\nDraw.MolsToGridImage([scaffold,chiral_scaffold])\n\n\n\n\nStart with doing a decomposition with the non-chiral scaffold. This matches all the molecules, but generates results that are not consistent with the chirality. The compounds in rows 2 and 3 (numbered from zero) demonstrate the problem clearly.\n\ngroups,_ = rdRGroupDecomposition.RGroupDecompose([scaffold],mols,asSmiles=False,asRows=False) \nPandasTools.RGroupDecompositionToFrame(groups,mols,include_core=True)\n\n\n\n\n\n  \n    \n      \n      Mol\n      Core\n      R1\n      R2\n    \n  \n  \n    \n      0\n      \n      \n      \n      \n    \n    \n      1\n      \n      \n      \n      \n    \n    \n      2\n      \n      \n      \n      \n    \n    \n      3\n      \n      \n      \n      \n    \n    \n      4\n      \n      \n      \n      \n    \n    \n      5\n      \n      \n      \n      \n    \n    \n      6\n      \n      \n      \n      \n    \n    \n      7\n      \n      \n      \n      \n    \n    \n      8\n      \n      \n      \n      \n    \n    \n      9\n      \n      \n      \n      \n    \n  \n\n\n\n\nTry the chiral scaffold. This one will only match the chiral compounds, but it does the right thing with those:\n\ngroups,unmatched = rdRGroupDecomposition.RGroupDecompose([chiral_scaffold],mols,asSmiles=False,asRows=False)\ntmols = [mols[x] for x in range(len(mols)) if x not in unmatched]\nPandasTools.RGroupDecompositionToFrame(groups,tmols,include_core=True,redraw_sidechains=True)\n\n[13:50:06] No core matches\n[13:50:06] No core matches\n[13:50:06] No core matches\n[13:50:06] No core matches\n\n\n\n\n\n\n  \n    \n      \n      Mol\n      Core\n      R1\n      R2\n    \n  \n  \n    \n      0\n      \n      \n      \n      \n    \n    \n      1\n      \n      \n      \n      \n    \n    \n      2\n      \n      \n      \n      \n    \n    \n      3\n      \n      \n      \n      \n    \n    \n      4\n      \n      \n      \n      \n    \n    \n      5\n      \n      \n      \n      \n    \n  \n\n\n\n\nNote that in each case the atom is assigned to the correct R group.\nWe can also combine the two scaffolds so that we can get the chiral and achiral cases. Order is important, so we include the more specific scaffold (the chiral one) first. In this case the stereochemistry determines the R1/R2 assignment for the chiral molecules. For the non-chiral molecules R1 and R2 are assigned using the standard symmetrization code.\n\ngroups,unmatched = rdRGroupDecomposition.RGroupDecompose([chiral_scaffold,scaffold],mols,asSmiles=False,asRows=False)\nPandasTools.RGroupDecompositionToFrame(groups,mols,include_core=True,redraw_sidechains=True)\n\n\n\n\n\n  \n    \n      \n      Mol\n      Core\n      R1\n      R2\n    \n  \n  \n    \n      0\n      \n      \n      \n      \n    \n    \n      1\n      \n      \n      \n      \n    \n    \n      2\n      \n      \n      \n      \n    \n    \n      3\n      \n      \n      \n      \n    \n    \n      4\n      \n      \n      \n      \n    \n    \n      5\n      \n      \n      \n      \n    \n    \n      6\n      \n      \n      \n      \n    \n    \n      7\n      \n      \n      \n      \n    \n    \n      8\n      \n      \n      \n      \n    \n    \n      9\n      \n      \n      \n      \n    \n  \n\n\n\n\n\n\nSidechains that attach in more than one place\nThis one is tricky, and there’s not really a right answer, this is just a demonstration of what the current code does\n\nmols = [x for x in Chem.SDMolSupplier('../data/rgd_chiral.sdf')]\nq = Chem.MolFromSmarts('[R2]')\nmols = [x for x in mols if x.HasSubstructMatch(q)]\nDraw.MolsToGridImage(mols,molsPerRow=4)\n\n\n\n\n\nscaffold = Chem.MolFromSmiles('C1OCC=CC1')\ngroups,unmatched = rdRGroupDecomposition.RGroupDecompose([scaffold],mols,asSmiles=False,asRows=False)\nPandasTools.RGroupDecompositionToFrame(groups,mols,include_core=True,redraw_sidechains=True)\n\n\n\n\n\n  \n    \n      \n      Mol\n      Core\n      R1\n      R2\n    \n  \n  \n    \n      0\n      \n      \n      \n      \n    \n    \n      1\n      \n      \n      \n      \n    \n    \n      2\n      \n      \n      \n      \n    \n  \n\n\n\n\n\n\nScaffold Variation\nWhat happens if there are small variations in the scaffold within the series, something that we see all the time in med chem work?\n\nmols = [Chem.MolFromSmiles(smi) for smi in 'c1c(F)cccn1 c1c(Cl)c(C)ccn1 c1c(F)cncn1 c1c(F)c(C)ccn1'.split()]\nDraw.MolsToGridImage(mols,molsPerRow=4)\n\n\n\n\n\nscaffold = Chem.MolFromSmiles('c1c([*:1])c([*:2])ccn1')\ngroups,unmatched = rdRGroupDecomposition.RGroupDecompose([scaffold],mols,asSmiles=True,asRows=False)\n# the second return value, unmatched, provides the indices of the molecules that did not match a scaffold:\nprint(unmatched)\ngroups\n\n[2]\n\n\n[13:50:06] No core matches\n\n\n{'Core': ['c1cc([*:2])c([*:1])cn1',\n  'c1cc([*:2])c([*:1])cn1',\n  'c1cc([*:2])c([*:1])cn1'],\n 'R1': ['F[*:1]', 'Cl[*:1]', 'F[*:1]'],\n 'R2': ['[H][*:2]', 'C[*:2]', 'C[*:2]']}\n\n\nYou can see that now we only get three results, the third molecule (index 2) didn’t end up in the output. Sometimes this is ok, but in cases like this it would be great if that molecule were also included in the R-group decomposition.\nOne solution to this is to provide two different scaffolds:\n\nscaffold2 = Chem.MolFromSmiles('c1c([*:1])c([*:2])ncn1')\ngroups,unmatched = rdRGroupDecomposition.RGroupDecompose([scaffold,scaffold2],mols,asSmiles=False,asRows=False)\nprint(unmatched)\nPandasTools.RGroupDecompositionToFrame(groups,mols,include_core=True)\n\n[]\n\n\n\n\n\n\n  \n    \n      \n      Mol\n      Core\n      R1\n      R2\n    \n  \n  \n    \n      0\n      \n      \n      \n      \n    \n    \n      1\n      \n      \n      \n      \n    \n    \n      2\n      \n      \n      \n      \n    \n    \n      3\n      \n      \n      \n      \n    \n  \n\n\n\n\nNotice that unmatched is now empty; all molecules matched one of the two cores\nAnother is provide the scaffold as SMARTS:\n\nsma_scaffold = Chem.MolFromSmarts('c:1:c(-[*:1]):c(-[*:2]):*:c:n:1')\ngroups,unmatched = rdRGroupDecomposition.RGroupDecompose([sma_scaffold],mols,asSmiles=False,asRows=False)\nPandasTools.RGroupDecompositionToFrame(groups,mols,include_core=True)\n\n\n\n\n\n  \n    \n      \n      Mol\n      Core\n      R1\n      R2\n    \n  \n  \n    \n      0\n      \n      \n      \n      \n    \n    \n      1\n      \n      \n      \n      \n    \n    \n      2\n      \n      \n      \n      \n    \n    \n      3\n      \n      \n      \n      \n    \n  \n\n\n\n\n\n\nMultiple scaffolds\nWhat about if we have multiple scaffolds which share a common SAR? Here we just provide them both and label the attachment points manually to show the correspondance.\n\nmols = [Chem.MolFromSmiles(smi) for smi in 'Fc1ccc(O)cc1 Fc1ccc(OC)cc1 Oc1ccc(Cl)cc1 Clc1ccc(OC)cc1 Fc1ccc(O)s1 COc1ccc(F)s1 Clc1ccc(O)s1 Clc1ccc(OC)s1'.split()]\nDraw.MolsToGridImage(mols,molsPerRow=4)\n\n\n\n\n\nscaffolds = [Chem.MolFromSmiles('[*:1]c1ccc([*:2])cc1'),Chem.MolFromSmiles('[*:1]c1ccc([*:2])s1')]\ngroups,unmatched = rdRGroupDecomposition.RGroupDecompose(scaffolds,mols,asSmiles=False,asRows=False)\nPandasTools.RGroupDecompositionToFrame(groups,mols,include_core=True)\n\n\n\n\n\n  \n    \n      \n      Mol\n      Core\n      R1\n      R2\n    \n  \n  \n    \n      0\n      \n      \n      \n      \n    \n    \n      1\n      \n      \n      \n      \n    \n    \n      2\n      \n      \n      \n      \n    \n    \n      3\n      \n      \n      \n      \n    \n    \n      4\n      \n      \n      \n      \n    \n    \n      5\n      \n      \n      \n      \n    \n    \n      6\n      \n      \n      \n      \n    \n    \n      7\n      \n      \n      \n      \n    \n  \n\n\n\n\nNotice that the symmetrization also worked.\n\n\nLooking at the options that are available\nWe’ll use a real dataset pulled from ChEMBL for this:\n\ncore = Chem.MolFromSmiles('c1ccccc1-c2nc(c1ccccc1)no2')\ncore\n\n\n\n\n \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nsmiles = ['CCOCCC1(Oc2ccc(Oc3ccc(-c4nc(-c5ccccc5)no4)cc3)cc2)C(=O)NC(=O)NC1=O', 'CCOc1ccc(-c2nc(-c3ccc(CN4CC(C(=O)O)C4)cc3)no2)cc1', 'CC(C)Cc1ccc(-c2nc(-c3ccc(CN4CC(C(=O)O)C4)cc3)no2)cc1', 'CCOCCC1(Oc2ccc(Oc3ccc(-c4nc(-c5ccc(F)cc5)no4)cc3)cc2)C(=O)NC(=O)NC1=O', 'O=C(O)C1CN(Cc2ccc(-c3noc(-c4ccc(C5CCC5)cc4)n3)cc2)C1', 'CCOCCC1(Oc2ccc(Oc3ccc(-c4noc(-c5ccccc5)n4)cc3)cc2)C(=O)NC(=O)NC1=O', 'O=C(O)C1CN(Cc2ccc(-c3noc(-c4ccc([C@@H]5CCC(F)(F)C5)cc4)n3)cc2)C1', 'CC(C)(C)c1ccc(-c2nc(-c3ccc(CN4CC(C(=O)O)C4)cc3)no2)cc1', 'Cc1cc(CCC(=O)O)ccc1-c1noc(-c2ccc(OC(C)C(F)(F)F)c(C#N)c2)n1', 'Cc1cc(-c2nc(-c3ccc(CCC(=O)O)cc3C)no2)ccc1OC(C)C', 'CC(C)(C)Cc1ccc(-c2nc(-c3ccc(CN4CC(C(=O)O)C4)cc3)no2)cc1', 'Cc1cc(CCC(=O)O)ccc1-c1noc(-c2ccc(OC(C)C)c(F)c2)n1', 'COc1cc(-c2nc(-c3ccc(CCC(=O)O)cc3C)no2)ccc1OC(C)C', 'CC(C)(C)c1ccc(-c2noc(-c3ccc(CN4CC(C(=O)O)C4)cc3)n2)cc1', 'Cc1cc(CCCCCC(=O)O)ccc1-c1noc(-c2ccc(C3CCCCC3)cc2)n1', 'Cc1cc(CCC(=O)O)ccc1-c1noc(-c2ccc(OCC(F)(F)F)c(C#N)c2)n1', 'CCOCCC1(Oc2ccc(Oc3ccc(-c4nc(-c5cccc(F)c5)no4)cc3)cc2)C(=O)NC(=O)NC1=O', 'Cc1ccccc1-c1noc(-c2ccc(C3CCCCC3)cc2)n1', 'CCCCc1ccc(-c2nc(-c3ccc(CN4CC(C(=O)O)C4)cc3)no2)cc1', 'Cc1cc(CCC(=O)O)ccc1-c1noc(-c2ccc(OC(C)C)c(C#N)c2)n1', 'O=C(O)C1CN(Cc2ccc(-c3noc(-c4ccc(CCC(F)(F)F)cc4)n3)cc2)C1', 'O=C(O)C1CN(Cc2ccc(-c3noc(-c4ccc(-c5ccccc5)cc4)n3)cc2)C1', 'O=C(O)C1CN(Cc2ccc(-c3noc(-c4ccc(C5CCCCC5)cc4)n3)cc2)C1', 'CC[C@H](C)Oc1ccc(-c2nc(-c3ccc(CCC(=O)O)cc3C)no2)cc1C#N', 'Cc1cc(CCCC(=O)O)ccc1-c1noc(-c2ccc(C3CCCCC3)cc2)n1', 'Cc1cc(CCC(=O)O)ccc1-c1noc(-c2ccc(OC(C)C)c(C(F)(F)F)c2)n1', 'Cc1cc(CCC(=O)O)ccc1-c1noc(-c2ccc(OC(C)C)c(Cl)c2)n1', 'CCCCCCc1ccc(-c2nc(-c3ccc(CN4CC(C(=O)O)C4)cc3)no2)cc1', 'Cc1cc(CCC(=O)O)ccc1-c1noc(-c2ccc(OC(C)C)c(Br)c2)n1', 'Cc1cc(CCC(=O)O)ccc1-c1noc(-c2ccc(OC(C(F)(F)F)C(F)(F)F)c(C#N)c2)n1', 'O=C(O)C1CN(Cc2ccc(-c3noc(-c4ccc(C5CCCC5)cc4)n3)cc2)C1', 'O=C(O)C1CN(Cc2ccc(-c3noc(-c4ccc([C@H]5CCC(F)(F)C5)cc4)n3)cc2)C1', 'O=C(O)C1CN(Cc2ccc(-c3noc(-c4ccc(C5CC5)cc4)n3)cc2)C1', 'CCCc1ccc(-c2nc(-c3ccc(CN4CC(C(=O)O)C4)cc3)no2)cc1', 'CCOCCC1(Oc2ccc(Oc3ccc(-c4nc(-c5ccccc5F)no4)cc3)cc2)C(=O)NC(=O)NC1=O', 'CCC(C)(C)c1ccc(-c2nc(-c3ccc(CN4CC(C(=O)O)C4)cc3)no2)cc1', 'Cc1cc(CC(=O)O)ccc1-c1noc(-c2ccc(C3CCCCC3)cc2)n1', 'CC(C)Oc1ccc(-c2nc(-c3ccc(CN4CC(C(=O)O)C4)cc3)no2)cc1', 'Cc1cc(C(=O)O)ccc1-c1noc(-c2ccc(C3CCCCC3)cc2)n1', 'CCOc1ccc(-c2nc(-c3ccc(CCC(=O)O)cc3C)no2)cc1C(F)(F)F', 'Cc1cc(CCC(=O)O)ccc1-c1noc(-c2ccc(C3CCCCC3)cc2)n1', 'COc1ccc(-c2nc(-c3ccc(CCC(=O)O)cc3C)no2)cc1C(F)(F)F']\nmols = [Chem.MolFromSmiles(x) for x in smiles]\n\n\nDraw.MolsToGridImage(mols[:16],molsPerRow=4)\n\n\n\n\n\n# we'll use just the first 16 molecules to make things a bit smaller for this demo\nm16 = mols[:16]\ngroups,unmatched = rdRGroupDecomposition.RGroupDecompose([core],m16,asSmiles=False,asRows=False)\nPandasTools.RGroupDecompositionToFrame(groups,m16,include_core=True,redraw_sidechains=True)\n\n\n\n\n\n  \n    \n      \n      Mol\n      Core\n      R1\n      R2\n      R3\n      R4\n    \n  \n  \n    \n      0\n      \n      \n      \n      \n      \n      \n    \n    \n      1\n      \n      \n      \n      \n      \n      \n    \n    \n      2\n      \n      \n      \n      \n      \n      \n    \n    \n      3\n      \n      \n      \n      \n      \n      \n    \n    \n      4\n      \n      \n      \n      \n      \n      \n    \n    \n      5\n      \n      \n      \n      \n      \n      \n    \n    \n      6\n      \n      \n      \n      \n      \n      \n    \n    \n      7\n      \n      \n      \n      \n      \n      \n    \n    \n      8\n      \n      \n      \n      \n      \n      \n    \n    \n      9\n      \n      \n      \n      \n      \n      \n    \n    \n      10\n      \n      \n      \n      \n      \n      \n    \n    \n      11\n      \n      \n      \n      \n      \n      \n    \n    \n      12\n      \n      \n      \n      \n      \n      \n    \n    \n      13\n      \n      \n      \n      \n      \n      \n    \n    \n      14\n      \n      \n      \n      \n      \n      \n    \n    \n      15\n      \n      \n      \n      \n      \n      \n    \n  \n\n\n\n\nLet’s do a query with labelled R groups:\n\nlcore = Chem.MolFromSmiles('c1cc([*:1])ccc1-c2nc(c1ccc([*:2])cc1)no2')\nlcore\n\n\n\n\n \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ngroups,unmatched = rdRGroupDecomposition.RGroupDecompose([lcore],m16,asSmiles=False,asRows=False)\nPandasTools.RGroupDecompositionToFrame(groups,m16,include_core=True,redraw_sidechains=True)\n\n\n\n\n\n  \n    \n      \n      Mol\n      Core\n      R1\n      R2\n      R3\n      R4\n    \n  \n  \n    \n      0\n      \n      \n      \n      \n      \n      \n    \n    \n      1\n      \n      \n      \n      \n      \n      \n    \n    \n      2\n      \n      \n      \n      \n      \n      \n    \n    \n      3\n      \n      \n      \n      \n      \n      \n    \n    \n      4\n      \n      \n      \n      \n      \n      \n    \n    \n      5\n      \n      \n      \n      \n      \n      \n    \n    \n      6\n      \n      \n      \n      \n      \n      \n    \n    \n      7\n      \n      \n      \n      \n      \n      \n    \n    \n      8\n      \n      \n      \n      \n      \n      \n    \n    \n      9\n      \n      \n      \n      \n      \n      \n    \n    \n      10\n      \n      \n      \n      \n      \n      \n    \n    \n      11\n      \n      \n      \n      \n      \n      \n    \n    \n      12\n      \n      \n      \n      \n      \n      \n    \n    \n      13\n      \n      \n      \n      \n      \n      \n    \n    \n      14\n      \n      \n      \n      \n      \n      \n    \n    \n      15\n      \n      \n      \n      \n      \n      \n    \n  \n\n\n\n\nWe can exclude any molecules that have R groups in non-labelled positions:\n\nparams = rdRGroupDecomposition.RGroupDecompositionParameters()\nparams.onlyMatchAtRGroups = True\ngroups,unmatched = rdRGroupDecomposition.RGroupDecompose([lcore],m16,asSmiles=False,asRows=False,options=params)\ntmols = [x for i,x in enumerate(m16) if i not in unmatched]\nPandasTools.RGroupDecompositionToFrame(groups,tmols,include_core=True,redraw_sidechains=True)\n\n[13:50:08] No core matches\n[13:50:08] No core matches\n[13:50:08] No core matches\n[13:50:08] No core matches\n[13:50:08] No core matches\n[13:50:08] No core matches\n\n\n\n\n\n\n  \n    \n      \n      Mol\n      Core\n      R1\n      R2\n    \n  \n  \n    \n      0\n      \n      \n      \n      \n    \n    \n      1\n      \n      \n      \n      \n    \n    \n      2\n      \n      \n      \n      \n    \n    \n      3\n      \n      \n      \n      \n    \n    \n      4\n      \n      \n      \n      \n    \n    \n      5\n      \n      \n      \n      \n    \n    \n      6\n      \n      \n      \n      \n    \n    \n      7\n      \n      \n      \n      \n    \n    \n      8\n      \n      \n      \n      \n    \n    \n      9\n      \n      \n      \n      \n    \n  \n\n\n\n\nThere are other useful parameters to control the calculation in that RGroupDecompositionParameters object, but this post is already getting pretty long, so I’m going to wrap up now and leave exploring those as an exercise for the reader. ;-)"
  },
  {
    "objectID": "posts/2022-12-25-colliding-bits-ii-revisited.html",
    "href": "posts/2022-12-25-colliding-bits-ii-revisited.html",
    "title": "Colliding bits II, revisited",
    "section": "",
    "text": "Note: This is a significantly revised version of an earlier post.\nIn an earlier post I looked at the minimal impact bit collisions in the RDKit’s Morgan fingerprints has on calculated similarity between molecules. This time I’m going to look at the impact of fingerprint size (as a surrogate for number of collisions) on the performance of machine-learning algorithms.\nI will use Datasets II from our model fusion paper to do the analysis. I’ve covered these datasets, which are available as part of the benchmarkng platform, in some detail in an earlier post.\nWhile working on this post I updated the benchmarking platform to work with Python 3 (the paper was a long time ago!) and added a few additional learning methods and one additional evaluation metric. Those will be merged back to the github repo soon (probably by the time this blog post actually appears), in the meantime it’s here (if that branch is missing, it indicates that the code is already merged to the main repo).\nThe fingerprints examined here:\n\nMFP2: Morgan fingerprint, radius = 2\nMFP3: Morgan fingerprint, radius = 3\nRDK5: RDKit fingerprint, max path length = 5\nHashAP: atom pairs, using count simulation\nHashTT: topological torsions, using count simulation\n\nThe benchmarking platform is pre-configured to support a short (1K) and long (16K) form of the fingerprints, so that part was easy.\nThe learning algorithms:\n\nLR: logistic regression, sklearn implementation\nLMNB: Laplacian Naive Bayes, NIBR implementation\nNB: Naive Bayes, sklearn implementation. Note that something went wrong with these calculations, so they won’t be included in any summaries.\nRF: random forest, sklearn implementation\nBRF: balanced random forest, imbalanced-learn implementation\nXGB: extreme gradient boosting, XGBoost implementation\n\nHere’s a summary of the results using AUC as a metric (there’s a giant table at the bottom with the other metrics). The result column indicates whether the AUC value for the short fingerprint is usually less than (lt), the same as (same), or greater than (gt) the AUC value for the long fingerprint. The P column provides the P value for the difference (assessed using scipy’s Wilcoxon signed-rank test). The delt column has the median difference between the short-fingerprint AUC and long-fingerprint AUC. The pct_delt column indicates the median percentage change in AUC relative to the short-fingerprint AUC.\n\n\n\nalg\nfp\nmetric\nresult\nP\ndelt\npct_delt\n\n\n\n\nlr\nmfp2\nAUC\nlt\n8.68e-51\n-0.011\n-0.0142\n\n\nlr\nmfp3\nAUC\nlt\n2.6e-64\n-0.019\n-0.0243\n\n\nlr\nrdk5\nAUC\nlt\n2.09e-24\n-0.011\n-0.0143\n\n\nlr\nhashap\nAUC\nlt\n8.77e-37\n-0.026\n-0.0325\n\n\nlr\nhashtt\nAUC\nlt\n8.02e-54\n-0.022\n-0.0294\n\n\nlmnb\nmfp2\nAUC\nlt\n3.2e-104\n-0.042\n-0.0573\n\n\nlmnb\nmfp3\nAUC\nlt\n6.05e-107\n-0.077\n-0.109\n\n\nlmnb\nrdk5\nAUC\nlt\n4.32e-60\n-0.071\n-0.193\n\n\nlmnb\nhashap\nAUC\ngt\n1.67e-18\n0.031\n0.0494\n\n\nlmnb\nhashtt\nAUC\nlt\n7.52e-105\n-0.051\n-0.0767\n\n\nrf\nmfp2\nAUC\nlt\n1.45e-102\n-0.087\n-0.132\n\n\nrf\nmfp3\nAUC\nlt\n2.23e-92\n-0.074\n-0.115\n\n\nrf\nrdk5\nAUC\ngt\n4.27e-11\n0.015\n0.0212\n\n\nrf\nhashap\nAUC\nsame\n0.00227\n0.0036\n0.00503\n\n\nrf\nhashtt\nAUC\nlt\n1.25e-63\n-0.046\n-0.0677\n\n\nbrf\nmfp2\nAUC\nlt\n6.61e-37\n-0.024\n-0.0304\n\n\nbrf\nmfp3\nAUC\nlt\n9.25e-40\n-0.031\n-0.04\n\n\nbrf\nrdk5\nAUC\ngt\n2.77e-09\n0.01\n0.0131\n\n\nbrf\nhashap\nAUC\ngt\n5.32e-07\n0.011\n0.0152\n\n\nbrf\nhashtt\nAUC\nlt\n8.45e-29\n-0.027\n-0.0362\n\n\nxgb\nmfp2\nAUC\nsame\n0.831\n0.00097\n0.00109\n\n\nxgb\nmfp3\nAUC\nsame\n0.00162\n-0.0051\n-0.00719\n\n\nxgb\nrdk5\nAUC\ngt\n1.36e-07\n0.012\n0.0157\n\n\nxgb\nhashap\nAUC\ngt\n1.49e-20\n0.027\n0.0358\n\n\nxgb\nhashtt\nAUC\nsame\n0.0265\n-0.0043\n-0.00645\n\n\n\nThe TL;DR from this: for most methods and fingerprints you can get a small, but real improvement in model performance (as measured by AUC) by using the longer fingerprints. There are a few cases, e.g. LMNB+rdk5 and RF+mfp2, where the model built with the longer fingerprint is >10% better. Exceptions to the general rule, which it could be interesting to investigate more deeply, include: - The rdk5 and hashap fingerprints: for this use case it looks like the additional information in the longer fingerprints tends to degrade performance. The “simpler” learning algorithms - lr and lmnb - either don’t show this effect or show it less… a strong suggestion that the problem is overfitting. - XGB doesn’t show improved performance for the longer fingerprint with any of the methods.\nNote that we’ve only looked at one type of data set here - training on reasonably homogeneous active molecules and then testing with diverse actives - so the results could well be different for models built/tested on things like screening data (where both the training and test sets are chemically diverse).\n\nfrom rdkit import Chem\nfrom rdkit.Chem import rdFingerprintGenerator\nimport numpy as np\n\nimport rdkit\nprint(rdkit.__version__)\nimport time\nprint(time.asctime())\n%pylab inline\n\n2022.09.1\nMon Dec 19 20:00:39 2022\n%pylab is deprecated, use %matplotlib inline and import the required libraries.\nPopulating the interactive namespace from numpy and matplotlib"
  },
  {
    "objectID": "posts/2022-12-25-colliding-bits-ii-revisited.html#logistic-regression",
    "href": "posts/2022-12-25-colliding-bits-ii-revisited.html#logistic-regression",
    "title": "Colliding bits II, revisited",
    "section": "Logistic regression",
    "text": "Logistic regression\n\ndo_scatter_plots('lr_mfp2','lr_lmfp2')"
  },
  {
    "objectID": "posts/2022-12-25-colliding-bits-ii-revisited.html#balanced-random-forests",
    "href": "posts/2022-12-25-colliding-bits-ii-revisited.html#balanced-random-forests",
    "title": "Colliding bits II, revisited",
    "section": "Balanced random forests",
    "text": "Balanced random forests\n\ndo_scatter_plots('brf_mfp2','brf_lmfp2')"
  },
  {
    "objectID": "posts/2022-12-25-colliding-bits-ii-revisited.html#random-forests",
    "href": "posts/2022-12-25-colliding-bits-ii-revisited.html#random-forests",
    "title": "Colliding bits II, revisited",
    "section": "Random forests",
    "text": "Random forests\n\ndo_scatter_plots('rf_mfp2','rf_lmfp2')"
  },
  {
    "objectID": "posts/2022-12-25-colliding-bits-ii-revisited.html#xgboost",
    "href": "posts/2022-12-25-colliding-bits-ii-revisited.html#xgboost",
    "title": "Colliding bits II, revisited",
    "section": "XGBoost",
    "text": "XGBoost\n\ndo_scatter_plots('xgb_mfp2','xgb_lmfp2')"
  },
  {
    "objectID": "posts/2022-12-25-colliding-bits-ii-revisited.html#laplacian-naive-bayes",
    "href": "posts/2022-12-25-colliding-bits-ii-revisited.html#laplacian-naive-bayes",
    "title": "Colliding bits II, revisited",
    "section": "Laplacian Naive Bayes",
    "text": "Laplacian Naive Bayes\n\ndo_scatter_plots('lmnb_mfp2_2','lmnb_lmfp2_2')"
  },
  {
    "objectID": "posts/2022-12-25-colliding-bits-ii-revisited.html#naive-bayes",
    "href": "posts/2022-12-25-colliding-bits-ii-revisited.html#naive-bayes",
    "title": "Colliding bits II, revisited",
    "section": "Naive Bayes",
    "text": "Naive Bayes\n\ndo_scatter_plots('nb_mfp2','nb_lmfp2')\n\n\n\n\nSomething isn’t right with the NB results… I need to look into that"
  },
  {
    "objectID": "posts/2022-12-25-colliding-bits-ii-revisited.html#auc",
    "href": "posts/2022-12-25-colliding-bits-ii-revisited.html#auc",
    "title": "Colliding bits II, revisited",
    "section": "AUC",
    "text": "AUC\n\n\n\nalg\nfp\nmetric\nresult\nP\ndelt\npct_delt\n\n\n\n\nlr\nmfp2\nAUC\nlt\n8.68e-51\n-0.011\n-0.0142\n\n\nlr\nmfp3\nAUC\nlt\n2.6e-64\n-0.019\n-0.0243\n\n\nlr\nrdk5\nAUC\nlt\n2.09e-24\n-0.011\n-0.0143\n\n\nlr\nhashap\nAUC\nlt\n8.77e-37\n-0.026\n-0.0325\n\n\nlr\nhashtt\nAUC\nlt\n8.02e-54\n-0.022\n-0.0294\n\n\nlmnb\nmfp2\nAUC\nlt\n3.2e-104\n-0.042\n-0.0573\n\n\nlmnb\nmfp3\nAUC\nlt\n6.05e-107\n-0.077\n-0.109\n\n\nlmnb\nrdk5\nAUC\nlt\n4.32e-60\n-0.071\n-0.193\n\n\nlmnb\nhashap\nAUC\ngt\n1.67e-18\n0.031\n0.0494\n\n\nlmnb\nhashtt\nAUC\nlt\n7.52e-105\n-0.051\n-0.0767\n\n\nrf\nmfp2\nAUC\nlt\n1.45e-102\n-0.087\n-0.132\n\n\nrf\nmfp3\nAUC\nlt\n2.23e-92\n-0.074\n-0.115\n\n\nrf\nrdk5\nAUC\ngt\n4.27e-11\n0.015\n0.0212\n\n\nrf\nhashap\nAUC\nsame\n0.00227\n0.0036\n0.00503\n\n\nrf\nhashtt\nAUC\nlt\n1.25e-63\n-0.046\n-0.0677\n\n\nbrf\nmfp2\nAUC\nlt\n6.61e-37\n-0.024\n-0.0304\n\n\nbrf\nmfp3\nAUC\nlt\n9.25e-40\n-0.031\n-0.04\n\n\nbrf\nrdk5\nAUC\ngt\n2.77e-09\n0.01\n0.0131\n\n\nbrf\nhashap\nAUC\ngt\n5.32e-07\n0.011\n0.0152\n\n\nbrf\nhashtt\nAUC\nlt\n8.45e-29\n-0.027\n-0.0362\n\n\nxgb\nmfp2\nAUC\nsame\n0.831\n0.00097\n0.00109\n\n\nxgb\nmfp3\nAUC\nsame\n0.00162\n-0.0051\n-0.00719\n\n\nxgb\nrdk5\nAUC\ngt\n1.36e-07\n0.012\n0.0157\n\n\nxgb\nhashap\nAUC\ngt\n1.49e-20\n0.027\n0.0358\n\n\nxgb\nhashtt\nAUC\nsame\n0.0265\n-0.0043\n-0.00645"
  },
  {
    "objectID": "posts/2022-12-25-colliding-bits-ii-revisited.html#auprc",
    "href": "posts/2022-12-25-colliding-bits-ii-revisited.html#auprc",
    "title": "Colliding bits II, revisited",
    "section": "AUPRC",
    "text": "AUPRC\n\n\n\nalg\nfp\nmetric\nresult\nP\ndelt\npct_delt\n\n\n\n\nlr\nmfp2\nAUPRC\nlt\n9.58e-55\n-0.0079\n-0.0535\n\n\nlr\nmfp3\nAUPRC\nlt\n1.72e-71\n-0.011\n-0.0758\n\n\nlr\nrdk5\nAUPRC\nlt\n2.93e-38\n-0.0042\n-0.0508\n\n\nlr\nhashap\nAUPRC\nlt\n1.11e-13\n-0.01\n-0.0857\n\n\nlr\nhashtt\nAUPRC\nlt\n2.33e-60\n-0.0091\n-0.102\n\n\nlmnb\nmfp2\nAUPRC\nlt\n9.34e-31\n-0.009\n-0.101\n\n\nlmnb\nmfp3\nAUPRC\nlt\n5.43e-27\n-0.0099\n-0.135\n\n\nlmnb\nrdk5\nAUPRC\ngt\n0.000113\n0.00025\n0.00953\n\n\nlmnb\nhashap\nAUPRC\nlt\n1.02e-18\n-0.0052\n-0.114\n\n\nlmnb\nhashtt\nAUPRC\nlt\n2.39e-17\n-0.0039\n-0.0839\n\n\nrf\nmfp2\nAUPRC\nlt\n3.24e-46\n-0.017\n-0.174\n\n\nrf\nmfp3\nAUPRC\nlt\n3.09e-59\n-0.019\n-0.211\n\n\nrf\nrdk5\nAUPRC\nsame\n0.41\n1.1e-05\n0.000428\n\n\nrf\nhashap\nAUPRC\ngt\n2.54e-05\n0.011\n0.1\n\n\nrf\nhashtt\nAUPRC\nlt\n8.39e-42\n-0.011\n-0.14\n\n\nbrf\nmfp2\nAUPRC\nlt\n1.41e-22\n-0.0086\n-0.0915\n\n\nbrf\nmfp3\nAUPRC\nlt\n4.72e-35\n-0.012\n-0.119\n\n\nbrf\nrdk5\nAUPRC\nsame\n0.455\n-0.00027\n-0.00484\n\n\nbrf\nhashap\nAUPRC\ngt\n0.00023\n0.0058\n0.0642\n\n\nbrf\nhashtt\nAUPRC\nlt\n3.38e-26\n-0.0075\n-0.121\n\n\nxgb\nmfp2\nAUPRC\nlt\n1.34e-12\n-0.0044\n-0.0558\n\n\nxgb\nmfp3\nAUPRC\nlt\n1.74e-25\n-0.0088\n-0.113\n\n\nxgb\nrdk5\nAUPRC\nlt\n1.32e-08\n-0.0034\n-0.0545\n\n\nxgb\nhashap\nAUPRC\nsame\n0.221\n0.008\n0.0872\n\n\nxgb\nhashtt\nAUPRC\nlt\n1.07e-13\n-0.0044\n-0.0792"
  },
  {
    "objectID": "posts/2022-12-25-colliding-bits-ii-revisited.html#ef1",
    "href": "posts/2022-12-25-colliding-bits-ii-revisited.html#ef1",
    "title": "Colliding bits II, revisited",
    "section": "EF1",
    "text": "EF1\n\n\n\nalg\nfp\nmetric\nresult\nP\ndelt\npct_delt\n\n\n\n\nlr\nmfp2\nEF1\nlt\n4.4e-23\n-1\n-0.0357\n\n\nlr\nmfp3\nEF1\nlt\n1.24e-36\n-1\n-0.0625\n\n\nlr\nrdk5\nEF1\nlt\n7.74e-16\n0\n0\n\n\nlr\nhashap\nEF1\nlt\n3.05e-06\n-1\n-0.0556\n\n\nlr\nhashtt\nEF1\nlt\n5.74e-36\n-1\n-0.0833\n\n\nlmnb\nmfp2\nEF1\nlt\n2.32e-74\n-3\n-0.167\n\n\nlmnb\nmfp3\nEF1\nlt\n9.4e-69\n-3\n-0.25\n\n\nlmnb\nrdk5\nEF1\ngt\n1.97e-58\n4\nnan\n\n\nlmnb\nhashap\nEF1\nsame\n0.147\n-1\nnan\n\n\nlmnb\nhashtt\nEF1\nlt\n5.42e-48\n-2\n-0.2\n\n\nrf\nmfp2\nEF1\nlt\n4.12e-11\n-1\n-0.0706\n\n\nrf\nmfp3\nEF1\nlt\n1.94e-14\n-1\n-0.0833\n\n\nrf\nrdk5\nEF1\nsame\n0.0619\n0\n0\n\n\nrf\nhashap\nEF1\ngt\n3.15e-06\n2\n0.1\n\n\nrf\nhashtt\nEF1\nlt\n1.33e-09\n-1\n-0.0476\n\n\nbrf\nmfp2\nEF1\nlt\n2.84e-09\n-1\n-0.0421\n\n\nbrf\nmfp3\nEF1\nlt\n4.46e-13\n-1\n-0.0769\n\n\nbrf\nrdk5\nEF1\nsame\n0.301\n0\nnan\n\n\nbrf\nhashap\nEF1\ngt\n9.93e-09\n1\n0.0779\n\n\nbrf\nhashtt\nEF1\nlt\n7.97e-14\n-1\n-0.0871\n\n\nxgb\nmfp2\nEF1\nlt\n1.06e-14\n-1\n-0.075\n\n\nxgb\nmfp3\nEF1\nlt\n2.22e-17\n-1\n-0.0625\n\n\nxgb\nrdk5\nEF1\nlt\n4.54e-09\n-1\nnan\n\n\nxgb\nhashap\nEF1\nsame\n0.335\n1\n0.0769\n\n\nxgb\nhashtt\nEF1\nlt\n6.27e-09\n0\n0"
  },
  {
    "objectID": "posts/2022-12-25-colliding-bits-ii-revisited.html#ef5",
    "href": "posts/2022-12-25-colliding-bits-ii-revisited.html#ef5",
    "title": "Colliding bits II, revisited",
    "section": "EF5",
    "text": "EF5\n\n\n\nalg\nfp\nmetric\nresult\nP\ndelt\npct_delt\n\n\n\n\nlr\nmfp2\nEF5\nlt\n4.32e-23\n-0.2\n-0.0357\n\n\nlr\nmfp3\nEF5\nlt\n3.64e-38\n-0.4\n-0.0559\n\n\nlr\nrdk5\nEF5\nlt\n8.96e-26\n-0.2\n-0.0469\n\n\nlr\nhashap\nEF5\nlt\n1.42e-08\n-0.2\n-0.0385\n\n\nlr\nhashtt\nEF5\nlt\n6.58e-38\n-0.4\n-0.0769\n\n\nlmnb\nmfp2\nEF5\nlt\n1.44e-82\n-1\n-0.154\n\n\nlmnb\nmfp3\nEF5\nlt\n2.57e-92\n-1.4\n-0.264\n\n\nlmnb\nrdk5\nEF5\nsame\n0.725\n-0.4\nnan\n\n\nlmnb\nhashap\nEF5\nlt\n1.47e-64\n-1\n-0.217\n\n\nlmnb\nhashtt\nEF5\nlt\n6.85e-73\n-0.81\n-0.185\n\n\nrf\nmfp2\nEF5\nlt\n3.72e-39\n-0.61\n-0.118\n\n\nrf\nmfp3\nEF5\nlt\n3.14e-26\n-0.4\n-0.0948\n\n\nrf\nrdk5\nEF5\nsame\n0.988\n0\n0\n\n\nrf\nhashap\nEF5\ngt\n6.9e-14\n0.61\n0.0769\n\n\nrf\nhashtt\nEF5\nlt\n2.61e-19\n-0.4\n-0.0811\n\n\nbrf\nmfp2\nEF5\nlt\n4.02e-16\n-0.4\n-0.0476\n\n\nbrf\nmfp3\nEF5\nlt\n8.91e-25\n-0.6\n-0.0854\n\n\nbrf\nrdk5\nEF5\nsame\n0.319\n0\n0\n\n\nbrf\nhashap\nEF5\ngt\n9.01e-07\n0.4\n0.0674\n\n\nbrf\nhashtt\nEF5\nlt\n1.18e-22\n-0.4\n-0.101\n\n\nxgb\nmfp2\nEF5\nlt\n3.14e-05\n-0.2\n-0.0308\n\n\nxgb\nmfp3\nEF5\nlt\n4.57e-13\n-0.4\n-0.0797\n\n\nxgb\nrdk5\nEF5\nsame\n0.00432\n-0.2\n-0.0354\n\n\nxgb\nhashap\nEF5\ngt\n1.24e-09\n0.61\n0.1\n\n\n\nI am sorely tempted to compare the individual methods and fingerprints to each other as well, but that’s not the point of this post, so I’ll hold that for another time."
  },
  {
    "objectID": "posts/2020-01-21-some-thoughts-on-cartridge-performance.html",
    "href": "posts/2020-01-21-some-thoughts-on-cartridge-performance.html",
    "title": "Some thoughts on the performance of the RDKit cartridge",
    "section": "",
    "text": "EDITED on 23.01.2020 John Mayfield pointed out that the way I had constructed the set of 10 million molecules wasn’t reproducible. This update fixes that, but it also changes the results.\nIt’s been a while since I did a post about the cartridge! This one is a little bit ranty, but hopefully it’s still useful."
  },
  {
    "objectID": "posts/2020-01-21-some-thoughts-on-cartridge-performance.html#sizes-of-the-tables-and-indices",
    "href": "posts/2020-01-21-some-thoughts-on-cartridge-performance.html#sizes-of-the-tables-and-indices",
    "title": "Some thoughts on the performance of the RDKit cartridge",
    "section": "Sizes of the tables and indices",
    "text": "Sizes of the tables and indices\npubchem_compound=# \\d+\n                             List of relations\n Schema |      Name       |   Type   |  Owner   |    Size    | Description \n--------+-----------------+----------+----------+------------+-------------\n public | fps             | table    | glandrum | 964 MB     | \n public | mols            | table    | glandrum | 4236 MB    | \n public | raw_data        | table    | glandrum | 9091 MB    | \n public | raw_data_id_seq | sequence | glandrum | 8192 bytes | \n(4 rows)\npubchem_compound=# \\di+\n                              List of relations\n Schema |     Name      | Type  |  Owner   |  Table   |  Size   | Description \n--------+---------------+-------+----------+----------+---------+-------------\n public | fps_mfp2_idx  | index | glandrum | fps      | 1226 MB | \n public | fps_pkey      | index | glandrum | fps      | 214 MB  | \n public | molidx        | index | glandrum | mols     | 4060 MB | \n public | mols_pkey     | index | glandrum | mols     | 214 MB  | \n public | raw_data_pkey | index | glandrum | raw_data | 2193 MB | \n(5 rows)"
  },
  {
    "objectID": "posts/2020-01-21-some-thoughts-on-cartridge-performance.html#performance-of-the-substructure-indices",
    "href": "posts/2020-01-21-some-thoughts-on-cartridge-performance.html#performance-of-the-substructure-indices",
    "title": "Some thoughts on the performance of the RDKit cartridge",
    "section": "Performance of the substructure indices",
    "text": "Performance of the substructure indices\nHere are results for the substructure queries executed above. For the purposes of this analysis I removed the limit on the query:\npubchem_compound=# explain analyze select * from mols where m@>'CC1=C(C=C(C=C1)C(N)=O)C#CC1=CN=CC=C1';\n                                                        QUERY PLAN                                                         \n---------------------------------------------------------------------------------------------------------------------------\n Bitmap Heap Scan on mols  (cost=2157.91..37897.03 rows=9999 width=398) (actual time=167.546..168.902 rows=1 loops=1)\n   Recheck Cond: (m @> 'Cc1ccc(C(N)=O)cc1C#Cc1cccnc1'::mol)\n   Rows Removed by Index Recheck: 328\n   Heap Blocks: exact=309\n   ->  Bitmap Index Scan on molidx  (cost=0.00..2155.41 rows=9999 width=0) (actual time=137.703..137.703 rows=329 loops=1)\n         Index Cond: (m @> 'Cc1ccc(C(N)=O)cc1C#Cc1cccnc1'::mol)\n Planning Time: 0.119 ms\n Execution Time: 169.178 ms\n(8 rows)\n\npubchem_compound=# explain analyze select * from mols where m@>'CC1=CC2=C(S1)C(=O)NC(C)=N2';\n                                                        QUERY PLAN                                                        \n--------------------------------------------------------------------------------------------------------------------------\n Bitmap Heap Scan on mols  (cost=2157.91..37897.03 rows=9999 width=398) (actual time=436.998..510.558 rows=46 loops=1)\n   Recheck Cond: (m @> 'Cc1nc2cc(C)sc2c(=O)[nH]1'::mol)\n   Rows Removed by Index Recheck: 14\n   Heap Blocks: exact=55\n   ->  Bitmap Index Scan on molidx  (cost=0.00..2155.41 rows=9999 width=0) (actual time=436.902..436.902 rows=60 loops=1)\n         Index Cond: (m @> 'Cc1nc2cc(C)sc2c(=O)[nH]1'::mol)\n Planning Time: 0.113 ms\n Execution Time: 510.801 ms\n(8 rows)\n\n\npubchem_compound=# explain analyze select * from mols where m@>'CN1C(=O)N(C)C2=C1C=NC(N)=N2';\n                                                         QUERY PLAN                                                         \n----------------------------------------------------------------------------------------------------------------------------\n Bitmap Heap Scan on mols  (cost=2157.91..37897.03 rows=9999 width=398) (actual time=5111.590..5113.136 rows=38 loops=1)\n   Recheck Cond: (m @> 'Cn1c(=O)n(C)c2nc(N)ncc21'::mol)\n   Rows Removed by Index Recheck: 10\n   Heap Blocks: exact=48\n   ->  Bitmap Index Scan on molidx  (cost=0.00..2155.41 rows=9999 width=0) (actual time=5081.767..5081.768 rows=48 loops=1)\n         Index Cond: (m @> 'Cn1c(=O)n(C)c2nc(N)ncc21'::mol)\n Planning Time: 0.058 ms\n Execution Time: 5113.296 ms\n(8 rows)\nAll of those show that the index is doing a reasonably good job of pruning compounds - the worst case query (the first one) only ends up trying at 329 substructure queries (instead of 10 million!) to find the 1 actual match."
  },
  {
    "objectID": "posts/2020-01-21-some-thoughts-on-cartridge-performance.html#warming-up-the-disk-cache",
    "href": "posts/2020-01-21-some-thoughts-on-cartridge-performance.html#warming-up-the-disk-cache",
    "title": "Some thoughts on the performance of the RDKit cartridge",
    "section": "Warming up the disk cache",
    "text": "Warming up the disk cache\nThere are tons of ways to do this. Here’s the approach I used for this post:\npubchem_compound=# select cid,mol_murckoscaffold(m) scaff into temporary table scaffs from mols order by cid desc limit 10;\nSELECT 10\npubchem_compound=# select count(*) from mols cross join scaffs where mols.m@>scaffs.scaff;\n count  \n--------\n 178828\n(1 row)\npubchem_compound=# select * into blah from fps order by cid desc limit 10;\nSELECT 10\npubchem_compound=# select count(*) from fps cross join blah where blah.mfp2%fps.mfp2;\n count \n-------\n   401\n(1 row)\nThat takes ~10 minutes to run for me."
  },
  {
    "objectID": "posts/2020-01-21-some-thoughts-on-cartridge-performance.html#doing-the-queries-and-making-the-images",
    "href": "posts/2020-01-21-some-thoughts-on-cartridge-performance.html#doing-the-queries-and-making-the-images",
    "title": "Some thoughts on the performance of the RDKit cartridge",
    "section": "Doing the queries and making the images",
    "text": "Doing the queries and making the images\nSince I’m not doing this one from a jupyter notebook, here’s the code snippet I’m using in jupyter to do the substructure queries and display the results:\nq='CN1C(=O)N(C)C2=C1C=NC(N)=N2'\nt1=time.time()\nd = %sql postgresql://localhost/pubchem_compound select * from mols where m@>:q limit 10;\nt2 = time.time()\nprint(f'{t2-t1:.2f} seconds')\nms = [Chem.MolFromSmiles(x) for x in [q]+[x[1] for x in d]]\nls = ['query']+[str(x[0]) for x in d]\nDraw.MolsToGridImage(ms[:8],legends=ls,molsPerRow=4)\nAnd the equivalent thing for nearest-neighbor queries:\nq='CN1CC2=NN=C(C3CCC(CC3)OC3=CC=CC=N3)N2C2=CC=C(Cl)C=C2C1'\nt1=time.time()\nd = %sql postgresql://localhost/pubchem_compound select * from get_mfp2_neighbors2(:q) limit 10;\nt2 = time.time()\nprint(f'{t2-t1:.2f} seconds')\nms = [Chem.MolFromSmiles(x) for x in [q]+[x[1] for x in d]]\nls = ['query']+[f'{x[0]} {x[2] :.2f}' for x in d]\nDraw.MolsToGridImage(ms[:8],legends=ls,molsPerRow=4)\nBoth of these are using the fantastic sql-magic for jupyter from Catherine Devlin."
  },
  {
    "objectID": "posts/2023-01-09-rgd-tutorial.html",
    "href": "posts/2023-01-09-rgd-tutorial.html",
    "title": "R-Group Decomposition Tutorial",
    "section": "",
    "text": "R-group decomposition (RGD) is a standard approach for analyzing chemical datasets and doing SAR analysis. Of course the RDKit provides code supporting RGD. Since there are a lot of different RGD use cases, and it turns out that doing R-group decomposition and providing useful results on arbitrary datasets is considerably more complicated than it may initially seem, the RDKit’s RGD implementation needs to be quite flexible (and the implementation is fairly complex). Unfortunately the code is also quite “underdocumented”… this tutorial is a first pass at fixing that. It will eventually end up in the RDKit documentation.\nHere I will demonstrate some of the more useful (in my opinion) options of the RGD code using some real-world datasets. I may revisit this topic at some point in the future to explain some of the more advanced topics. If there are pieces you think I should cover, please let me know in the comments!\nOther RGD-related blog posts:\nYou can also use the rgd tag to find these.\nThe first two datasets I’ll use in this post are created using the SMILES provided in the Supplementary Information from a couple of open-acess J Med Chem papers (Aside: isn’t it great that J. Med. Chem. encourages authors to provide SMILES for the structures in their papers and so many authors actually do so? Isn’t it depressing that the journals which focus on computational topics don’t do so?)."
  },
  {
    "objectID": "posts/2023-01-09-rgd-tutorial.html#working-without-r-labels",
    "href": "posts/2023-01-09-rgd-tutorial.html#working-without-r-labels",
    "title": "R-Group Decomposition Tutorial",
    "section": "Working without R labels",
    "text": "Working without R labels\nIt’s also possible to do RGD by providing a core without labeled R groups:\n\ncore_without_labels = Chem.MolFromSmarts('Cc1nc(=O)c(O)c(C=O)n1')\ncore_without_labels\n\n\n\n\n\ncrgd,fails = rdRGroupDecomposition.RGroupDecompose([core_without_labels],mols,asRows=False)\nprint(len(fails))\nPandasTools.RGroupDecompositionToFrame(crgd,[mols[i] for i in range(len(mols)) if i not in fails],).head()\n\n1\n\n\n[14:15:54] No core matches\n\n\n\n\n\n\n  \n    \n      \n      Mol\n      R1\n      R2\n      R3\n      R4\n    \n  \n  \n    \n      0\n      \n      \n      \n      \n      \n    \n    \n      1\n      \n      \n      \n      \n      \n    \n    \n      2\n      \n      \n      \n      \n      \n    \n    \n      3\n      \n      \n      \n      \n      \n    \n    \n      4\n      \n      \n      \n      \n      \n    \n  \n\n\n\n\nHere the R labels are automatically assigned, but the result is otherwise the same as what we saw above."
  },
  {
    "objectID": "posts/2023-03-02-clustering-conformers.html",
    "href": "posts/2023-03-02-clustering-conformers.html",
    "title": "Clustering conformers",
    "section": "",
    "text": "This one came up during a conversation with Felix Pultar, a postdoc in the group, and I thought it made for a nice blog post, so here we go.\nOne common workflow in conformational analysis is to generate a bunch of conformers for a molecule and then find a representative subset by clustering them.\nThe RDKit has everything required to do this, but there’s not all that much info out there showing how to do it.\nThis blog post aims to change that.\n\nfrom rdkit.Chem import Draw\nfrom rdkit.Chem.Draw import IPythonConsole\nfrom rdkit import Chem\nfrom rdkit.Chem import rdDistGeom\nfrom rdkit.Chem import rdMolAlign\nimport rdkit\nprint(rdkit.__version__)\n\n2022.09.4\n\n\n\nGenerate conformers\nStart by constructing a molecule and then generating a set of 300 conformers for it using ETKDGv3.\n\n# modified CHEMBL12747, ionized\nm = Chem.MolFromSmiles('O=C([O-])CCn1c(=O)c(=O)[nH]c2cc([N+](=O)[O-])c(-n3ccc(C=NOCc4ccccc4)c3)cc21')\nm\n\n\n\n\n\nmh = Chem.AddHs(m)\nps = rdDistGeom.ETKDGv3()\nps.randomSeed = 0xd06f00d\nps.numThreads = 10\ncids = rdDistGeom.EmbedMultipleConfs(mh,300,ps)\nlen(cids)\n\n300\n\n\nRemove Hs from the molecule at this point because they aren’t particularly informative for the rest of the analysis and they just make things more difficult\n\nm3d = Chem.RemoveHs(mh)\n\n\n\nDirect alignment vs best alignment\nFind a pair of conformers with a decent size mismatch between the direct alignment (which does not take symmetry into account) and the best alignment (which does):\n\nmaxd = -100\nfor j in range(0,5):\n    for i in range(j,len(cids)):\n        d1 = rdMolAlign.AlignMol(m3d,m3d,prbCid=cids[i],refCid=cids[j])\n        d2 = rdMolAlign.GetBestRMS(m3d,m3d,prbId=cids[i],refId=cids[j])\n        delt = d1-d2\n        if delt<-1e-5:\n            print(f'ooops, {i}, {delt}')\n        if delt>maxd:\n            maxd = delt\n            maxi = i\n            maxj = j\nd1 = rdMolAlign.AlignMol(m3d,m3d,prbCid=cids[maxi],refCid=cids[maxj])\nd2 = rdMolAlign.GetBestRMS(m3d,m3d,prbId=cids[maxi],refId=cids[maxj])\nprint(maxi,maxd,d1,d2)\n\n282 0.703433090406554 1.0038182177331938 0.3003851273604343\n\n\nNow show those two conformers:\n\nimport py3Dmol\ndef drawit(m, cids=[-1], p=None, removeHs=True,\n           colors=('cyanCarbon','redCarbon','blueCarbon','magentaCarbon','whiteCarbon','purpleCarbon')):\n        if removeHs:\n            m = Chem.RemoveHs(m)\n        if p is None:\n            p = py3Dmol.view(width=400, height=400)\n        p.removeAllModels()\n        for i,cid in enumerate(cids):\n            IPythonConsole.addMolToView(m,p,confId=cid)\n        for i,cid in enumerate(cids):\n            p.setStyle({'model':i,},\n                            {'stick':{'colorscheme':colors[i%len(colors)]}})\n        p.zoomTo()\n        return p.show()\n\nHere are the two conformers aligned using the atom indices:\n\nd1 = rdMolAlign.AlignMol(m3d,m3d,prbCid=cids[maxi],refCid=cids[maxj])\ndrawit(m3d,[cids[maxj],cids[maxi]])\n\n\n        You appear to be running in JupyterLab (or JavaScript failed to load for some other reason).  You need to install the 3dmol extension: \n        jupyter labextension install jupyterlab_3dmol\n        \n\n\n\nAnd then aligned with GetBestRMS:\n\nd2 = rdMolAlign.GetBestRMS(m3d,m3d,prbId=cids[maxi],refId=cids[maxj])\ndrawit(m3d,[cids[maxj],cids[maxi]])\n\n\n        You appear to be running in JupyterLab (or JavaScript failed to load for some other reason).  You need to install the 3dmol extension: \n        jupyter labextension install jupyterlab_3dmol\n        \n\n\n\nThe alignments don’t actually look all that different. The difference in RMSD is due to the atoms in the nitro group and the terminal phenyl ring: GetBestRMS() recognizes that the symmetry while AlignMol() just matches atoms by their indices.\n\n\nCluster Them\nNow generate the RMSD distance matrix using GetBestRMS(). Note that as of the 2022.09 release cycle the convenience function AllChem.GetConformerRMSMatrix() does not take symmetry into account, so we need to build the symmetric matrix (we just store the lower triangle) manually:\n\ndists = []\nfor i in range(len(cids)):\n    for j in range(i):\n        dists.append(rdMolAlign.GetBestRMS(m3d,m3d,i,j))\n\nNow we can do Butina clustering. We use a distance threshold of 1.5 Å:\n\nfrom rdkit.ML.Cluster import Butina\nclusts = Butina.ClusterData(dists, len(cids), 1.5, isDistData=True, reordering=True)\nlen(clusts)\n\n10\n\n\nThat’s it. The 300 conformers form 10 clusters. Let’s visualize the centroids (the first conformer in each cluster)\nTo make visualization of the clusters easier to interpret, align all the conformers to the rigid 6-6 core:\n\nm\n\n\n\n\n\ncore = Chem.MolFromSmiles('O=C1C(=O)N(C)c2cc(N)c(N)cc2N1')\ncore\n\n\n\n\n\nrdMolAlign.AlignMolConformers(m3d,atomIds = m3d.GetSubstructMatch(core))\n\nNow look at the first five cluster centroids;\n\ncentroids = [x[0] for x in clusts]\ndrawit(m3d,centroids[:5])\n\n\n        You appear to be running in JupyterLab (or JavaScript failed to load for some other reason).  You need to install the 3dmol extension: \n        jupyter labextension install jupyterlab_3dmol"
  },
  {
    "objectID": "posts/2020-03-30-setting-up-an-environment.html",
    "href": "posts/2020-03-30-setting-up-an-environment.html",
    "title": "Setting up an environment to make Python contributions to the RDKit",
    "section": "",
    "text": "It has been tricky to contribute code or documentation to the RDKit if you’re a Python programmer who doesn’t want to deal with the complexities of getting an RDKit build working. We want to make it straightforward for people to contribute, so I’m working on some recipes to make thigs easier. This is the first pass at that.\nIn order to fix bugs or add features in Python you need to be able to clone a local fork of the RDKit from github, modify the code in that local clone, and then run the local code in order to test it. The problem is that most RDKit functionality requires some binary components that need to be built from C++ and installed in the appropriate places. We’re going to work around that problem here by copying the binary components from a recent binary distribution of the RDKit into a local clone of the RDKit repo.\nI’m going to explain each of the required steps, but the complete set of steps required is at the bottom of this post. Assuming that you have the prerequisites (explained directly below), I hope that these will “just work” for you, but one never knows… I’d like to be able to include this in the RDKit documentation, so please me know how it goes if you try the recipe out. Please do not add a comment to this blog post, I’ve created a github issue so that we have the comments in one place. If you don’t have a github account, please email me your comments and I’ll add them to the issue.\n\nThe steps explained\nAt the moment this recipe only works on linux and the mac. I will put together a similar recipe for windows and either do a separate post or update this one.\nPrerequisites:\n\nyou need to have either anaconda python or miniconda installed and in your path\nyou need to have git installed and in your path\n\nYou should start by changing into the directory where you want to clone the RDKit source repository and then running:\ngit clone https://github.com/rdkit/rdkit.git\nThat will clone the repo from github into a local directory called rdkit. We now change into that directory and use it to set our RDBASE environment variable:\ncd rdkit\nexport RDBASE=`pwd`\nThe next step is to create the conda environment that we’re going to use to hold the RDKit binary components and install a recent beta version of the RDKit into that environment:\nconda create -y -n py37_rdkit_beta python=3.7\nconda activate py37_rdkit_beta\nconda install -y -c rdkit/label/beta rdkit\nIf you have other Python packages that you’d like to work with, go ahead and install them into the environment now.\nNext we copy the RDKit binary components from that environment into our local clone of the RDKit repo:\ncd $CONDA_PREFIX/lib/python3.7/site-packages/rdkit\nrsync -a -m --include '*/' --include='*.so' --include='inchi.py' --exclude='*' . $RDBASE/rdkit\nNOTE: that rsync command should be one long line.\nFinally we set our PYTHONPATH and then test that everything is working by importing the RDKit’s Chem module:\nexport PYTHONPATH=\"$RDBASE\"\ncd $RDBASE/rdkit\npython -c 'from rdkit import Chem;print(Chem.__file__)'\nThat last command should not generate errors and should show you a filename that is in your local github clone. As an example, I started the first step of this process in my /scratch/rdkit_devel directory, so I see:\n/scratch/rdkit_devel/rdkit/rdkit/Chem/__init__.py\n\n\nRunning the tests\nIf you’re planning on making an RDKit contribution, it’s important to know how to run the Python tests to make sure that your changes work and don’t break anything else. For historic reasons the RDKit uses a self-written framework for running tests, but it’s easy enough to use. You need to run the script $RDBASE/rdkit/TestRunner.py and point it to the test_list.py file containing the tests to be run. For example, if you want to run all the tests in the directory $RDBASE/rdkit/Chem (this corresponds to the python module rdkit.Chem), you would do:\ncd $RDBASE/rdkit/Chem\npython $RDBASE/rdkit/TestRunner.py test_list.py\nThat will take a while and generate a lot of output, including things that look like exceptions and errors, but should finish with something like:\nScript: test_list.py.  Passed 40 tests in 69.70 seconds\n\n\nFinishing up\nYou’re set. The one thing to remember is that whenever you want to use this environment in a new terminal window or shell, you need to activate the py37_rdkit_beta conda environment (don’t delete it!), set RDBASE, and set your PYTHONPATH:\nconda activate py37_rdkit_beta\ncd your_local_rdkit_clone  # <- replace this with the real name of the directory\nexport RDBASE=`pwd`\nexport PYTHONPATH=\"$RDBASE\"\n\n\nThe recipe\nHere’s the complete recipe:\ngit clone https://github.com/rdkit/rdkit.git\ncd rdkit\nexport RDBASE=`pwd`\nconda create -y -n py37_rdkit_beta python=3.7\nconda activate py37_rdkit_beta\nconda install -y -c rdkit/label/beta rdkit\ncd $CONDA_PREFIX/lib/python3.7/site-packages/rdkit\nrsync -a -m --include '*/' --include='*.so' --include='inchi.py' --exclude='*' . $RDBASE/rdkit\nexport PYTHONPATH=\"$RDBASE\"\ncd $RDBASE/rdkit\npython -c 'from rdkit import Chem;print(Chem.__file__)'"
  },
  {
    "objectID": "posts/2022-12-18-introducing-rdDetermineBonds.html",
    "href": "posts/2022-12-18-introducing-rdDetermineBonds.html",
    "title": "Introducing rdDetermineBonds",
    "section": "",
    "text": "One of the problems with using the results from quantum chemical calculations with the RDKit is that typical QM output formats just include atoms and their positions: since the calculations don’t need bond orders, they don’t show up in the output. The problem of assigning correct bond orders to the atoms in a molecule based solely on atomic positions (and the overall charge on the molecule) is a non-trivial one, and we’ve never had a good answer in the RDKit.\nA few years ago Jan Jensen and his group published xyz2mol, an open-source, RDKit-based solution to this problem written in Python: https://github.com/jensengroup/xyz2mol. During this year’s Google Summer of Code, Sreya Gogineni, did a C++ port of the Python code and integrated it into the RDKit core for the 2022.09 release. Here’s the project description and here’s Sreya’s “final report” which is also the PR where we merged her changes into the RDKit core.\nThis post was originally just going to be a quick introduction to how to use that code. However, since I was having fun with it, I went ahead and did some testing on a bunch of 3D structures from QM9.\n\nfrom rdkit import Chem\nfrom rdkit.Chem import Draw\nfrom rdkit.Chem.Draw import IPythonConsole\nIPythonConsole.ipython_3d = True\nimport rdkit\nrdkit.__version__\n\n'2022.09.1'\n\n\n\nUsing rdDetermineBonds\nTo get some testing files, I downloaded some structures from the QM9 dataset. Here’s what those look like:\n\n!cat ../data/dsgdb9nsd_107313.xyz\n\n19\ngdb 107313  2.67642 1.59305 1.14971 3.3443  81.12   -0.2359 -0.0506 0.1853  1106.1507   0.159794    -385.918216 -385.909962 -385.909018 -385.950934 31.892  \nC    0.0645055554    1.4843171326    0.3723315122   -0.379845\nC   -0.001915467     0.0516984051   -0.1729357038   -0.277772\nC   -1.4001624807   -0.5304376801   -0.1487075838    0.233551\nC   -1.9909553844   -1.0379429662    1.1601625215   -0.307513\nC   -1.7182271444   -1.9962888369    0.0152208454   -0.158294\nC   -2.905416575    -2.2627721735   -0.8489696604   -0.065615\nC   -3.3347497536   -1.1525477782   -1.4661914556   -0.191532\nC   -2.4353480328   -0.0114763902   -1.1388331005    0.336742\nO   -2.4853518918    1.1093228549   -1.595794586    -0.340877\nH    1.0876615149    1.8699729825    0.3263064541    0.106173\nH   -0.5836533924    2.142053447    -0.2101812431    0.152698\nH   -0.2626541721    1.5210712578    1.4170099662    0.108877\nH    0.3710335675    0.0343653078   -1.2041622283    0.107526\nH    0.662791197    -0.6008609283    0.4071642198    0.091428\nH   -1.3142481944   -1.0584396879    2.0096409673    0.122076\nH   -3.0252533013   -0.8199288984    1.4038330438    0.125348\nH   -0.9412329872   -2.7436632889    0.1278385726    0.101319\nH   -3.37329736 -3.2394582332   -0.9072563749    0.118603\nH   -4.2004762777   -1.0463782959   -2.1061677066    0.117109\n88.1998 132.6788    204.3282    214.9254    283.2151    320.8425    354.2003    451.4683    471.7609    631.475 661.0085    735.6532    750.9738    778.4916    839.8756    849.5692    876.8931    897.9162    967.6602    980.1789    992.0568    1026.4327   1049.1839   1072.0692   1075.099    1111.0662   1128.3577   1138.5104   1233.4573   1265.5356   1338.63 1352.428    1365.7919   1389.2764   1408.176    1477.5353   1487.9659   1495.4859   1514.6888   1630.2685   1799.8365   3021.0204   3038.158    3057.8354   3101.9102   3122.4464   3138.2864   3177.3129   3193.7776   3214.9261   3232.806\nCCC12CC1C=CC2=O CC[C@]12C[C@H]1C=CC2=O  \nInChI=1S/C8H10O/c1-2-8-5-6(8)3-4-7(8)9/h3-4,6H,2,5H2,1H3    InChI=1S/C8H10O/c1-2-8-5-6(8)3-4-7(8)9/h3-4,6H,2,5H2,1H3/t6-,8+/m1/s1\n\n\nSreya also added an XYZ file format parser to the RDKit, but these files include a bunch of additional information that we need to strip out. Here’s the code for that:\n\n# the XYZ files from QM9 aren't really XYZ... clean them up:\ndef cleanup_qm9_xyz(fname):\n    ind = open(fname).readlines()\n    nAts = int(ind[0])\n    # There are two smiles in the data: the one from GDB and the one assigned from the\n    # 3D coordinates in the QM9 paper using OpenBabel (I think).\n    gdb_smi,relax_smi = ind[-2].split()[:2]\n    ind[1] = '\\n'\n    ind = ind[:nAts+2]\n    for i in range(2,nAts+2):\n        l = ind[i]\n        l = l.split('\\t')\n        l.pop(-1)\n        ind[i] = '\\t'.join(l)+'\\n'\n    ind = ''.join(ind)\n    return ind,gdb_smi,relax_smi\n\n\nind,gdb_smi,relax_smi = cleanup_qm9_xyz('../data/dsgdb9nsd_107313.xyz')\nprint(ind)\n\n19\n\nC    0.0645055554    1.4843171326    0.3723315122\nC   -0.001915467     0.0516984051   -0.1729357038\nC   -1.4001624807   -0.5304376801   -0.1487075838\nC   -1.9909553844   -1.0379429662    1.1601625215\nC   -1.7182271444   -1.9962888369    0.0152208454\nC   -2.905416575    -2.2627721735   -0.8489696604\nC   -3.3347497536   -1.1525477782   -1.4661914556\nC   -2.4353480328   -0.0114763902   -1.1388331005\nO   -2.4853518918    1.1093228549   -1.595794586\nH    1.0876615149    1.8699729825    0.3263064541\nH   -0.5836533924    2.142053447    -0.2101812431\nH   -0.2626541721    1.5210712578    1.4170099662\nH    0.3710335675    0.0343653078   -1.2041622283\nH    0.662791197    -0.6008609283    0.4071642198\nH   -1.3142481944   -1.0584396879    2.0096409673\nH   -3.0252533013   -0.8199288984    1.4038330438\nH   -0.9412329872   -2.7436632889    0.1278385726\nH   -3.37329736 -3.2394582332   -0.9072563749\nH   -4.2004762777   -1.0463782959   -2.1061677066\n\n\n\nAnd now we can construct a molecule:\n\nraw_mol = Chem.MolFromXYZBlock(ind)\nprint(raw_mol.GetNumAtoms(),raw_mol.GetNumBonds())\n\n19 0\n\n\n\nimport py3Dmol\ndef draw_with_spheres(mol):\n    v = py3Dmol.view(width=300,height=300)\n    IPythonConsole.addMolToView(mol,v)\n    v.zoomTo()\n    v.setStyle({'sphere':{'radius':0.3},'stick':{'radius':0.2}});\n    v.show()\n\n\ndraw_with_spheres(raw_mol)\n\n\n        You appear to be running in JupyterLab (or JavaScript failed to load for some other reason).  You need to install the 3dmol extension: \n        jupyter labextension install jupyterlab_3dmol\n        \n\n\n\nOf course that doesn’t yet have bonds. Let’s fix that.\nStart with rdDetermineBonds.DetermineConnectivity(), this uses distances between atoms to determine where there should be bonds, but does not attempt to figure out bond orders.\n\nfrom rdkit.Chem import rdDetermineBonds\nconn_mol = Chem.Mol(raw_mol)\nrdDetermineBonds.DetermineConnectivity(conn_mol)\n\ndraw_with_spheres(conn_mol)\n\n\n        You appear to be running in JupyterLab (or JavaScript failed to load for some other reason).  You need to install the 3dmol extension: \n        jupyter labextension install jupyterlab_3dmol\n        \n\n\n\nNow we can use rdDetermineBonds.DetermineBondOrders() to figure out what the bond orders should be.\nThis requires the overall charge on the molecule (the default value of the charge is zero, so it’s not technically necessary to provide it here, but we do so to be clear):\n\nrdDetermineBonds.DetermineBondOrders(conn_mol,charge=0)\ndraw_with_spheres(conn_mol)\n\n\n        You appear to be running in JupyterLab (or JavaScript failed to load for some other reason).  You need to install the 3dmol extension: \n        jupyter labextension install jupyterlab_3dmol\n        \n\n\n\nWe can do both steps in a single call. This is the easiest way to use the code if you just want to look at the final bond orders:\n\nconn_mol = Chem.Mol(raw_mol)\nrdDetermineBonds.DetermineBonds(conn_mol,charge=0)\ndraw_with_spheres(conn_mol)\n\n\n        You appear to be running in JupyterLab (or JavaScript failed to load for some other reason).  You need to install the 3dmol extension: \n        jupyter labextension install jupyterlab_3dmol\n        \n\n\n\nSee if the SMILES we got agrees with the what QM9 says it should be:\n\ncm = Chem.RemoveHs(conn_mol)\nosmi = Chem.MolToSmiles(cm)\nsmi = Chem.CanonSmiles(relax_smi)\nprint(osmi,smi)\nosmi==smi\n\nCC[C@]12C[C@H]1C=CC2=O CC[C@]12C[C@H]1C=CC2=O\n\n\nTrue\n\n\nYep… that’s all good.\nLet’s do another example:\n\nind,gdb_smi,relax_smi = cleanup_qm9_xyz('../data/dsgdb9nsd_127185.xyz')\nraw_mol = Chem.MolFromXYZBlock(ind)\nconn_mol = Chem.Mol(raw_mol)\nrdDetermineBonds.DetermineBonds(conn_mol,charge=0)\nconn_mol\ndraw_with_spheres(conn_mol)\n\n\n        You appear to be running in JupyterLab (or JavaScript failed to load for some other reason).  You need to install the 3dmol extension: \n        jupyter labextension install jupyterlab_3dmol\n        \n\n\n\nAgain, make sure we got it right:\n\ncm = Chem.RemoveHs(conn_mol)\nosmi = Chem.MolToSmiles(cm)\nsmi = Chem.CanonSmiles(relax_smi)\nprint(osmi,smi)\nosmi==smi\n\nCN(C=O)c1ccon1 CN(C=O)c1ccon1\n\n\nTrue\n\n\nSince this method needs the Hs to be there, it unfortunately won’t be useful in assigning bond orders to the ligands from PDB structures… ah well.\n\n\nTesting the functionality on a bunch of molecules\nHere’s a little test to see how well the new functionality does on a randomly selected subset of QM9.\nStart by getting 10K random files from my local copy of QM9 (these, for obvious reasons, aren’t in the gitub repo for this notebook) and preprocessing them:\n\nimport glob\nimport random\nrandom.seed(0xf00d)\n\nfns = list(glob.glob('/local/QM9/*.xyz'))\nrandom.shuffle(fns)\nfns = fns[:10000]\n\n\nqm9_data = []\nfor fn in fns:\n    d,gdb_smi,relax_smi = cleanup_qm9_xyz(fn)\n    qm9_data.append((fn,d,gdb_smi,relax_smi))\n\nI believe that QM9 doesn’t have double bond stereo indicated in the SMILES, verify that:\n\nhas_dbl_bond_stereo=[]\nfor tpl in qm9_data:\n    smi = tpl[-1]\n    if smi.find('/') != -1 or smi.find('\\\\') != -1:\n        print(tpl)\n\nHere’s the testing code.\nFor each molecule we have two SMILES to compare to: 1. gdb_smi: the SMILES from GDB that the QM9 authors used as input 2. relax_smi: the SMILES generated by OpenBabel(?) from the optimized structure.\nWe’ll start by seeing if we match relax_smi and, if that fails, compare to gdb_smi.\n\nfrom rdkit import RDLogger\nRDLogger.DisableLog('rdApp.*')\nrelax_fails = []\ngdb_fails = []\nfor fn,ind,gdb_smi,relax_smi in qm9_data:\n    # the RDKit can't parse some of the SMILES from QM9... skip those mols\n    try:\n        smi = Chem.CanonSmiles(relax_smi)\n    except:\n        continue\n    mol = Chem.MolFromXYZBlock(ind)\n    if mol is None:\n        print(f'Could not parse {fn}')\n        continue\n    rdDetermineBonds.DetermineBonds(mol,charge=0)\n    # remove double bond stereo:\n    for bond in mol.GetBonds():\n        if bond.GetBondType() == Chem.BondType.DOUBLE:\n            bond.SetStereo(Chem.BondStereo.STEREONONE)\n        elif bond.GetBondType() == Chem.BondType.SINGLE:\n            bond.SetBondDir(Chem.BondDir.NONE)\n    osmi = Chem.MolToSmiles(Chem.RemoveAllHs(mol))\n    # compare to relax_smi:\n    if smi!=osmi:\n        relax_fails.append((fn,smi,osmi))\n        # that failed, so next we are going to compare to gdb_smi;\n        try:\n            smi = Chem.CanonSmiles(gdb_smi)\n        except:\n            continue\n        # the GDB smiles don't have any stereo at all, so get rid of atomic stereo\n        for atom in mol.GetAtoms():\n            atom.SetChiralTag(Chem.ChiralType.CHI_UNSPECIFIED)\n        osmi = Chem.MolToSmiles(Chem.RemoveAllHs(mol))\n        if smi != osmi:\n            gdb_fails.append((fn,smi,osmi))\nRDLogger.EnableLog('rdApp.*')\n\nlen(relax_fails),len(gdb_fails)\n\nCould not parse /local/QM9/dsgdb9nsd_112773.xyz\nCould not parse /local/QM9/dsgdb9nsd_071817.xyz\nCould not parse /local/QM9/dsgdb9nsd_024513.xyz\nCould not parse /local/QM9/dsgdb9nsd_057755.xyz\nCould not parse /local/QM9/dsgdb9nsd_005005.xyz\nCould not parse /local/QM9/dsgdb9nsd_132540.xyz\nCould not parse /local/QM9/dsgdb9nsd_002091.xyz\nCould not parse /local/QM9/dsgdb9nsd_025366.xyz\nCould not parse /local/QM9/dsgdb9nsd_104557.xyz\n\n\n(909, 27)\n\n\n\nrelax_fails[0]\n\n('/local/QM9/dsgdb9nsd_130414.xyz', '[NH][C]1C=NOC(CN)=N1', 'N=c1cnoc(CN)n1')\n\n\n\ngdb_fails[0]\n\n('/local/QM9/dsgdb9nsd_130861.xyz', 'O=Cc1cc(=O)nno1', 'N#N.O=C=CC(=O)C=O')\n\n\nLet’s start by looking at some of the failures based on relax_smi.\nIn the output we have pairs of molecules where the first is constructed from relax_smi and the second is what we perceived\n\nimport os\nfailmols = []\nnms = []\nfor fn,ismi,osmi in relax_fails:\n    im = Chem.MolFromSmiles(ismi)\n    om = Chem.MolFromSmiles(osmi)\n    failmols.append(im)\n    failmols.append(om)\n    nms.append(f'{os.path.basename(fn)} relax_smi')\n    nms.append('rdkit_smi')\nDraw.MolsToGridImage(failmols[:20],molsPerRow=4,legends=nms)        \n\n\n\n\nThose seem to be cases where we’ve assigned a multiple bond while the SMILES in the publication has a single bond with radicals on either side.\nWhat about some of the 27 cases where we haven’t reproduced the input GDB SMILES?\n\nimport os\nfailmols = []\nnms = []\nfor fn,ismi,osmi in gdb_fails:\n    im = Chem.MolFromSmiles(ismi)\n    om = Chem.MolFromSmiles(osmi)\n    failmols.append(im)\n    failmols.append(om)\n    nms.append(f'{os.path.basename(fn)} relax_smi')\n    nms.append('rdkit_smi')\nDraw.MolsToGridImage(failmols[:20],molsPerRow=4,legends=nms)        \n\n\n\n\nLet’s look at a couple of those:\n\nind,gdb_smi,relax_smi = cleanup_qm9_xyz('/local/QM9/dsgdb9nsd_129106.xyz')\nraw_mol = Chem.MolFromXYZBlock(ind)\nconn_mol = Chem.Mol(raw_mol)\nrdDetermineBonds.DetermineBonds(conn_mol,charge=0)\nconn_mol\ndraw_with_spheres(conn_mol)\n\n\n        You appear to be running in JupyterLab (or JavaScript failed to load for some other reason).  You need to install the 3dmol extension: \n        jupyter labextension install jupyterlab_3dmol\n        \n\n\n\n\nind,gdb_smi,relax_smi = cleanup_qm9_xyz('/local/QM9/dsgdb9nsd_133855.xyz')\nraw_mol = Chem.MolFromXYZBlock(ind)\nconn_mol = Chem.Mol(raw_mol)\nrdDetermineBonds.DetermineBonds(conn_mol,charge=0)\nconn_mol\ndraw_with_spheres(conn_mol)\n\n\n        You appear to be running in JupyterLab (or JavaScript failed to load for some other reason).  You need to install the 3dmol extension: \n        jupyter labextension install jupyterlab_3dmol\n        \n\n\n\nThose are clearly cases where the QM optimization has yielded a completely different structure from what they started with.\nI’m sure we’ll end up finding (and fixing) issues once more people start using the code, but I think these results show that the new functionality in rdDetermineBonds works quite well!\n\n\nBenchmarking the code\nThe last question I had, and I will definitely stop after this, is how long it takes to run the code. Let’s check that.\nI just want to time DetermineBonds() part, so let’s construct the molecules in advance:\n\nfrom rdkit import rdBase\nwith rdBase.BlockLogs():\n    tmols = []\n    for fn,ind,gdb_smi,relax_smi in qm9_data:\n        # the RDKit can't parse some of the SMILES from QM9... skip those\n        mol = Chem.MolFromXYZBlock(ind)\n        if mol is None:\n            continue\n        tmols.append(mol)\nlen(tmols)\n\n9991\n\n\n\n%timeit [rdDetermineBonds.DetermineBonds(m,charge=0) for m in tmols]\n\n646 ms ± 2.95 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)\n\n\nWe can do almost 10K molecules in 646 ms, that’s about 65 μs per molecule. So running DetermineBonds() shouldn’t be a bottleneck in any workflows. :-)"
  },
  {
    "objectID": "posts/2021-12-15-single-molecule-reactions.html",
    "href": "posts/2021-12-15-single-molecule-reactions.html",
    "title": "Using single-molecule reactions",
    "section": "",
    "text": "This short post was inspired by a recent question on the RDKit-discuss mailing list: https://www.mail-archive.com/rdkit-discuss@lists.sourceforge.net/msg10905.html\nThe idea is to provide a quick introduction to a piece of chemical reaction functionality which was added to the 2021.09 RDKit release.\n\nfrom rdkit import Chem\nfrom rdkit.Chem import rdChemReactions\nfrom rdkit.Chem.Draw import IPythonConsole\nfrom rdkit.Chem import Draw\nimport rdkit\nprint(rdkit.__version__)\n\n2021.09.3\n\n\nThis was the molecule that Lewis asked about.\n\nm1 = Chem.MolFromSmiles('COC(=O)C1=C(C=CC=C1)C1=CC=C(C[N+]#[N]=[N-])C=C1',sanitize=False)\nm1\n\n\n\n\nThe RDKit won’t accept this with default settings because there’s an odd representation of an azide group which includes a five-valent neutral nitrogen.\nIt’s straight forward to define a reaction which can convert this odd azide form to the more normal variant:\n\ntf1 = rdChemReactions.ReactionFromSmarts('[#6:1]-[N+:2]#[N:3]=[N-:4]>>[#6:1]-[N+0:2]=[N+1:3]=[N-:4]')\ntf1\n\n\n\n\nThe usual way to use this would be with the RunReactants() method, which returns a list of lists of new molecules. In this case though, we have a reaction which operates on a single reactant and has a single product, so we can take advantage of the new RunReactantInPlace() method.\nAs the method name implies, this modifies the reactant molecule in place instead of creating new molecules which are returned as products:\n\ntf1.RunReactantInPlace(m1)\n\n# now sanitize the molecule so that we do chemistry perception and can get decent drawings:\nChem.SanitizeMol(m1)\nm1\n\n\n\n\nIt’s important to note that his only modifies one match at a time, so if we have multiple functional groups which need to be modified, we’ll need to call RunReactantInPlace() multiple times.\nHere’s a demonstration of that using a molecule which has two of these weird azide constructions\n\nm1 = Chem.MolFromSmiles('c1cc([N+]#[N]=[N-])ccc1[N+]#[N]=[N-]',sanitize=False)\nm1\n\n\n\n\nThe first application of RunReactantInPlace() changes one of the groups:\n\ntf1.RunReactantInPlace(m1)\nm1\n\n\n\n\nIf we call RunReactantInPlace() again, the second occurance is replaced:\n\ntf1.RunReactantInPlace(m1)\nm1\n\n\n\n\nRunReactantInPlace() makes it easy to know when to stop because it returns a boolean letting you know whether or not the molecule was modified. So in this case we’ll get false:\n\ntf1.RunReactantInPlace(m1)\n\nFalse\n\n\nThis makes it easy to do all the transformations to a molecule with a while loop:\n\nm1 = Chem.MolFromSmiles('c1cc([N+]#[N]=[N-])ccc1[N+]#[N]=[N-]',sanitize=False)\nwhile tf1.RunReactantInPlace(m1):\n    pass\nChem.SanitizeMol(m1)\nm1\n\n\n\n\nRunReactantInPlace() is limited, it can only be used with reactions which only have one reactant and product and which do not add atoms in the product.\n\ntf2 = rdChemReactions.ReactionFromSmarts('[#6:1]-[NH2:2]>>[#6:1]-[NH2:2]C')\ntmp = Chem.MolFromSmiles('CCN')\ntf2.RunReactantInPlace(tmp)\n\nValueError: ChemicalParserException: single component reactions which add atoms in the product are not supported\n\n\nNote that it can be used with reactions which remove atoms:\n\ntf2 = rdChemReactions.ReactionFromSmarts('[#6:1]-[NH2:2]>>[#6:1]')\ntmp = Chem.MolFromSmiles('CCN')\ntf2.RunReactantInPlace(tmp)\n\nTrue\n\n\n\ntmp\n\n\n\n\nAside from being easier to use when working with this simple transformations, it’s worth pointing out that RunReactantInPlace() is significantly faster than using RunReactants() with the same reaction:\n\nm1 = Chem.MolFromSmiles('COC(=O)C1=C(C=CC=C1)C1=CC=C(C[N+]#[N]=[N-])C=C1',sanitize=False)\n%timeit tf1.RunReactantInPlace(Chem.Mol(m1))\n\n9.93 µs ± 125 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)\n\n\n\nm1 = Chem.MolFromSmiles('COC(=O)C1=C(C=CC=C1)C1=CC=C(C[N+]#[N]=[N-])C=C1',sanitize=False)\n%timeit tf1.RunReactants((Chem.Mol(m1),))\n\n22.6 µs ± 81.2 ns per loop (mean ± std. dev. of 7 runs, 10000 loops each)"
  },
  {
    "objectID": "posts/2023-01-18-fingerprint-generator-tutorial.html",
    "href": "posts/2023-01-18-fingerprint-generator-tutorial.html",
    "title": "FingerprintGenerator tutorial",
    "section": "",
    "text": "The RDKit supports a number of different fingerprinting algorithms and fingerprint types. For historical reasons (i.e. “bad decisions made a long time ago”) these are accessed via an inconsistent and confusing set of function names. Boran Adas, a student doing a Google Summer of Code project back in 2018, added a new API with a consistent interface for a number of the fingerprint types. I’ve mentioned this a few times and used it in some blog posts, but it has remained “underdocumented”. This blog post is an attempt to remedy that. Some of this content will end up in a future version of the RDKit docs.\nStart by getting some molecules to work with"
  },
  {
    "objectID": "posts/2023-01-18-fingerprint-generator-tutorial.html#count-simulation",
    "href": "posts/2023-01-18-fingerprint-generator-tutorial.html#count-simulation",
    "title": "FingerprintGenerator tutorial",
    "section": "Count simulation",
    "text": "Count simulation\nIt’s possible to simulate count-based fingerprints using bit vector fingerprints. I’ve discussed this in another blog post and there’s a description in the section of the RDKit book about atom pair and topological torsion fingerprints, so I won’t get into heavy detail here.\nThe fingerprint generators allow you to use count simulation for every fingerprint algorithm. It’s enabled by default for atom pairs and topological torsions, but you can also use it with the other fingerprints by using the keyword argument countSimulation=True when constructing the fingerprints\nHere’s a quick demo of the impact that has with the Morgan fingerprint for the set of molecules we loaded here.\n\nfrom rdkit import DataStructs\nfpgen = rdFingerprintGenerator.GetMorganGenerator(radius=2,fpSize=1024)\n# for a direct comparison we need to use a fingerprint 4 times as long:\nsimfpgen = rdFingerprintGenerator.GetMorganGenerator(radius=2,fpSize=4096,countSimulation=True)\nfps = [fpgen.GetFingerprint(m) for m in ms]\ncountfps = [fpgen.GetCountFingerprint(m) for m in ms]\nsimfps = [simfpgen.GetFingerprint(m) for m in ms]\n\ncountsims = []\nsims = []\nsimsims = []\nfor i in range(len(ms)//2):\n    for j in range(i+i,len(ms)//2):\n        countsims.extend(DataStructs.BulkTanimotoSimilarity(countfps[i],countfps[j:]))\n        sims.extend(DataStructs.BulkTanimotoSimilarity(fps[i],fps[j:]))\n        simsims.extend(DataStructs.BulkTanimotoSimilarity(simfps[i],simfps[j:]))\n\n\nfrom scipy import stats\n\n\nbvr,_ = stats.spearmanr(countsims,sims)\nsimr,_ = stats.spearmanr(countsims,simsims)\nprint(bvr,simr)\n\n0.8353509796090909 0.9430970250118949\n\n\n\nfigsize(12,6)\nsubplot(1,2,1)\nhexbin(countsims,sims,bins='log')\nplot((0,1),(0,1),'k-')\ntitle(f'bit vector similarity, r={bvr:.2f}')\nxlabel('count similarity')\nsubplot(1,2,2)\nhexbin(countsims,simsims,bins='log')\nplot((0,1),(0,1),'k-')\ntitle(f'simulated counts similarity, r={simr:.2f}')\nxlabel('count similarity');\n\n\n\n\n\nYou can see that, in general, the count simulation results in closer similarity values."
  },
  {
    "objectID": "posts/2023-01-18-fingerprint-generator-tutorial.html#rooted-fingerprints",
    "href": "posts/2023-01-18-fingerprint-generator-tutorial.html#rooted-fingerprints",
    "title": "FingerprintGenerator tutorial",
    "section": "“Rooted” fingerprints",
    "text": "“Rooted” fingerprints\nIt’s often useful to generate fingerprints which only include bits from particular atoms. We can easily do this with the fingerprint generators\n\nfrom rdkit.Chem import Draw\nopts = Draw.MolDrawOptions()\nopts.addAtomIndices = True\nDraw.MolToImage(ibuprofen,size=(350,300),options=opts)\n\n\n\n\n\n# define a query which returns the C atom from a carboxyl group:\ncarboxyl = Chem.MolFromSmarts('[$(C(=O)[OH,O-])]')\nmatches = [x[0] for x in ibuprofen.GetSubstructMatches(carboxyl)]\nmatches\n\n[12]\n\n\n\nttgen = rdFingerprintGenerator.GetTopologicalTorsionGenerator()\n\nao = rdFingerprintGenerator.AdditionalOutput()\nao.AllocateBitPaths()\n\nfp = ttgen.GetSparseCountFingerprint(ibuprofen,fromAtoms=matches,additionalOutput=ao)\nao.GetBitPaths()\n\n{5645816361: ((6, 7, 10, 12), (8, 7, 10, 12))}\n\n\nWe can do the same thing with RDKit fingerprints, but since those involve bond indices, we need to see the those:\n\nfrom rdkit.Chem import Draw\nopts = Draw.MolDrawOptions()\nopts.addBondIndices = True\nDraw.MolToImage(ibuprofen,size=(350,300),options=opts)\n\n\n\n\n\nrdkgen = rdFingerprintGenerator.GetRDKitFPGenerator(maxPath=3, # <- max of 3 bonds in the subgraph\n                                                    numBitsPerFeature=1) # <- only set one bit per subgraph (the default is 2)\n\nao = rdFingerprintGenerator.AdditionalOutput()\nao.AllocateBitPaths()\n\nfp = rdkgen.GetSparseCountFingerprint(ibuprofen,fromAtoms=matches,additionalOutput=ao)\nao.GetBitPaths()\n\n{733740352: ((11, 9, 7), (11, 9, 6)),\n 1444346785: ((12, 13),),\n 1461736417: ((11, 12),),\n 1480085840: ((11, 12, 10),),\n 1524090560: ((11, 13),),\n 1728147184: ((11, 13, 12),),\n 1940446997: ((11, 10),),\n 2001612136: ((11, 9),),\n 2172716083: ((12,),),\n 2821383998: ((11, 13, 9),),\n 3146241850: ((11, 10, 9),),\n 3508377372: ((11, 12, 9),),\n 3977409745: ((11, 13, 10),),\n 4274652475: ((13,),),\n 4275705116: ((11,),)}\n\n\nSince the RDKit fingerprint can include branched subgraphs (not just linear paths like topological torsions), there’s no concept of a “start” or “central” atom, so we get all subgraphs which include bonds involving the carboxyl C - in this case bonds 11, 12, and 13\nIn both of the examples above I used GetSparseCountFingerprint(), but the fromAtoms argument works with all of the fingerprint generation functions."
  },
  {
    "objectID": "posts/2023-01-18-fingerprint-generator-tutorial.html#working-with-numpy",
    "href": "posts/2023-01-18-fingerprint-generator-tutorial.html#working-with-numpy",
    "title": "FingerprintGenerator tutorial",
    "section": "Working with numpy",
    "text": "Working with numpy\nIf you’re generating fingerprints and it would be useful to have them represented as numpy arrays (for example, if you’re using the FPs with scikit-learn), there are two convenience functions for directly getting numpy arrays from the fingerprint generators:\n\nimport numpy as np\n\nnp_bits = rdkgen.GetFingerprintAsNumPy(ibuprofen)\nnp_bits\n\narray([0, 0, 0, ..., 0, 0, 0], dtype=uint8)\n\n\n\nnp_counts = rdkgen.GetCountFingerprintAsNumPy(ibuprofen)\nnp_counts\n\narray([0, 0, 0, ..., 0, 0, 0], dtype=uint32)\n\n\nthose arrays are each as long as the generator’s fingerprint size (2048 by default):\n\nprint(np_bits.size)\nprint(np_counts.size)\n\n2048\n2048"
  },
  {
    "objectID": "posts/2023-01-18-fingerprint-generator-tutorial.html#saving-info-about-the-fingerprints",
    "href": "posts/2023-01-18-fingerprint-generator-tutorial.html#saving-info-about-the-fingerprints",
    "title": "FingerprintGenerator tutorial",
    "section": "Saving info about the fingerprints",
    "text": "Saving info about the fingerprints\nThe fingerprint generators also provide a simple way to get a text string describing the parameters used to generate fingerprints: the GetInfoString() method:\n\nfpg = rdFingerprintGenerator.GetMorganGenerator(radius=2,fpSize=2048)\nfpg.GetInfoString()\n\n'Common arguments : countSimulation=0 fpSize=2048 bitsPerFeature=1 includeChirality=0 --- MorganArguments onlyNonzeroInvariants=0 radius=2 --- MorganEnvironmentGenerator --- MorganInvariantGenerator includeRingMembership=1 --- MorganInvariantGenerator useBondTypes=1 useChirality=0'\n\n\n\nfpg = rdFingerprintGenerator.GetRDKitFPGenerator()\nfpg.GetInfoString()\n\n'Common arguments : countSimulation=0 fpSize=2048 bitsPerFeature=2 includeChirality=0 --- RDKitFPArguments minPath=1 maxPath=7 useHs=1 branchedPaths=1 useBondOrder=1 --- RDKitFPEnvGenerator --- RDKitFPAtomInvGenerator --- No bond invariants generator'"
  },
  {
    "objectID": "posts/2021-05-13-intro-to-the-molecule-enumerator.html",
    "href": "posts/2021-05-13-intro-to-the-molecule-enumerator.html",
    "title": "Intro to the molecule enumerator",
    "section": "",
    "text": "The V3000 mol file format allows a number of interesting and useful advanced query features. Here I’ll look at two of them: position variation bonds (a.k.a. variable attachment points) and link nodes.\nThis blog post uses features from the 2021.03.1 RDKit release; some of this will not work with older releases.\n\nfrom rdkit import Chem\nfrom rdkit.Chem.Draw import rdDepictor\nfrom rdkit.Chem import Draw\nfrom rdkit.Chem.Draw import IPythonConsole\nfrom rdkit.Chem import rdMolEnumerator\nimport rdkit\nprint(rdkit.__version__)\n\n2021.03.1\n\n\n\nPosition variation bonds\nHere’s a molecule with a position variation bond:\n\npv1 = Chem.MolFromMolBlock('''\n  Mrv2007 06232015292D          \n\n  0  0  0     0  0            999 V3000\nM  V30 BEGIN CTAB\nM  V30 COUNTS 9 8 0 0 0\nM  V30 BEGIN ATOM\nM  V30 1 C -1.7083 2.415 0 0\nM  V30 2 C -3.042 1.645 0 0\nM  V30 3 C -3.042 0.105 0 0\nM  V30 4 N -1.7083 -0.665 0 0\nM  V30 5 C -0.3747 0.105 0 0\nM  V30 6 C -0.3747 1.645 0 0\nM  V30 7 * -0.8192 1.3883 0 0\nM  V30 8 O -0.8192 3.6983 0 0\nM  V30 9 C 0.5145 4.4683 0 0\nM  V30 END ATOM\nM  V30 BEGIN BOND\nM  V30 1 1 1 2\nM  V30 2 2 2 3\nM  V30 3 1 3 4\nM  V30 4 2 4 5\nM  V30 5 1 5 6\nM  V30 6 2 1 6\nM  V30 7 1 7 8 ENDPTS=(3 1 5 6) ATTACH=ANY\nM  V30 8 1 8 9\nM  V30 END BOND\nM  V30 END CTAB\nM  END''')\npv1\n\n\n\n\nThe query is describing a molecule consisting of a pyriding ring with an methoxy substituted either ortho, meta, or para to the N atom.\nThe RDKit includes functionality in the rdkit.Chem.rdMolEnumerator module which allows you enumerate all of the molecules which are described by this query.\nThe function rdMolEnumerator.Enumerate() is straightforward to use: given a molecule with supported query features it returns a MolBundle object which includes each possible expansion of the query:\n\npv1_bundle = rdMolEnumerator.Enumerate(pv1)\npv1_bundle\n\n<rdkit.Chem.rdchem.MolBundle at 0x7fc138399b20>\n\n\nWe can render the molecules in the bundle using Draw.MolsToGridImage():\n\nDraw.MolsToGridImage(pv1_bundle)\n\n\n\n\nThese are pretty ugly since the enumeration hasn’t generated new coordinates for the atom which correspond to the new connectivity.\nI’ll use this convenience function to find the common core shared by the molecules in a bundle and generate 2D coordinates for all the molecules with the core oriented consistently:\n\nfrom rdkit.Chem import rdFMCS\ndef align_bundle_coords(bndl):\n    ps = rdFMCS.MCSParameters()\n    for m in bndl:\n        Chem.SanitizeMol(m)\n    mcs = rdFMCS.FindMCS(bndl,completeRingsOnly=True)\n    q = Chem.MolFromSmarts(mcs.smartsString)\n    rdDepictor.Compute2DCoords(q)\n    for m in bndl:\n        rdDepictor.GenerateDepictionMatching2DStructure(m,q)\n\nNow let’s apply that to our bundle:\n\npv1_bundle = rdMolEnumerator.Enumerate(pv1)\nalign_bundle_coords(pv1_bundle)\nDraw.MolsToGridImage(pv1_bundle)\n\n\n\n\nOf course a molecule can have more than one position variation bond:\n\npv2 = Chem.MolFromMolBlock('''\n  Mrv2007 06242006032D          \n\n  0  0  0     0  0            999 V3000\nM  V30 BEGIN CTAB\nM  V30 COUNTS 10 8 0 0 0\nM  V30 BEGIN ATOM\nM  V30 1 C -1.7083 2.415 0 0\nM  V30 2 C -3.042 1.645 0 0\nM  V30 3 C -3.042 0.105 0 0\nM  V30 4 N -1.7083 -0.665 0 0\nM  V30 5 C -0.3747 0.105 0 0\nM  V30 6 C -0.3747 1.645 0 0\nM  V30 7 * -3.042 0.875 0 0\nM  V30 8 F -5.0434 0.875 0 0\nM  V30 9 * -1.0415 2.03 0 0\nM  V30 10 Cl -1.0415 4.34 0 0\nM  V30 END ATOM\nM  V30 BEGIN BOND\nM  V30 1 1 1 2\nM  V30 2 2 2 3\nM  V30 3 1 3 4\nM  V30 4 2 4 5\nM  V30 5 1 5 6\nM  V30 6 2 1 6\nM  V30 7 1 7 8 ENDPTS=(2 2 3) ATTACH=ANY\nM  V30 8 1 9 10 ENDPTS=(2 1 6) ATTACH=ANY\nM  V30 END BOND\nM  V30 END CTAB\nM  END\n''')\npv2\n\n\n\n\nThis is also supported by the enumerator:\n\npv2_bundle = rdMolEnumerator.Enumerate(pv2)\nalign_bundle_coords(pv2_bundle)\nDraw.MolsToGridImage(pv2_bundle)\n\n\n\n\n\n\nLink nodes\nAnother useful query feature, link nodes, allow you to describe rings of various sizes or chains with different lengths:\n\nlink1 = Chem.MolFromMolBlock('''one linknode\n  Mrv2007 06222005102D          \n\n  0  0  0     0  0            999 V3000\nM  V30 BEGIN CTAB\nM  V30 COUNTS 6 6 0 0 0\nM  V30 BEGIN ATOM\nM  V30 1 C 8.25 12.1847 0 0\nM  V30 2 C 6.9164 12.9547 0 0\nM  V30 3 C 6.9164 14.4947 0 0\nM  V30 4 C 9.5836 14.4947 0 0\nM  V30 5 C 9.5836 12.9547 0 0\nM  V30 6 O 8.25 10.6447 0 0\nM  V30 END ATOM\nM  V30 BEGIN BOND\nM  V30 1 1 1 2\nM  V30 2 1 2 3\nM  V30 3 1 4 5\nM  V30 4 1 1 5\nM  V30 5 1 3 4\nM  V30 6 1 1 6\nM  V30 END BOND\nM  V30 LINKNODE 1 4 2 1 2 1 5\nM  V30 END CTAB\nM  END''')\nlink1\n\n\n\n\nAnd we can enumerate and display these in the same way. Here there’s not much sense in doing the MCS analysis to get the shared coordinates, so I just generate coordinates for the molecules directly:\n\nlink1_bundle = rdMolEnumerator.Enumerate(link1)\nfor m in link1_bundle:\n     Chem.SanitizeMol(m)\n     rdDepictor.Compute2DCoords(m)\nDraw.MolsToGridImage(link1_bundle)\n\n\n\n\n\n\nCombining them\nWe can also combine link nodes and position variation bonds in the same molecule:\n\ncombined = Chem.MolFromMolBlock('''\n  Mrv2108 05132110052D          \n\n  0  0  0     0  0            999 V3000\nM  V30 BEGIN CTAB\nM  V30 COUNTS 19 20 0 0 0\nM  V30 BEGIN ATOM\nM  V30 1 N -2.2078 4.3165 0 0\nM  V30 2 C -2.9544 2.9695 0 0\nM  V30 3 C -2.1612 1.6495 0 0\nM  V30 4 C -0.6214 1.6763 0 0\nM  V30 5 C 0.1252 3.0233 0 0\nM  V30 6 C -0.668 4.3433 0 0\nM  V30 7 C 1.6649 3.0501 0 0\nM  V30 8 C -4.4941 2.9427 0 0\nM  V30 9 C 2.4581 1.7301 0 0\nM  V30 10 C 2.985 3.8433 0 0\nM  V30 11 C 3.7781 2.5233 0 0\nM  V30 12 C -6.3747 4.5774 0 0\nM  V30 13 C -6.9764 3.1598 0 0\nM  V30 14 C -5.8142 2.1495 0 0\nM  V30 15 C -4.8405 4.4431 0 0\nM  V30 16 F -7.1678 5.8974 0 0\nM  V30 17 O 3.3575 5.3376 0 0\nM  V30 18 * -1.1502 2.5564 0 0\nM  V30 19 C -1.1502 0.2464 0 0\nM  V30 END ATOM\nM  V30 BEGIN BOND\nM  V30 1 1 1 2\nM  V30 2 2 2 3\nM  V30 3 1 3 4\nM  V30 4 2 4 5\nM  V30 5 1 5 6\nM  V30 6 2 1 6\nM  V30 7 1 5 7\nM  V30 8 1 2 8\nM  V30 9 1 9 11\nM  V30 10 1 10 11\nM  V30 11 1 7 9\nM  V30 12 1 7 10\nM  V30 13 1 12 13\nM  V30 14 1 13 14\nM  V30 15 1 12 15\nM  V30 16 1 14 8\nM  V30 17 1 8 15\nM  V30 18 1 12 16\nM  V30 19 1 10 17\nM  V30 20 1 18 19 ENDPTS=(3 6 3 4) ATTACH=ANY\nM  V30 END BOND\nM  V30 LINKNODE 1 2 2 10 7 10 11\nM  V30 LINKNODE 1 2 2 12 13 12 15\nM  V30 END CTAB\nM  END\n''')\ncombined\n\n\n\n\nEnumerating that produces 12 molecules:\n\ncombined_bundle = rdMolEnumerator.Enumerate(combined)\nalign_bundle_coords(combined_bundle)\nDraw.MolsToGridImage(combined_bundle,subImgSize=(300,250))\n\n\n\n\n\n\nUsing MolBundles for substructure search\nMolBundles can also be used as substructure search queries.\nHere’s another query molecule:\n\nqry= Chem.MolFromMolBlock('''\n  Mrv2108 05132113572D          \n\n  0  0  0     0  0            999 V3000\nM  V30 BEGIN CTAB\nM  V30 COUNTS 13 13 0 0 0\nM  V30 BEGIN ATOM\nM  V30 1 C 1.2124 -2.4845 0 0\nM  V30 2 N 2.5461 -3.2545 0 0\nM  V30 3 C 2.5461 -4.7945 0 0\nM  V30 4 C 1.2124 -5.5645 0 0\nM  V30 5 C 1.2124 -7.1045 0 0\nM  V30 6 C -0.0335 -8.0097 0 0\nM  V30 7 O 0.4424 -9.4744 0 0\nM  V30 8 C 1.9824 -9.4744 0 0\nM  V30 9 C 2.4583 -8.0097 0 0\nM  V30 10 C -0.1212 -4.7945 0 0\nM  V30 11 C -0.1212 -3.2545 0 0\nM  V30 12 * 0.5456 -2.8695 0 0\nM  V30 13 C -0.6094 -0.869 0 0\nM  V30 END ATOM\nM  V30 BEGIN BOND\nM  V30 1 2 1 2\nM  V30 2 1 2 3\nM  V30 3 2 3 4\nM  V30 4 1 4 5\nM  V30 5 1 6 7\nM  V30 6 1 7 8\nM  V30 7 1 8 9\nM  V30 8 1 5 9\nM  V30 9 1 4 10\nM  V30 10 2 10 11\nM  V30 11 1 1 11\nM  V30 12 1 12 13 ENDPTS=(2 11 1) ATTACH=ANY\nM  V30 13 1 5 6\nM  V30 END BOND\nM  V30 LINKNODE 1 2 2 6 5 6 7\nM  V30 END CTAB\nM  END\n''')\nqry\n\n\n\n\nAnd a set of molecules to search through which I pulled from ChEMBL\n\nsmis = '''Cc1nc(C(C)(C)NC(=O)c2ccc(C3CCOCC3)c(OCC3CC3)n2)no1\n CC(C)(CO)NC(=O)c1ccc(C2CCOC2)c(OCC2CC2)n1\n CC(C)(NC(=O)c1ccc(C2CCOCC2)c(OCC2CC2)n1)c1nccs1\n Cc1c(-c2cncc(C3(O)CCOCC3)c2)cnc2c1CCCN2C(N)=O\n CC(C)Oc1cc(NC(=O)N2CCCc3cc(C4CCOC4)c(C=O)nc32)ncc1C#N\n NC(=O)N1CCCc2cc(-c3cncc(C4(O)CCOC4)c3)cnc21\n CCC(CC)(NC(=O)c1ccc(C2CCOCC2)c(OCC2CC2)n1)C(=O)NC\n CC(C)(NC(=O)c1ccc(C2CCOCC2)c(OCC2CC2)n1)c1ncco1\n N#Cc1cc(-c2ccoc2)c2ccc(OCc3cncc(C4(O)CCOCC4)c3)cc2c1\n Nc1cc(-c2cc(C3CCOCC3)cnc2N)ccc1C(=O)N[C@H](CO)c1ccccc1\n Nc1ncc(C2CCOCC2)cc1-c1ccc(C(=O)NCc2cccnc2)cc1\n Cc1nc(C(C)(C)NC(=O)c2ccc(C3CCOC3)c(OCC3CC3)n2)no1\n CC(C)C[C@H](NC(=O)c1ccc(C2CCOC2)c(OCC2CC2)n1)C(N)=O\n Nc1ncc(C2CCOCC2)cc1-c1ccc(C(=O)N[C@H](CO)c2ccccc2)cc1Cl\n NC(=O)[C@H](CC1CC1)NC(=O)c1ccc(C2CCOC2)c(OCC2CC2)n1\n'''\nmols = [Chem.MolFromSmiles(x.strip()) for x in smis.split('\\n') if x.strip()]\n\nThe query itself doesn’t match most of these molecules:\n\nmatches = [x for x in mols if x.HasSubstructMatch(qry)]\nlen(mols),len(matches)\n\n(15, 6)\n\n\nBut if we enumerate it into a MolBundle and use that as the substructure query then all the molecules match:\n\nqry_bundle = rdMolEnumerator.Enumerate(qry)\nmatches = [x for x in mols if x.HasSubstructMatch(qry_bundle)]\nlen(mols),len(matches)\n\n(15, 15)\n\n\nLet’s look at a few of those matches\n\nmatches = []\nmatched_ats = []\nfor x in mols:\n    match = x.GetSubstructMatch(qry_bundle)\n    if match:\n        matches.append(x)\n        matched_ats.append(match)\nDraw.MolsToGridImage(matches[:6],highlightAtomLists=matched_ats,subImgSize=(300,250))\n\n\n\n\nWe’re working on expanding support for the MolBundle in other RDKit code. For example, it would be really nice to be able to use them directly as queries for the SubstructLibrary\n\n\nFinal bit: input from CXSMILES\nIt’s also possible to read both variable attachment points and link nodes from CXSMILES:\n\nm = Chem.MolFromSmiles('CO*.C1=CC=NC=C1 |c:2,4,6,m:2:3.5.4|')\nm\n\n\n\n\nAs that example shows, the coordinate generation code is currently not great at setting the atom positions for these. That’s a ToDo for a future release.\n\nm = Chem.MolFromSmiles('OC1CCCC1 |LN:1:1.4.2.5|')\nm\n\n\n\n\nThe RDKit currently does not write either link nodes or variable attachment points to CXSMILES, that’s another ToDo for a future release."
  },
  {
    "objectID": "posts/2022-10-28-dealing-with-multiconformer-sd-files.html",
    "href": "posts/2022-10-28-dealing-with-multiconformer-sd-files.html",
    "title": "Dealing with multiconformer SD files",
    "section": "",
    "text": "A recurring question is how to save and share multi-conformer molecules. The easiest (and fastest) way to do this in the RDKit is to just pickle the molecules. It’s not significantly more difficult to use rdMolInterchange.MolToJSON() to serialize the molecules as JSON. Neither of these methods work if you want to work with other tools, so we’re frequently stuck with using something like SD files.\nThe topic came up in the lab today, so I figured I’d do a blog post looking at how to create and work with multi-conformer SD files as well as multi-molecule, multi-conformer SD files with the RDKit. Memo to myself: some of this should probably also end up in the Cookbook.\n\nfrom rdkit import Chem\nfrom rdkit.Chem import Draw\nfrom rdkit.Chem import rdDepictor\nrdDepictor.SetPreferCoordGen(True)\n\nimport rdkit\nprint(rdkit.__version__)\n\n2022.03.5\n\n\nStart by generating conformers for doravirine, lenalidomide, and mutanobactin:\n\ndorav = Chem.MolFromSmiles('Cn1c(n[nH]c1=O)Cn2ccc(c(c2=O)Oc3cc(cc(c3)Cl)C#N)C(F)(F)F')\nlenal = Chem.MolFromSmiles('O=C1NC(=O)CCC1N3C(=O)c2cccc(c2C3)N')\nmutanob = Chem.MolFromSmiles('CCCCCCCCCC(=O)[C@@H]1[C@@H]2CNC(=O)[C@H](CS2)NC(=O)[C@@H](NC(=O)[C@@H]3CCCN3C(=O)[C@H](NC(=O)[C@@H](NC1=O)CC(C)C)C)C(C)C')\n\nDraw.MolsToGridImage([dorav,lenal,mutanob],subImgSize=(300,250))\n\n\n\n\n\nfrom rdkit.Chem import rdDistGeom\n\nps = rdDistGeom.ETKDGv3()\nps.randomSeed = 0xf00d\nps.numThreads = 4\nps.pruneRmsThresh = 0.5\n\n\ndorav = Chem.AddHs(dorav)\nlenal = Chem.AddHs(lenal)\nmutanob = Chem.AddHs(mutanob)\n\nd_cids = rdDistGeom.EmbedMultipleConfs(dorav,200,ps)\nl_cids = rdDistGeom.EmbedMultipleConfs(lenal,200,ps)\nm_cids = rdDistGeom.EmbedMultipleConfs(mutanob,200,ps)\n\n\n\nprint(dorav.GetNumConformers(),lenal.GetNumConformers(),mutanob.GetNumConformers())\n\n58 7 200\n\n\nNow let’s start with a digression and quickly demo the two easy ways of storing and retrieving this multi-conformer molecule: pickling and using JSON:\n\nimport pickle\n\npkl = pickle.dumps(dorav)\nnmol = pickle.loads(pkl)\nnmol.GetNumConformers()\n\n58\n\n\n\nfrom rdkit.Chem import rdMolInterchange\nmjs = rdMolInterchange.MolToJSON(dorav)\nnmol = rdMolInterchange.JSONToMols(mjs)[0]\nnmol.GetNumConformers()\n\n58\n\n\nJust out of curiosity let’s see how long those take:\n\n%timeit pickle.dumps(dorav)\n\n162 µs ± 1.33 µs per loop (mean ± std. dev. of 7 runs, 10,000 loops each)\n\n\n\n%timeit pickle.loads(pkl)\n\n175 µs ± 1.44 µs per loop (mean ± std. dev. of 7 runs, 10,000 loops each)\n\n\n\n%timeit rdMolInterchange.MolToJSON(dorav)\n\n646 µs ± 12.7 µs per loop (mean ± std. dev. of 7 runs, 1,000 loops each)\n\n\n\n%timeit rdMolInterchange.JSONToMols(mjs)[0]\n\n252 µs ± 3.5 µs per loop (mean ± std. dev. of 7 runs, 1,000 loops each)\n\n\nWrite those to an SDF “file”\n\nfrom io import StringIO\nsio = StringIO()\nw = Chem.SDWriter(sio)\nfor cid in d_cids:\n    w.write(dorav,confId=cid)\nw.flush()\nsdf = sio.getvalue()\n\n\nsdf[:100]\n\n'\\n     RDKit          3D\\n\\n 40 42  0  0  0  0  0  0  0  0999 V2000\\n   -3.5730   -0.0689    0.9965 C   '\n\n\n\nfrom io import BytesIO\n\nbio = BytesIO(sdf.encode())\nsuppl = Chem.ForwardSDMolSupplier(bio)\n\nref = next(suppl)\nfor mol in suppl:\n    ref.AddConformer(mol.GetConformer(),assignId=True)\n\nprint(ref.GetNumConformers())\n\n58\n\n\nAgain: how long does this take?\n\n%timeit sio=StringIO();w=Chem.SDWriter(sio);[w.write(dorav,confId=cid) for cid in d_cids];w.flush();sdf=sio.getvalue()\n\n9.85 ms ± 213 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)\n\n\n\n%timeit bio=BytesIO(sdf.encode());suppl=Chem.ForwardSDMolSupplier(bio);ref=next(suppl);[ref.AddConformer(m.GetConformer(),assignId=True) for m in suppl]\n\n13.1 ms ± 250 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)\n\n\nOk, that was pretty easy. What about handling SDFs which contain multiple conformers of more than one molecule?\nStart by creating an SDF with all conformers of all three molecules:\n\nfrom io import StringIO\nsio = StringIO()\nw = Chem.SDWriter(sio)\n\nmol = Chem.Mol(dorav)\nmol.SetProp('_Name','doravirine')\nfor cid in d_cids:\n    w.write(mol,confId=cid)\nmol = Chem.Mol(lenal)\nmol.SetProp('_Name','lenalidomide')\nfor cid in l_cids:\n    w.write(mol,confId=cid)\nmol = Chem.Mol(mutanob)\nmol.SetProp('_Name','mutanobactin')\nfor cid in m_cids:\n    w.write(mol,confId=cid)\n\n    \nw.flush()\nmultimol_sdf = sio.getvalue()\n\nAnd here’s a function to return the molecules from a multi-molecule, multi-conformer supplier:\n\ndef mols_from_multimol_multiconf_supplier(supplier,propertyName='_Name'):\n    mol = None\n    for itm in supplier:\n        if itm is None:\n            continue\n        if mol is None:\n            mol = itm\n            refVal = mol.GetProp(propertyName)\n            continue\n        pVal = itm.GetProp(propertyName)\n        if pVal == refVal:\n            mol.AddConformer(itm.GetConformer(),assignId=True)\n        else:\n            # we're done with the last molecule, so let's restart the next one\n            res = mol\n            mol = itm\n            refVal = pVal\n            yield res\n    \n    yield mol\n\nNow try that out:\n\nfrom io import BytesIO\n\nbio = BytesIO(multimol_sdf.encode())\nsuppl = Chem.ForwardSDMolSupplier(bio)\n\nms = [x for x in mols_from_multimol_multiconf_supplier(suppl)]\nprint([m.GetNumConformers() for m in ms])\n\n[58, 7, 200]\n\n\nBy default the function uses the molecule names, but we can use other property names if we want:\n\nfrom io import StringIO\nsio = StringIO()\nw = Chem.SDWriter(sio)\n\nmol = Chem.Mol(dorav)\nmol.SetProp('molecule_id','doravirine')\nfor cid in d_cids:\n    w.write(mol,confId=cid)\nmol = Chem.Mol(lenal)\nmol.SetProp('molecule_id','lenalidomide')\nfor cid in l_cids:\n    w.write(mol,confId=cid)\nmol = Chem.Mol(mutanob)\nmol.SetProp('molecule_id','mutanobactin')\nfor cid in m_cids:\n    w.write(mol,confId=cid)\n\n    \nw.flush()\nmultimol_sdf = sio.getvalue()\n\nbio = BytesIO(multimol_sdf.encode())\nsuppl = Chem.ForwardSDMolSupplier(bio)\n\nms = [x for x in mols_from_multimol_multiconf_supplier(suppl,propertyName='molecule_id')]\nprint([m.GetNumConformers() for m in ms])\n\n[58, 7, 200]"
  },
  {
    "objectID": "posts/2023-02-04-working-with-conformers.html",
    "href": "posts/2023-02-04-working-with-conformers.html",
    "title": "Working with conformers",
    "section": "",
    "text": "The RDKit stores atomic coordinates in Conformer objects which are attached to the corresponding molecules. In this tutorial post we’re going to look in detail at the way conformers are stored and ways to work with them.\nA molecule constructed from SMILES has no conformer information:\nAn aside: when you display a molecule without conformers in Jupyter, a 2D conformer is generated so that there’s something to display:\nBut this conformer is just temporary; the molecule itself is not modified:\nWhen we ask to have 2D coordinates generated, they are added as a conformer:\nAnd that conformer is flagged as not being 3D:\nGenerating a 3D structure also results in a conformer being added to the molecule (by default any existing conformers are cleared):\nMolecules can have more than one conformer attached. This is what happens whenever we ask for multiple conformers to be generated:\nCalling GetConformer() without arguments on a molecule with multiple conformers (as we did above) returns the default conformer. This is also what most RDKit operations that work with conformers do:\nBut functions which use conformer information also generally take an optional confId argument that allows you to change which conformer is used:\nAs an aside: the Is3D flag on conformers is used by the RDKit’s jupyter integration to decide how to show the molecule. We can fool it by marking a 3D conformer as 2D:\nor a 2D conformer as 3D:"
  },
  {
    "objectID": "posts/2023-02-04-working-with-conformers.html#conformer-ids",
    "href": "posts/2023-02-04-working-with-conformers.html#conformer-ids",
    "title": "Working with conformers",
    "section": "Conformer IDs",
    "text": "Conformer IDs\nEach conformer has an ID associated with it:\n\nprint([x.GetId() for x in esomeprazole.GetConformers()])\n\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n\nAnd there’s no guarantee that the IDs are consecutive:\n\ncp = Chem.Mol(esomeprazole)\ncp.RemoveConformer(0)\ncp.RemoveConformer(3)\ncp.RemoveConformer(7)\nprint([x.GetId() for x in cp.GetConformers()])\n\n[1, 2, 4, 5, 6, 8, 9]\n\n\nThe default conformer is just the first one:\n\nesomeprazole.GetConformer().GetId(),cp.GetConformer().GetId()\n\n(0, 1)\n\n\nIf we ask for a conformer Id which doesn’t exist, we get an error\n\ncp.GetConformer(12)\n\nValueError: Bad Conformer Id\n\n\nSo it’s usually better to loop over conformers by using for conf in m.GetConformers() than to do something like for confid in range(m.GetNumConformers())"
  },
  {
    "objectID": "posts/2023-02-04-working-with-conformers.html#getting-atom-positions",
    "href": "posts/2023-02-04-working-with-conformers.html#getting-atom-positions",
    "title": "Working with conformers",
    "section": "Getting atom positions",
    "text": "Getting atom positions\nWe can get the position of an individual atom using the GetAtomPosition() method:\n\nconf = esomeprazole.GetConformer()\npos = conf.GetAtomPosition(0)\npos\n\n<rdkit.Geometry.rdGeometry.Point3D at 0x24549d77940>\n\n\nPoint3D objects have x, y, an z members:\n\npos.x\n\n7.673833423925606\n\n\nWe can also treat them as vectors:\n\npos[0]\n\n7.673833423925606\n\n\nor convert them to a list:\n\nlist(pos)\n\n[7.673833423925606, 1.9026270201484923, 0.7499323617732389]\n\n\nIf you want to work with all of the atom positions at once, you can get the full set of positions as a numeric python array:\n\nconf = esomeprazole.GetConformer()\nconf.GetPositions()\n\narray([[ 7.67383342,  1.90262702,  0.74993236],\n       [ 6.45500303,  1.5863599 ,  1.35650536],\n       [ 5.47994258,  0.87148768,  0.70572686],\n       [ 5.73975972,  0.49700014, -0.60402982],\n       [ 4.78365557, -0.22724183, -1.28080521],\n       [ 3.59642905, -0.54463893, -0.59986585],\n       [ 2.59405829, -1.21382165, -1.03927358],\n       [ 1.57249064, -1.34923356, -0.0664238 ],\n       [ 0.23760111, -2.18813362, -0.61069031],\n       [ 0.81652921, -3.85758446, -0.60953112],\n       [-1.27391039, -2.26700639,  0.09012225],\n       [-2.10815098, -1.11798724,  0.39836845],\n       [-1.98174435, -0.40660263,  1.56568982],\n       [-2.94381966,  0.4469877 ,  1.9742195 ],\n       [-4.10302205,  0.68692145,  1.27699325],\n       [-5.19127878,  1.57733968,  1.7705111 ],\n       [-4.26093798, -0.01014656,  0.07490913],\n       [-5.42572563,  0.23147474, -0.6552053 ],\n       [-5.42087157,  1.29218749, -1.61825447],\n       [-3.29351791, -0.86279333, -0.31409244],\n       [-3.3729589 , -1.58163605, -1.64292335],\n       [ 2.09334884, -0.69551121,  0.96089041],\n       [ 3.32320448, -0.18671147,  0.68892685],\n       [ 4.28153998,  0.53232818,  1.34410496],\n       [ 8.09389757,  0.95596456,  0.26748966],\n       [ 7.65061035,  2.62967184, -0.06019159],\n       [ 8.38623492,  2.21563152,  1.56819868],\n       [ 6.66853902,  0.74454419, -1.13424145],\n       [ 4.89232116, -0.56528193, -2.30134486],\n       [-1.97542789, -3.01240938, -0.43608787],\n       [-1.27389641, -2.83764033,  1.13153208],\n       [-2.83784116,  0.99189563,  2.93071709],\n       [-5.86663733,  0.96082859,  2.44934068],\n       [-5.84018865,  1.83545526,  0.9297767 ],\n       [-4.86235377,  2.50117065,  2.2287445 ],\n       [-4.78779089,  1.06132465, -2.50433141],\n       [-4.99817085,  2.23486583, -1.20407518],\n       [-6.43595476,  1.42487573, -2.00400931],\n       [-4.24971742, -1.21643589, -2.21758627],\n       [-2.46593717, -1.22685901, -2.26727455],\n       [-3.47585534, -2.65007473, -1.58068986],\n       [ 4.1067109 ,  0.83680778,  2.34637208]])"
  },
  {
    "objectID": "posts/2023-02-04-working-with-conformers.html#addingremoving-conformers",
    "href": "posts/2023-02-04-working-with-conformers.html#addingremoving-conformers",
    "title": "Working with conformers",
    "section": "Adding/removing conformers",
    "text": "Adding/removing conformers\nI already showed how to remove conformer in the section on conformer IDs, but you can also add conformers to a molecule.\nLet’s start by getting a conformer which is a canonical orientation: centered at the origin and with its principle axes aligned with the cartesian axes:\n\nfrom rdkit.Chem import rdMolTransforms\n\n# GetConformer() returns a reference to the existing conformer, we want a copy:\nconf = Chem.Conformer(esomeprazole.GetConformer(0))\nrdMolTransforms.CanonicalizeConformer(conf)\n\nMake a copy of the molecule and add a 2D conformer, by default Compute2DCoords() clears the existing conformers\n\ncp = Chem.Mol(esomeprazole)\nrdDepictor.Compute2DCoords(cp)\n\n0\n\n\nNow add the that canonical conformer and set its ID so that it is unique. The return value is the new conformer ID\n\ncp.AddConformer(conf,assignId=True)\n\n1\n\n\n\ncp.GetConformer().GetPositions()[:3]\n\narray([[8.41075857, 1.90814121, 0.        ],\n       [6.92408705, 2.10766008, 0.        ],\n       [6.00796287, 0.91992422, 0.        ]])\n\n\n\ncp.GetConformer(1).GetPositions()[:3]\n\narray([[ 7.39395019,  1.81765991, -0.52124964],\n       [ 6.17231368,  1.90827963,  0.15172549],\n       [ 5.15244456,  1.01460864, -0.06395248]])"
  },
  {
    "objectID": "posts/2023-02-04-working-with-conformers.html#getting-a-new-molecule-with-just-one-conformer",
    "href": "posts/2023-02-04-working-with-conformers.html#getting-a-new-molecule-with-just-one-conformer",
    "title": "Working with conformers",
    "section": "Getting a new molecule with just one conformer",
    "text": "Getting a new molecule with just one conformer\nThere are often times you want to copy a multi-conformer molecule but just keep one of the conformers.\nThe standard way of copying RDKit molecules will copy all conformers:\n\ncp = Chem.Mol(esomeprazole)\ncp.GetNumConformers()\n\n10\n\n\nBut we can tell it to just copy one:\n\ncp = Chem.Mol(esomeprazole,confId=5)\nprint(cp.GetNumConformers(), cp.GetConformer().GetId())\n\n1 5"
  },
  {
    "objectID": "posts/2021-01-31-looking-at-random-coordinate-embedding.html",
    "href": "posts/2021-01-31-looking-at-random-coordinate-embedding.html",
    "title": "Looking at random-coordinate embedding",
    "section": "",
    "text": "This post discusses and shows the impact of the useRandomCoords option for the RDKit’s conformer generator.\nThe RDKit’s conformation generator is based on distance geometry. Here are the basic steps for the standard approach:\nAnother way to generate the initial set of coordinates is to replace steps 3 and 4 with just picking a set of random coordinates (i.e. scatter the atoms randomly about a 3D box) and then moving on to step 5 and minimizing those using the distance geometry force field mentioned above. I learned of this approach from David Spellmeyer, who published it back in 1997: https://doi.org/10.1016/S1093-3263(97)00014-4\nStarting from random coordinates has been possible within the RDKit more or less since the beginning (I’ve known David a long time ;-), but it’s not the default because my implementation of it was slower than the standard embedding approach in the early testing and validation work I did. I’ve been saying for years that random-coordinate embedding is more robust (though slower), but I haven’t actually gone back and tested/quantified that since my initial experiments. This blog post aims to clear some of that up.\nTL;DR: I ran some experiments using a set of 900 molecules with varying numbers of rotatable bonds and two different macrocycle sizes. Each molecule has at least two specified stereocenters. Given the current implementation, random-coordinate embedding is more robust - it’s more likely to produce the requested number of conformers for these structures than the standard metric embedding is - but it still tends to be a bit slower.\nHere’s a graphical summary of the results:  The main conclusion about timing can be see by comparing the red (metric) and blue (random) data.\nHere’s a plot comparing how long it takes to generate each conformer when trying for 50 conformers (left) or 50 more diverse conformers (right), the plot has been zoomed in, so a few extreme outliers (which impact the standard metric embedding more severely than the random-coordinate embedding) are not visible.\nGiven that it is certainly more robust and that the overall performance difference isn’t huge, I think I’m likely to switch to using random-coordinate embedding for my future work. Maybe we can think about making it the default in the RDKit too.\nFor those who are interested, here’s the original literature about ETKDG:\nIf you want to play with the compounds yourself, the SMILES are all in the rdkit_blog github repo\nOk, let’s get to work and generate the data."
  },
  {
    "objectID": "posts/2021-01-31-looking-at-random-coordinate-embedding.html#single-conformer",
    "href": "posts/2021-01-31-looking-at-random-coordinate-embedding.html#single-conformer",
    "title": "Looking at random-coordinate embedding",
    "section": "Single conformer",
    "text": "Single conformer\n\nps = AllChem.ETKDGv3()\nps.randomSeed=0xf00d\nmetric_etkdg_res = []\nfor i,m in enumerate(ms):\n    if not (i+1)%10:\n        print(f'Doing {i+1} of {len(ms)}')\n    m = Chem.Mol(m)\n    t1 = time.time()\n    AllChem.EmbedMolecule(m,ps)\n    t2 = time.time()\n    metric_etkdg_res.append((t2-t1,m.GetNumConformers(),m,m.GetIntProp('RTB')))\nwith open('./results/random_coords_expt.pkl','wb+') as outf:\n    pickle.dump((metric_etkdg_res,),outf)\n\n\nps = AllChem.ETKDGv3()\nps.randomSeed=0xf00d\nps.useRandomCoords = True\nrandom_etkdg_res = []\nfor i,m in enumerate(ms):\n    if not (i+1)%10:\n        print(f'Doing {i+1} of {len(ms)}')\n    m = Chem.Mol(m)\n    t1 = time.time()\n    AllChem.EmbedMolecule(m,ps)\n    t2 = time.time()\n    random_etkdg_res.append((t2-t1,m.GetNumConformers(),m,m.GetIntProp('RTB')))\nwith open('./results/random_coords_expt.pkl','wb+') as outf:\n    pickle.dump((metric_etkdg_res,random_etkdg_res,),outf)"
  },
  {
    "objectID": "posts/2021-01-31-looking-at-random-coordinate-embedding.html#conformers",
    "href": "posts/2021-01-31-looking-at-random-coordinate-embedding.html#conformers",
    "title": "Looking at random-coordinate embedding",
    "section": "50 conformers",
    "text": "50 conformers\n\nps = AllChem.ETKDGv3()\nps.randomSeed=0xf00d\nps.numThreads = 4\nmetric_etkdg50_res = []\nfor i,m in enumerate(ms):\n    if not (i+1)%10:\n        print(f'Doing {i+1} of {len(ms)}')\n    m = Chem.Mol(m)\n    t1 = time.time()\n    AllChem.EmbedMultipleConfs(m,50,ps)\n    t2 = time.time()\n    metric_etkdg50_res.append((t2-t1,m.GetNumConformers(),m,m.GetIntProp('RTB')))\nwith open('./results/random_coords_expt.pkl','wb+') as outf:\n    pickle.dump((metric_etkdg_res,random_etkdg_res,metric_etkdg50_res,),outf)\n\n\nps = AllChem.ETKDGv3()\nps.randomSeed=0xf00d\nps.numThreads = 4\nps.useRandomCoords = True\nrandom_etkdg50_res = []\nfor i,m in enumerate(ms):\n    if not (i+1)%10:\n        print(f'Doing {i+1} of {len(ms)}')\n    m = Chem.Mol(m)\n    t1 = time.time()\n    AllChem.EmbedMultipleConfs(m,50,ps)\n    t2 = time.time()\n    random_etkdg50_res.append((t2-t1,m.GetNumConformers(),m,m.GetIntProp('RTB')))\nwith open('./results/random_coords_expt.pkl','wb+') as outf:\n    pickle.dump((metric_etkdg_res,random_etkdg_res,metric_etkdg50_res,random_etkdg50_res,),outf)"
  },
  {
    "objectID": "posts/2021-01-31-looking-at-random-coordinate-embedding.html#number-of-conformers-generated",
    "href": "posts/2021-01-31-looking-at-random-coordinate-embedding.html#number-of-conformers-generated",
    "title": "Looking at random-coordinate embedding",
    "section": "Number of conformers generated",
    "text": "Number of conformers generated\n\nfigsize(7.5,6)\nnrots = sorted(set(x[-1] for x in metric_etkdg_res))\nprint(f'number of mols with below 50 conformers:')\nfor nrot in nrots:\n    xp = [x[1] for x in metric_etkdg50_res if x[-1]==nrot]\n    yp = [x[1] for x in random_etkdg50_res if x[-1]==nrot]\n    print(f'  {nrot} rotatable bonds, metric: {len([1 for x in xp if x!=50])} random: {len([1 for x in yp if x!=50])}')\n    scatter(xp,yp,label=str(nrot))\nlegend();\n#xlim(0,30);\n#ylim(0,40);\n#plot((0,30),(0,30))\ntitle('num confs generated out of 50')\nxlabel('metric')\nylabel('random coords');\n\nnumber of mols with below 50 conformers:\n  -14 rotatable bonds, metric: 8 random: 0\n  -10 rotatable bonds, metric: 1 random: 1\n  1 rotatable bonds, metric: 2 random: 2\n  2 rotatable bonds, metric: 2 random: 2\n  5 rotatable bonds, metric: 1 random: 1\n  10 rotatable bonds, metric: 4 random: 0\n  15 rotatable bonds, metric: 10 random: 0\n  20 rotatable bonds, metric: 27 random: 0\n  25 rotatable bonds, metric: 28 random: 0\n\n\n\n\n\n\nfigsize(7.5,6)\nnrots = sorted(set(x[-1] for x in metric_etkdg_res))\nprint(f'number of mols with below 50 conformers:')\nfor nrot in nrots:\n    xp = [x[1] for x in metric_etkdg50_rms_res if x[-1]==nrot]\n    yp = [x[1] for x in random_etkdg50_rms_res if x[-1]==nrot]\n    print(f'  {nrot} rotatable bonds, metric: {len([1 for x in xp if x!=50])} random: {len([1 for x in yp if x!=50])}')\n    scatter(xp,yp,label=str(nrot))\nlegend();\n#xlim(0,30);\n#ylim(0,40);\nplot((0,50),(0,50))\ntitle('num diverse confs generated out of 50')\nxlabel('metric')\nylabel('random coords');\n\nnumber of mols with below 50 conformers:\n  -14 rotatable bonds, metric: 31 random: 17\n  -10 rotatable bonds, metric: 85 random: 83\n  1 rotatable bonds, metric: 99 random: 99\n  2 rotatable bonds, metric: 100 random: 100\n  5 rotatable bonds, metric: 93 random: 85\n  10 rotatable bonds, metric: 32 random: 19\n  15 rotatable bonds, metric: 13 random: 1\n  20 rotatable bonds, metric: 27 random: 0\n  25 rotatable bonds, metric: 28 random: 0\n\n\n\n\n\n\nfigsize(7.5,6)\nnrots = sorted(set(x[-1] for x in metric_etkdg_res))\nprint(f'number of mols with below 50 conformers:')\nfor nrot in nrots:\n    xp = [x[1] for x in metric_etkdg50_nochiral_res if x[-1]==nrot]\n    yp = [x[1] for x in random_etkdg50_nochiral_res if x[-1]==nrot]\n    print(f'  {nrot} rotatable bonds, metric: {len([1 for x in xp if x!=50])} random: {len([1 for x in yp if x!=50])}')\n    scatter(xp,yp,label=str(nrot))\nlegend();\n#xlim(0,30);\n#ylim(0,40);\n#plot((0,30),(0,30))\ntitle('num nochiral confs generated out of 50')\nxlabel('metric')\nylabel('random coords');\n\nnumber of mols with below 50 conformers:\n  -14 rotatable bonds, metric: 6 random: 0\n  -10 rotatable bonds, metric: 0 random: 0\n  1 rotatable bonds, metric: 0 random: 0\n  2 rotatable bonds, metric: 0 random: 0\n  5 rotatable bonds, metric: 0 random: 0\n  10 rotatable bonds, metric: 2 random: 0\n  15 rotatable bonds, metric: 9 random: 0\n  20 rotatable bonds, metric: 26 random: 0\n  25 rotatable bonds, metric: 21 random: 0\n\n\n\n\n\nThe random coordinate embedding produces 50 conformers in almost every case, while there are a significant number of examples where metric embedding is unable to produce all 50 conformers."
  },
  {
    "objectID": "posts/2021-01-31-looking-at-random-coordinate-embedding.html#time-per-conformer-generated",
    "href": "posts/2021-01-31-looking-at-random-coordinate-embedding.html#time-per-conformer-generated",
    "title": "Looking at random-coordinate embedding",
    "section": "Time per conformer generated",
    "text": "Time per conformer generated\n\nfigsize(15,6)\nnrots = sorted(set(x[-1] for x in metric_etkdg_res))\n\nsubplot(1,2,1)\nfor nrot in nrots:\n    keep = [i for i,(x,y) in enumerate(zip(metric_etkdg50_res,random_etkdg50_res)) if x[-1]==nrot and x[1]!=0 and y[1]!=0]\n    xp = [metric_etkdg50_res[x][0]/metric_etkdg50_res[x][1] for x in keep]\n    yp = [random_etkdg50_res[x][0]/random_etkdg50_res[x][1] for x in keep]\n    scatter(xp,yp,label=str(nrot))\nlegend();\nxlim(0,1.5);\nylim(0,1.2);\nplot((0,.8),(0,.8))\ntitle('time per conformer produced (4 threads)')\nxlabel('metric')\nylabel('random coords');\n\nsubplot(1,2,2)\nfor nrot in nrots:\n    keep = [i for i,(x,y) in enumerate(zip(metric_etkdg50_rms_res,random_etkdg50_rms_res)) if x[-1]==nrot and x[1]!=0 and y[1]!=0]\n    xp = [metric_etkdg50_res[x][0]/metric_etkdg50_rms_res[x][1] for x in keep]\n    yp = [random_etkdg50_res[x][0]/random_etkdg50_rms_res[x][1] for x in keep]\n    scatter(xp,yp,label=str(nrot))\nlegend();\nxlim(0,1.5);\nylim(0,2);\nplot((0,1),(0,1))\ntitle('time per diverse conformer produced (4 threads)')\nxlabel('metric')\nylabel('random coords');\n\n\n\n\nLook at the same thing without cropping outliers.\n\nfigsize(15,6)\nnrots = sorted(set(x[-1] for x in metric_etkdg_res))\n\nsubplot(1,2,1)\nfor nrot in nrots:\n    keep = [i for i,(x,y) in enumerate(zip(metric_etkdg50_res,random_etkdg50_res)) if x[-1]==nrot and x[1]!=0 and y[1]!=0]\n    xp = [metric_etkdg50_res[x][0]/metric_etkdg50_res[x][1] for x in keep]\n    yp = [random_etkdg50_res[x][0]/random_etkdg50_res[x][1] for x in keep]\n    scatter(xp,yp,label=str(nrot))\nlegend();\nplot((0,3.5),(0,3.5))\ntitle('time per conformer produced (4 threads)')\nxlabel('metric')\nylabel('random coords');\n\nsubplot(1,2,2)\nfor nrot in nrots:\n    keep = [i for i,(x,y) in enumerate(zip(metric_etkdg50_rms_res,random_etkdg50_rms_res)) if x[-1]==nrot and x[1]!=0 and y[1]!=0]\n    xp = [metric_etkdg50_res[x][0]/metric_etkdg50_rms_res[x][1] for x in keep]\n    yp = [random_etkdg50_res[x][0]/random_etkdg50_rms_res[x][1] for x in keep]\n    scatter(xp,yp,label=str(nrot))\nlegend();\nplot((0,3.5),(0,3.5))\ntitle('time per diverse conformer produced (4 threads)')\nxlabel('metric')\nylabel('random coords');\n\n\n\n\nNote that these times per conformer cannot be directly compared to the time to generate a single conformer since these were run using multiple threads."
  },
  {
    "objectID": "posts/2021-01-31-looking-at-random-coordinate-embedding.html#ignoring-chirality",
    "href": "posts/2021-01-31-looking-at-random-coordinate-embedding.html#ignoring-chirality",
    "title": "Looking at random-coordinate embedding",
    "section": "Ignoring chirality",
    "text": "Ignoring chirality\n\nfigsize(7.5,6)\nnrots = sorted(set(x[-1] for x in metric_etkdg_res))\nfor nrot in nrots:\n    xp = [x[0] for x in metric_etkdg50_nochiral_res if x[-1]==nrot]\n    yp = [x[0] for x in random_etkdg50_nochiral_res if x[-1]==nrot]\n    scatter(xp,yp,label=str(nrot))\nlegend();\n#xlim(0,30);\n#ylim(0,40);\nplot((0,15),(0,15))\ntitle('nochiral time(s)')\nxlabel('metric')\nylabel('random coords');\n\n\n\n\nGeneral impact of ignoring chirality\n\nnrots = sorted(set(x[-1] for x in metric_etkdg_res))\nfigsize(15,6)\nsubplot(1,2,1)\nfor nrot in nrots:\n    xp = [x[0] for x in metric_etkdg50_res if x[-1]==nrot]\n    yp = [x[0] for x in metric_etkdg50_nochiral_res if x[-1]==nrot]\n    scatter(xp,yp,label=str(nrot))\nlegend();\nxlim(0,50);\nylim(0,30);\nplot((0,30),(0,30))\ntitle('metric embedding time(s)')\nxlabel('chiral')\nylabel('nochiral');\n\nsubplot(1,2,2)\nfor nrot in nrots:\n    xp = [x[0] for x in random_etkdg50_res if x[-1]==nrot]\n    yp = [x[0] for x in random_etkdg50_nochiral_res if x[-1]==nrot]\n    scatter(xp,yp,label=str(nrot))\nlegend();\nxlim(0,50);\nylim(0,40);\nplot((0,40),(0,40))\ntitle('random embedding time(s)')\nxlabel('chiral')\nylabel('nochiral');"
  },
  {
    "objectID": "posts/2021-01-31-looking-at-random-coordinate-embedding.html#impact-of-box-size-on-random-embedding",
    "href": "posts/2021-01-31-looking-at-random-coordinate-embedding.html#impact-of-box-size-on-random-embedding",
    "title": "Looking at random-coordinate embedding",
    "section": "Impact of box size on random embedding",
    "text": "Impact of box size on random embedding\n\nnrots = sorted(set(x[-1] for x in metric_etkdg_res))\nfigsize(15,6)\nsubplot(1,2,1)\nfor nrot in nrots:\n    xp = [x[0] for x in random_etkdg50_res if x[-1]==nrot]\n    yp = [x[0] for x in random_etkdg50_box1_res if x[-1]==nrot]\n    scatter(xp,yp,label=str(nrot))\nlegend();\nxlim(0,80);\nylim(0,80);\nplot((0,60),(0,60))\ntitle('random embedding time(s)')\nxlabel('mult=2 (default)')\nylabel('mult=1');\n    \n    \nsubplot(1,2,2)\nfor nrot in nrots:\n    xp = [x[0] for x in random_etkdg50_res if x[-1]==nrot]\n    yp = [x[0] for x in random_etkdg50_box2_res if x[-1]==nrot]\n    scatter(xp,yp,label=str(nrot))\nlegend();\nxlim(0,80);\nylim(0,80);\nplot((0,60),(0,60))\ntitle('random embedding time(s)')\nxlabel('mult=2 (default)')\nylabel('mult=0.5');"
  },
  {
    "objectID": "posts/2021-01-31-looking-at-random-coordinate-embedding.html#summaries",
    "href": "posts/2021-01-31-looking-at-random-coordinate-embedding.html#summaries",
    "title": "Looking at random-coordinate embedding",
    "section": "Summaries",
    "text": "Summaries\n\ndef set_box_color(bp, color):\n    setp(bp['boxes'], color=color)\n    setp(bp['whiskers'], color=color)\n    setp(bp['caps'], color=color)\n    setp(bp['medians'], color=color)\n    setp(bp['fliers'], markeredgecolor=color)\n\nfigsize(15,6)\n\nax = axes()\nax.set_yscale('log');\nax.set_ylabel('time(s)')\nax.set_xlabel('nrot')\n\nnrots = sorted(set(x[-1] for x in metric_etkdg_res))\nd = [[x[0] for x in metric_etkdg50_res if x[-1]==nrot] for nrot in nrots]\nbp = ax.boxplot(d,positions = [3*x for x in range(len(d))]);\nset_box_color(bp,'r')\n\nd = [[x[0] for x in random_etkdg50_res if x[-1]==nrot] for nrot in nrots]\nbp = ax.boxplot(d,positions = [3*x+.5 for x in range(len(d))]);\nset_box_color(bp,'b')\n\nd = [[x[0] for x in random_etkdg50_nochiral_res if x[-1]==nrot] for nrot in nrots]\nbp = ax.boxplot(d,positions = [3*x+1 for x in range(len(d))]);\nset_box_color(bp,'c')\n\nd = [[x[0] for x in random_etkdg50_box1_res if x[-1]==nrot] for nrot in nrots]\nbp = ax.boxplot(d,positions = [3*x+1.5 for x in range(len(d))]);\nset_box_color(bp,'m')\n\nd = [[x[0] for x in random_etkdg50_box2_res if x[-1]==nrot] for nrot in nrots]\nbp = ax.boxplot(d,positions = [3*x+2 for x in range(len(d))]);\nset_box_color(bp,'y')\n\n#set_axis_style(ax, [str(x) for x in nrots])\nticks = [str(x) for x in nrots]\nxticks(np.arange(0, len(ticks) * 3, 3)+1, ticks);\n\n\n\nplot([], c='r', label='metric')\nplot([], c='b', label='random')\nplot([], c='c', label='random-nochiral')\nplot([], c='m', label='random-box1')\nplot([], c='y', label='random-box0.5')\n\nlegend();\n\n\n\n\n\ndef set_box_color(bp, color):\n    setp(bp['boxes'], color=color)\n    setp(bp['whiskers'], color=color)\n    setp(bp['caps'], color=color)\n    setp(bp['medians'], color=color)\n    setp(bp['fliers'], markeredgecolor=color)\n\nfigsize(15,6)\n\nax = axes()\nax.set_yscale('log');\nax.set_ylabel('time per conformer (s)')\nax.set_xlabel('nrot')\n\nnrots = sorted(set(x[-1] for x in metric_etkdg_res))\nd = [[x[0]/x[2].GetNumConformers() for x in metric_etkdg50_res if x[-1]==nrot and x[2].GetNumConformers()!=0] for nrot in nrots]\nbp = ax.boxplot(d,positions = [3*x for x in range(len(d))]);\nset_box_color(bp,'r')\n\nd = [[x[0]/x[2].GetNumConformers() for x in metric_etkdg50_rms_res if x[-1]==nrot and x[2].GetNumConformers()!=0] for nrot in nrots]\nbp = ax.boxplot(d,positions = [3*x+.5 for x in range(len(d))]);\nset_box_color(bp,'c')\n\nd = [[x[0]/x[2].GetNumConformers() for x in random_etkdg50_res if x[-1]==nrot and x[2].GetNumConformers()!=0] for nrot in nrots]\nbp = ax.boxplot(d,positions = [3*x+1 for x in range(len(d))]);\nset_box_color(bp,'b')\n\nd = [[x[0]/x[2].GetNumConformers() for x in random_etkdg50_rms_res if x[-1]==nrot and x[2].GetNumConformers()!=0] for nrot in nrots]\nbp = ax.boxplot(d,positions = [3*x+1.5 for x in range(len(d))]);\nset_box_color(bp,'m')\n\n\n#set_axis_style(ax, [str(x) for x in nrots])\nticks = [str(x) for x in nrots]\nxticks(np.arange(0, len(ticks) * 3, 3)+1, ticks);\n\n\n\nplot([], c='r', label='metric')\nplot([], c='c', label='metric-diverse')\nplot([], c='b', label='random')\nplot([], c='m', label='random-diverse')\n\nlegend();"
  },
  {
    "objectID": "posts/2021-08-03-generalized-substructure-search.html",
    "href": "posts/2021-08-03-generalized-substructure-search.html",
    "title": "Generalized substructure search",
    "section": "",
    "text": "[Updated 19.12.2021 to use new functionality from the 2021.09 RDKit release]\nOver the last couple of releases we’ve added a number of RDKit features which allow useage of more advanced substructure query features and more control over the results returned by substructure searches. These include\n\nChem.AdjustQueryProperties() to tune the results returned by a substructure query\nrdMolEnumerator.Enumerate() to enumerate some V3000 mol block query features (as of the 2021.03 release the supported features are variable attachment points and link nodes)\nrdTautomerQuery.TautomerQuery() to allow tautomer-insensitive substructures search\n\nIn this post I’ll show how to use all of those together to do “generalized substructures searching” with the RDKit. Towards the bottom of the post there are a couple of Python functions which can be used in other scripts to make this process easier. I’ll also try and figure out a good way to get that into a future RDKit release.\nAAs an example, here’s a query:\n\nand here are four ChEMBL molecules returned using that query:\n\n\nfrom rdkit import Chem\nfrom rdkit.Chem import rdMolEnumerator\nfrom rdkit.Chem import rdTautomerQuery\nfrom rdkit.Chem import Draw\nfrom rdkit.Chem.Draw import IPythonConsole\nIPythonConsole.drawOptions.minFontSize = 10\nDraw.SetComicMode(IPythonConsole.drawOptions)\nfrom rdkit.Chem import rdDepictor\nrdDepictor.SetPreferCoordGen(True)\nimport rdkit\nprint(rdkit.__version__)\nimport time\nprint(time.asctime())\n\n2021.09.3\nSun Dec 19 06:14:00 2021\n\n\nLoad a SubstructLibrary created using ChEMBL_29. The code used to construct this is:\nfrom rdkit import RDLogger\nfrom rdkit import Chem\nfrom rdkit.Chem import rdSubstructLibrary\nimport pickle, time\nimport gzip\n\ngz = gzip.GzipFile('/home/glandrum/Downloads/chembl_29.sdf.gz')\nsuppl = Chem.ForwardSDMolSupplier(gz)\nRDLogger.DisableLog(\"rdApp.warning\")\nt1=time.time()\ndata = []\nfor i,mol in enumerate(suppl):\n    if not ((i+1)%50000):\n        print(f\"Processed {i+1} molecules in {(time.time()-t1):.1f} seconds\")\n    if mol is None or mol.GetNumAtoms()>50:\n        continue\n    fp = Chem.PatternFingerprint(mol,fpSize=1024,tautomerFingerprints=True)\n    smi = Chem.MolToSmiles(mol)\n    data.append((smi,fp))\nt2=time.time()\npickle.dump(data,open('../data/chembl29_sssdata.pkl','wb+'))\nt1=time.time()\nmols = rdSubstructLibrary.CachedTrustedSmilesMolHolder()\nfps = rdSubstructLibrary.TautomerPatternHolder(1024)\nfor smi,fp in data:\n    mols.AddSmiles(smi)\n    fps.AddFingerprint(fp)\nlibrary = rdSubstructLibrary.SubstructLibrary(mols,fps)\nt2=time.time()\nprint(f\"That took {t2-t1:.2f} seconds. The library has {len(library)} molecules.\")\npickle.dump(library,open('../data/chembl29_ssslib.pkl','wb+'))\n\nimport pickle\nwith open('./results/chembl29_ssslib.pkl','rb') as inf:\n    sslib = pickle.load(inf)\nprint(f'SubstructLibrary loaded with {len(sslib)} molecules')\n\nSubstructLibrary loaded with 2049078 molecules\n\n\n\nEnumeration\nStart with a query including a variable attachment point:\n\nqry = Chem.MolFromMolBlock('''\n  Mrv2108 08012107372D          \n\n  0  0  0     0  0            999 V3000\nM  V30 BEGIN CTAB\nM  V30 COUNTS 11 11 0 0 0\nM  V30 BEGIN ATOM\nM  V30 1 C -2.4167 7.8734 0 0\nM  V30 2 C -3.7503 7.1034 0 0\nM  V30 3 C -3.7503 5.5633 0 0\nM  V30 4 N -2.4167 4.7933 0 0\nM  V30 5 C -1.083 5.5633 0 0\nM  V30 6 C -1.083 7.1034 0 0\nM  V30 7 N 0.3973 7.5279 0 0\nM  V30 8 N 0.3104 5.0377 0 0\nM  V30 9 C 1.2585 6.2511 0 0\nM  V30 10 * 0.3539 6.2828 0 0\nM  V30 11 C 1.5089 8.2833 0 0\nM  V30 END ATOM\nM  V30 BEGIN BOND\nM  V30 1 1 1 2\nM  V30 2 2 2 3\nM  V30 3 1 3 4\nM  V30 4 2 4 5\nM  V30 5 1 5 6\nM  V30 6 2 1 6\nM  V30 7 1 7 6\nM  V30 8 1 5 8\nM  V30 9 1 8 9\nM  V30 10 2 7 9\nM  V30 11 1 10 11 ENDPTS=(2 8 7) ATTACH=ANY\nM  V30 END BOND\nM  V30 END CTAB\nM  END\n''')\nqry\n\n\n\n\n\nbndl = rdMolEnumerator.Enumerate(qry)\nmatches = sslib.GetMatches(bndl)\nprint(f'{len(matches)} matches')\nmols = [sslib.GetMol(x) for x in matches]\n# sort the molecules by number of atoms and preserve the match ID\nsorted_res = sorted(zip(mols,matches),key=lambda x:x[0].GetNumAtoms())\nsorted_mols,sorted_matches = zip(*sorted_res)\nDraw.MolsToGridImage(sorted_mols[:12],legends=[str(x) for x in sorted_matches],molsPerRow=4)\n\n1000 matches\n\n\n\n\n\nThose include some addditional rings attached to the core in molecules like 1476, 10083, and 10853. We can prevent that by calling AdjustQueryProperties():\n\nbndl = Chem.MolBundle()\nfor m in rdMolEnumerator.Enumerate(qry):\n    bndl.AddMol(Chem.AdjustQueryProperties(m))\nmatches = sslib.GetMatches(bndl)\nprint(f'{len(matches)} matches')\nmols = [sslib.GetMol(x) for x in matches]\n# sort the molecules by number of atoms and preserve the match ID\nsorted_res = sorted(zip(mols,matches),key=lambda x:x[0].GetNumAtoms())\nsorted_mols,sorted_matches = zip(*sorted_res)\nDraw.MolsToGridImage(sorted_mols[:12],legends=[str(x) for x in sorted_matches],molsPerRow=4)\n\n148 matches\n\n\n\n\n\nAn aside: this would be more convenient if AdjustQueryProperties directly supported passing MolBundle objects. That’s something for a future version.\nNow let’s make the query more complex by adding a link node in addition to the variable attachment point:\n\nqry = Chem.MolFromMolBlock('''\n  Mrv2108 08012108062D          \n\n  0  0  0     0  0            999 V3000\nM  V30 BEGIN CTAB\nM  V30 COUNTS 13 13 0 0 0\nM  V30 BEGIN ATOM\nM  V30 1 C -2.4167 7.8734 0 0\nM  V30 2 C -3.7503 7.1034 0 0\nM  V30 3 C -3.7503 5.5633 0 0\nM  V30 4 N -2.4167 4.7933 0 0\nM  V30 5 C -1.083 5.5633 0 0\nM  V30 6 C -1.083 7.1034 0 0\nM  V30 7 N 0.3973 7.5279 0 0\nM  V30 8 N 0.3104 5.0377 0 0\nM  V30 9 C 1.2585 6.2511 0 0\nM  V30 10 * 0.3539 6.2828 0 0\nM  V30 11 C 1.5089 8.2833 0 0\nM  V30 12 C 2.7975 6.1974 0 0\nM  V30 13 N 3.6136 7.5033 0 0\nM  V30 END ATOM\nM  V30 BEGIN BOND\nM  V30 1 1 1 2\nM  V30 2 2 2 3\nM  V30 3 1 3 4\nM  V30 4 2 4 5\nM  V30 5 1 5 6\nM  V30 6 2 1 6\nM  V30 7 1 7 6\nM  V30 8 1 5 8\nM  V30 9 1 8 9\nM  V30 10 2 7 9\nM  V30 11 1 10 11 ENDPTS=(2 8 7) ATTACH=ANY\nM  V30 12 1 9 12\nM  V30 13 1 12 13\nM  V30 END BOND\nM  V30 LINKNODE 1 2 2 12 9 12 13\nM  V30 END CTAB\nM  END\n''')\nqry\n\n\n\n\n\nbndl = rdMolEnumerator.Enumerate(qry)\nmatches = sslib.GetMatches(bndl)\nprint(f'{len(matches)} matches')\nmols = [sslib.GetMol(x) for x in matches]\n# sort the molecules by number of atoms and preserve the match ID\nsorted_res = sorted(zip(mols,matches),key=lambda x:x[0].GetNumAtoms())\nsorted_mols,sorted_matches = zip(*sorted_res)\nDraw.MolsToGridImage(sorted_mols[:12],legends=[str(x) for x in sorted_matches],molsPerRow=4)\n\n193 matches\n\n\n\n\n\n\n\nEnumeration + tautomer-insensitive queries\nHere we will use the RDKit’s TautomerQuery class to do tautomer-insensitive substructure queries. We start by enumerating the molecules, as above, but then convert each of the results into a TautomerQuery\nTo see what’s going on here it helps to have the result molecules all aligned the same way. In order to do that we also need to generate query molecules with aligned coordinates.\n\nfrom rdkit.Chem import rdFMCS\n\ndef getAlignedQueries(qry):\n    # generate a conformer for the query if we don't have one already\n    if not qry.GetNumConformers():\n        rdDepictor.Compute2DCoords(qry)\n\n    bndl = rdMolEnumerator.Enumerate(qry)\n    \n    # find the MCS of the enumerated molecules:\n    mcs = rdFMCS.FindMCS(bndl)\n    qmcs = Chem.MolFromSmarts(mcs.smartsString)\n    \n    # and now adjust the properties, generate coordinates, and create the TautomerQuery\n    queries = []\n    for q in bndl:\n        q = Chem.AdjustQueryProperties(q)\n        rdDepictor.GenerateDepictionMatching2DStructure(q,qry,refPatt=qmcs)\n        queries.append(rdTautomerQuery.TautomerQuery(q))\n    return queries\n\ndef drawAlignedMols(mols,qry,legends=None,molsPerRow=4):\n    queries = getAlignedQueries(qry)\n    for i,m in enumerate(mols):\n        for q in queries:\n            if q.IsSubstructOf(m):\n                rdDepictor.GenerateDepictionMatching2DStructure(m,q.GetTemplateMolecule())\n    return Draw.MolsToGridImage(mols,legends=legends,molsPerRow=molsPerRow)\n\n\nqry = Chem.MolFromMolBlock('''\n  Mrv2108 08012108222D          \n\n  0  0  0     0  0            999 V3000\nM  V30 BEGIN CTAB\nM  V30 COUNTS 12 12 0 0 0\nM  V30 BEGIN ATOM\nM  V30 1 C -2.4167 7.8734 0 0\nM  V30 2 C -3.7503 7.1034 0 0\nM  V30 3 C -3.7503 5.5633 0 0\nM  V30 4 N -2.4167 4.7933 0 0\nM  V30 5 C -1.083 5.5633 0 0\nM  V30 6 C -1.083 7.1034 0 0\nM  V30 7 N 0.3973 7.5279 0 0\nM  V30 8 N 0.3104 5.0377 0 0\nM  V30 9 C 1.2585 6.2511 0 0\nM  V30 10 * -3.0835 7.4884 0 0\nM  V30 11 [C,N,O] -3.0835 9.7984 0 0\nM  V30 12 * 2.7975 6.1974 0 0\nM  V30 END ATOM\nM  V30 BEGIN BOND\nM  V30 1 1 1 2\nM  V30 2 2 2 3\nM  V30 3 1 3 4\nM  V30 4 2 4 5\nM  V30 5 1 5 6\nM  V30 6 2 1 6\nM  V30 7 1 7 6\nM  V30 8 1 5 8\nM  V30 9 1 8 9\nM  V30 10 2 7 9\nM  V30 11 1 10 11 ENDPTS=(2 2 1) ATTACH=ANY\nM  V30 12 1 9 12\nM  V30 END BOND\nM  V30 END CTAB\nM  END\n''')\nqry\n\n\n\n\nStart by doing a tautomer-sensitive query to see how many results we get:\n\nbndl = rdMolEnumerator.Enumerate(qry)\nmatches = []\nfor m in bndl:\n    m = Chem.AdjustQueryProperties(m)\n    matches.extend(sslib.GetMatches(m))\nprint(f'{len(matches)} matches')\nmols = [sslib.GetMol(x) for x in matches]\n\n# sort the molecules by number of atoms and preserve the match ID\nsorted_res = sorted(zip(mols,matches),key=lambda x:x[0].GetNumAtoms())\nsorted_mols,sorted_matches = zip(*sorted_res)\ndrawAlignedMols(sorted_mols[:12],qry,[str(x) for x in sorted_matches])\n\n276 matches\n\n\n\n\n\nNow do the tautomer-insensitive version of that and show just the new molecules\n\nbndl = rdMolEnumerator.Enumerate(qry)\nmatches2 = []\nfor m in bndl:\n    m = Chem.AdjustQueryProperties(m)\n    tqry = rdTautomerQuery.TautomerQuery(m)\n    matches2.extend(sslib.GetMatches(tqry))\nextras = set(matches2).difference(matches)\nprint(f'{len(matches2)} matches, {len(extras)} are non-overlapping')\nmols = [sslib.GetMol(x) for x in extras]\n# sort the molecules by number of atoms and preserve the match ID\nsorted_res = sorted(zip(mols,matches),key=lambda x:x[0].GetNumAtoms())\nsorted_mols,sorted_matches = zip(*sorted_res)\ndrawAlignedMols(sorted_mols[:12],qry,[str(x) for x in sorted_matches])\n\n288 matches, 12 are non-overlapping\n\n\n\n\n\n\n\nBring it all together\nNow let’s put that all together in one function and include the information required to do atom highlighting in the structure drawings\n\nfrom rdkit.Chem import rdFMCS\nfrom rdkit.Chem import rdTautomerQuery\n\n# this function does the enumeration of the queries\ndef getAlignedQueries(qry,tautomerInsensitive=True):\n    if not qry.GetNumConformers():\n        rdDepictor.Compute2DCoords(qry)\n    bndl = rdMolEnumerator.Enumerate(qry)\n    \n    # find the MCS of the enumerated molecules:\n    mcs = rdFMCS.FindMCS(bndl)\n    qmcs = Chem.MolFromSmarts(mcs.smartsString)\n    \n    # and now adjust the properties, generate coordinates, and create the TautomerQuery\n    queries = []\n    for q in bndl:\n        q = Chem.AdjustQueryProperties(q)\n        rdDepictor.GenerateDepictionMatching2DStructure(q,qry,refPatt=qmcs)\n        if tautomerInsensitive:\n            q = rdTautomerQuery.TautomerQuery(q)\n        queries.append(q)\n    return queries\n\n\ndef generalizedSubstructureSearch(query,sslib,tautomerInsensitive=True,alignResults=True,\n                                  maxResults=1000):\n    queries = getAlignedQueries(query,tautomerInsensitive=tautomerInsensitive)\n    matches = []\n    for q in queries:\n        matches.extend(sslib.GetMatches(q,maxResults=maxResults))\n    tmols = [(x,sslib.GetMol(x)) for x in matches]\n    mols = []\n    for idx,mol in sorted(tmols,key=lambda x:x[1].GetNumAtoms()):\n        match = None\n        if(alignResults):\n            for q in queries:\n                if tautomerInsensitive:\n                    match = q.GetSubstructMatch(mol)\n                    if match:\n                        rdDepictor.GenerateDepictionMatching2DStructure(mol,q.GetTemplateMolecule())\n                        break\n                else:\n                    match = mol.GetSubstructMatch(q)\n                    if match:\n                        rdDepictor.GenerateDepictionMatching2DStructure(mol,q)\n                        break\n                \n        mols.append((idx,mol,match))\n        if len(mols)>=maxResults:\n            break\n    return mols\n    \n\n\nres = generalizedSubstructureSearch(qry,sslib)\nids,mols,matchAtoms = zip(*res)\nprint(f'{len(mols)} results')\nDraw.MolsToGridImage(mols[:12],legends=[str(x) for x in ids],highlightAtomLists=matchAtoms,\n                     molsPerRow=4)\n\n288 results\n\n\n\n\n\n\nres = generalizedSubstructureSearch(qry,sslib,tautomerInsensitive=False)\nids,mols,matchAtoms = zip(*res)\nprint(f'{len(mols)} results')\nDraw.MolsToGridImage(mols[:12],legends=[str(x) for x in ids],highlightAtomLists=matchAtoms,\n                     molsPerRow=4)\n\n276 results\n\n\n\n\n\nLast example, link nodes + variable attachment + tautomer enumeration\n\nqry = Chem.MolFromMolBlock('''\n  Mrv2108 08032106392D          \n\n  0  0  0     0  0            999 V3000\nM  V30 BEGIN CTAB\nM  V30 COUNTS 13 13 0 0 0\nM  V30 BEGIN ATOM\nM  V30 1 C -2.4167 7.8734 0 0\nM  V30 2 C -3.7503 7.1034 0 0\nM  V30 3 C -3.7503 5.5633 0 0\nM  V30 4 N -2.4167 4.7933 0 0\nM  V30 5 C -1.083 5.5633 0 0\nM  V30 6 C -1.083 7.1034 0 0\nM  V30 7 N 0.3973 7.5279 0 0\nM  V30 8 N 0.3104 5.0377 0 0\nM  V30 9 C 1.2585 6.2511 0 0\nM  V30 10 * -3.0835 7.4884 0 0\nM  V30 11 [C,N,O] -3.0835 9.7984 0 0\nM  V30 12 * 2.7975 6.1974 0 0\nM  V30 13 N 3.6136 7.5033 0 0\nM  V30 END ATOM\nM  V30 BEGIN BOND\nM  V30 1 1 1 2\nM  V30 2 2 2 3\nM  V30 3 1 3 4\nM  V30 4 2 4 5\nM  V30 5 1 5 6\nM  V30 6 2 1 6\nM  V30 7 1 7 6\nM  V30 8 1 5 8\nM  V30 9 1 8 9\nM  V30 10 2 7 9\nM  V30 11 1 10 11 ENDPTS=(3 3 2 1) ATTACH=ANY\nM  V30 12 1 9 12\nM  V30 13 1 12 13\nM  V30 END BOND\nM  V30 LINKNODE 1 3 2 12 9 12 13\nM  V30 END CTAB\nM  END\n''')\nqry\n\n\n\n\n\nres = generalizedSubstructureSearch(qry,sslib)\nids,mols,matchAtoms = zip(*res)\nprint(f'{len(mols)} results')\nDraw.MolsToGridImage(mols[:12],legends=[str(x) for x in ids],highlightAtomLists=matchAtoms,\n                     molsPerRow=4)\n\n24 results\n\n\n\n\n\nImage for the blog post summary:\n\nkeep = [0,1,4,6]\nids,mols,matchAtoms = zip(*[res[x] for x in keep])\nDraw.MolsToGridImage(mols[:12],legends=[str(x) for x in ids],highlightAtomLists=matchAtoms,\n                    molsPerRow=2,subImgSize=(300,250))"
  },
  {
    "objectID": "posts/2022-12-23-descriptor-tutorial.html",
    "href": "posts/2022-12-23-descriptor-tutorial.html",
    "title": "Descriptor calculation tutorial",
    "section": "",
    "text": "A question asked on Mastodon made me realize that we don’t have a tutorial anywhere on descriptor calculation. Here’s a first pass at doing that. This will eventually end up in the RDKit documentation\nStart by doing the usual imports\n\nfrom rdkit import Chem\nimport rdkit\nrdkit.__version__\n\n'2022.09.1'\n\n\nA test molecule:\n\ndoravirine = Chem.MolFromSmiles('Cn1c(n[nH]c1=O)Cn2ccc(c(c2=O)Oc3cc(cc(c3)Cl)C#N)C(F)(F)F')\ndoravirine\n\n\n\n\nThe Descriptors module has a list of the available descriptors. The list is made of (name, function) 2-tuples:\n\nfrom rdkit.Chem import Descriptors\nprint(len(Descriptors._descList))\nprint(Descriptors._descList[:5])\n\n208\n[('MaxEStateIndex', <function MaxEStateIndex at 0x7fe4a4f2d1f0>), ('MinEStateIndex', <function MinEStateIndex at 0x7fe4a4f2d280>), ('MaxAbsEStateIndex', <function MaxAbsEStateIndex at 0x7fe4a4f2d310>), ('MinAbsEStateIndex', <function MinAbsEStateIndex at 0x7fe4a4f2d3a0>), ('qed', <function qed at 0x7fe4a4e2e3a0>)]\n\n\nWe can use those functions to directly calculate the corresponding descriptor. So, for example, the value of MaxEStateIndex for doravirine is:\n\nDescriptors._descList[0][1](doravirine)\n\n13.412553309006833\n\n\nAs an aside, if we just want a few named descriptors, it’s a lot clearer (and easier to write the code!) if we call the individual descriptor functions directly:\n\nDescriptors.MaxEStateIndex(doravirine)\n\n13.412553309006833\n\n\nOften we want to calculate all the descriptors. As of the 2022.09 release of the rdkit there’s no real convenience function for descriptor calculation, so let’s create one:\n\ndef getMolDescriptors(mol, missingVal=None):\n    ''' calculate the full list of descriptors for a molecule\n    \n        missingVal is used if the descriptor cannot be calculated\n    '''\n    res = {}\n    for nm,fn in Descriptors._descList:\n        # some of the descriptor fucntions can throw errors if they fail, catch those here:\n        try:\n            val = fn(mol)\n        except:\n            # print the error message:\n            import traceback\n            traceback.print_exc()\n            # and set the descriptor value to whatever missingVal is\n            val = missingVal\n        res[nm] = val\n    return res\n        \n\n\ngetMolDescriptors(doravirine)\n\n{'MaxEStateIndex': 13.412553309006833,\n 'MinEStateIndex': -4.871620672188628,\n 'MaxAbsEStateIndex': 13.412553309006833,\n 'MinAbsEStateIndex': 0.045220418860841605,\n 'qed': 0.6914051268589834,\n 'MolWt': 425.754,\n 'HeavyAtomMolWt': 414.66600000000005,\n 'ExactMolWt': 425.050251552,\n 'NumValenceElectrons': 150,\n 'NumRadicalElectrons': 0,\n 'MaxPartialCharge': 0.4197525104273902,\n 'MinPartialCharge': -0.45079941098947357,\n 'MaxAbsPartialCharge': 0.45079941098947357,\n 'MinAbsPartialCharge': 0.4197525104273902,\n 'FpDensityMorgan1': 1.3103448275862069,\n 'FpDensityMorgan2': 2.0344827586206895,\n 'FpDensityMorgan3': 2.6206896551724137,\n 'BCUT2D_MWHI': 35.495691906445956,\n 'BCUT2D_MWLOW': 10.182401353178228,\n 'BCUT2D_CHGHI': 2.363442602497932,\n 'BCUT2D_CHGLO': -2.1532454345808123,\n 'BCUT2D_LOGPHI': 2.362094239067197,\n 'BCUT2D_LOGPLOW': -2.2620565247489415,\n 'BCUT2D_MRHI': 6.30376236817795,\n 'BCUT2D_MRLOW': -0.13831572005086737,\n 'BalabanJ': 2.1143058157682066,\n 'BertzCT': 1236.821427505276,\n 'Chi0': 21.344570503761737,\n 'Chi0n': 14.619315272563007,\n 'Chi0v': 15.375244218581463,\n 'Chi1': 13.595574016164479,\n 'Chi1n': 7.8933192308003095,\n 'Chi1v': 8.271283703809537,\n 'Chi2n': 5.882827756329733,\n 'Chi2v': 6.319263536801718,\n 'Chi3n': 3.9307609940961763,\n 'Chi3v': 4.148978884332168,\n 'Chi4n': 2.4772835642835087,\n 'Chi4v': 2.7023697348309867,\n 'HallKierAlpha': -3.519999999999999,\n 'Ipc': 2291995.915536308,\n 'Kappa1': 20.220355828454835,\n 'Kappa2': 7.4789147435283585,\n 'Kappa3': 4.168020338062062,\n 'LabuteASA': 164.8909024413842,\n 'PEOE_VSA1': 9.303962601591405,\n 'PEOE_VSA10': 11.3129633249809,\n 'PEOE_VSA11': 5.824404497999927,\n 'PEOE_VSA12': 5.749511833283905,\n 'PEOE_VSA13': 5.559266895052007,\n 'PEOE_VSA14': 11.86604191564695,\n 'PEOE_VSA2': 9.361636831863176,\n 'PEOE_VSA3': 9.893218992372859,\n 'PEOE_VSA4': 23.531818506063985,\n 'PEOE_VSA5': 0.0,\n 'PEOE_VSA6': 11.600939890232516,\n 'PEOE_VSA7': 24.26546827384644,\n 'PEOE_VSA8': 18.267148868031594,\n 'PEOE_VSA9': 18.177429210401844,\n 'SMR_VSA1': 17.908108096824506,\n 'SMR_VSA10': 11.600939890232516,\n 'SMR_VSA2': 5.261891554738487,\n 'SMR_VSA3': 19.331562912184786,\n 'SMR_VSA4': 7.04767198267719,\n 'SMR_VSA5': 12.72105492335605,\n 'SMR_VSA6': 0.0,\n 'SMR_VSA7': 73.27433730199388,\n 'SMR_VSA8': 0.0,\n 'SMR_VSA9': 17.568244979360085,\n 'SlogP_VSA1': 15.98587324705553,\n 'SlogP_VSA10': 13.171245143024459,\n 'SlogP_VSA11': 11.49902366656781,\n 'SlogP_VSA12': 11.600939890232516,\n 'SlogP_VSA2': 19.331562912184786,\n 'SlogP_VSA3': 19.76872690603324,\n 'SlogP_VSA4': 11.33111286753076,\n 'SlogP_VSA5': 16.95130748139392,\n 'SlogP_VSA6': 40.05138621360316,\n 'SlogP_VSA7': 5.022633313741326,\n 'SlogP_VSA8': 0.0,\n 'SlogP_VSA9': 0.0,\n 'TPSA': 105.70000000000002,\n 'EState_VSA1': 28.738272135679853,\n 'EState_VSA10': 22.760319511168106,\n 'EState_VSA11': 0.0,\n 'EState_VSA2': 28.704757542634727,\n 'EState_VSA3': 6.06636706846161,\n 'EState_VSA4': 21.397409935657397,\n 'EState_VSA5': 19.18040611960041,\n 'EState_VSA6': 6.069221312792274,\n 'EState_VSA7': 0.0,\n 'EState_VSA8': 10.197363616602075,\n 'EState_VSA9': 21.599694398771053,\n 'VSA_EState1': 47.48050639865553,\n 'VSA_EState10': 5.842061004535676,\n 'VSA_EState2': 24.16343117595945,\n 'VSA_EState3': 14.921853617262808,\n 'VSA_EState4': -2.8980189732872814,\n 'VSA_EState5': -1.0781549918202147,\n 'VSA_EState6': 6.092225491490601,\n 'VSA_EState7': -3.945179835565914,\n 'VSA_EState8': -0.2762282865821226,\n 'VSA_EState9': 1.3919488437959202,\n 'FractionCSP3': 0.17647058823529413,\n 'HeavyAtomCount': 29,\n 'NHOHCount': 1,\n 'NOCount': 8,\n 'NumAliphaticCarbocycles': 0,\n 'NumAliphaticHeterocycles': 0,\n 'NumAliphaticRings': 0,\n 'NumAromaticCarbocycles': 1,\n 'NumAromaticHeterocycles': 2,\n 'NumAromaticRings': 3,\n 'NumHAcceptors': 7,\n 'NumHDonors': 1,\n 'NumHeteroatoms': 12,\n 'NumRotatableBonds': 4,\n 'NumSaturatedCarbocycles': 0,\n 'NumSaturatedHeterocycles': 0,\n 'NumSaturatedRings': 0,\n 'RingCount': 3,\n 'MolLogP': 2.65458,\n 'MolMR': 94.87570000000002,\n 'fr_Al_COO': 0,\n 'fr_Al_OH': 0,\n 'fr_Al_OH_noTert': 0,\n 'fr_ArN': 0,\n 'fr_Ar_COO': 0,\n 'fr_Ar_N': 4,\n 'fr_Ar_NH': 1,\n 'fr_Ar_OH': 0,\n 'fr_COO': 0,\n 'fr_COO2': 0,\n 'fr_C_O': 0,\n 'fr_C_O_noCOO': 0,\n 'fr_C_S': 0,\n 'fr_HOCCN': 0,\n 'fr_Imine': 0,\n 'fr_NH0': 4,\n 'fr_NH1': 1,\n 'fr_NH2': 0,\n 'fr_N_O': 0,\n 'fr_Ndealkylation1': 0,\n 'fr_Ndealkylation2': 0,\n 'fr_Nhpyrrole': 1,\n 'fr_SH': 0,\n 'fr_aldehyde': 0,\n 'fr_alkyl_carbamate': 0,\n 'fr_alkyl_halide': 3,\n 'fr_allylic_oxid': 0,\n 'fr_amide': 0,\n 'fr_amidine': 0,\n 'fr_aniline': 0,\n 'fr_aryl_methyl': 0,\n 'fr_azide': 0,\n 'fr_azo': 0,\n 'fr_barbitur': 0,\n 'fr_benzene': 1,\n 'fr_benzodiazepine': 0,\n 'fr_bicyclic': 0,\n 'fr_diazo': 0,\n 'fr_dihydropyridine': 0,\n 'fr_epoxide': 0,\n 'fr_ester': 0,\n 'fr_ether': 1,\n 'fr_furan': 0,\n 'fr_guanido': 0,\n 'fr_halogen': 4,\n 'fr_hdrzine': 0,\n 'fr_hdrzone': 0,\n 'fr_imidazole': 0,\n 'fr_imide': 0,\n 'fr_isocyan': 0,\n 'fr_isothiocyan': 0,\n 'fr_ketone': 0,\n 'fr_ketone_Topliss': 0,\n 'fr_lactam': 0,\n 'fr_lactone': 0,\n 'fr_methoxy': 0,\n 'fr_morpholine': 0,\n 'fr_nitrile': 1,\n 'fr_nitro': 0,\n 'fr_nitro_arom': 0,\n 'fr_nitro_arom_nonortho': 0,\n 'fr_nitroso': 0,\n 'fr_oxazole': 0,\n 'fr_oxime': 0,\n 'fr_para_hydroxylation': 0,\n 'fr_phenol': 0,\n 'fr_phenol_noOrthoHbond': 0,\n 'fr_phos_acid': 0,\n 'fr_phos_ester': 0,\n 'fr_piperdine': 0,\n 'fr_piperzine': 0,\n 'fr_priamide': 0,\n 'fr_prisulfonamd': 0,\n 'fr_pyridine': 1,\n 'fr_quatN': 0,\n 'fr_sulfide': 0,\n 'fr_sulfonamd': 0,\n 'fr_sulfone': 0,\n 'fr_term_acetylene': 0,\n 'fr_tetrazole': 0,\n 'fr_thiazole': 0,\n 'fr_thiocyan': 0,\n 'fr_thiophene': 0,\n 'fr_unbrch_alkane': 0,\n 'fr_urea': 0}\n\n\nSuppose I want to generate the full set of descriptors for a bunch of molecules…\n\n!head ../data/herg_data.txt\n\ncanonical_smiles molregno activity_id standard_value standard_units\nN[C@@H]([C@@H]1CC[C@H](CC1)NS(=O)(=O)c2ccc(F)cc2F)C(=O)N3CC[C@H](F)C3 29272 671631 49000 nM\nN[C@@H](C1CCCCC1)C(=O)N2CCSC2 29758 674222 28000 nM\nN[C@@H]([C@@H]1CC[C@H](CC1)NC(=O)c2ccc(F)c(F)c2)C(=O)N3CCSC3 29449 675583 5900 nM\nN[C@@H]([C@@H]1CC[C@H](CC1)NS(=O)(=O)c2ccc(F)cc2F)C(=O)N3CCCC3 29244 675588 35000 nM\nN[C@@H]([C@@H]1CC[C@H](CC1)NS(=O)(=O)c2ccc(OC(F)(F)F)cc2)C(=O)N3CC[C@@H](F)C3 29265 679299 6000 nM\nN[C@@H]([C@@H]1CC[C@H](CC1)NS(=O)(=O)c2ccc(F)cc2F)C(=O)N3CC[C@@H](F)C3 29253 679302 52000 nM\nN[C@@H]([C@@H]1CC[C@H](CC1)NC(=O)c2ccc(F)c(F)c2)C(=O)N3CCCC3 29482 683566 29000 nM\nN[C@@H]([C@@H]1CC[C@H](CC1)NC(=O)c2ccccc2C(F)(F)F)C(=O)N3CCSC3 29340 685042 39000 nM\nN[C@@H]([C@@H]1CC[C@H](CC1)NC(=O)OCc2ccccc2)C(=O)N3CC[C@@H](F)C3 29213 685047 43000 nM\n\n\nWe can read in all the molecules using a “Supplier” object, there’s more about this in the documentation\n\nsuppl = Chem.SmilesMolSupplier('../data/herg_data.txt')\nmols = [m for m in suppl]\nlen(mols)\n\n1090\n\n\nNow calculate the descriptors. This takes a bit (10-20 seconds on my machine) for the ~1100 molecules I read in.\n\nallDescrs = [getMolDescriptors(m) for m in mols]\n\nThe problem here is that we have a list of dictionaries… that’s not useful for most things. Let’s convert it to a pandas dataframe:\n\nimport pandas as pd\ndf = pd.DataFrame(allDescrs)\ndf.head()\n\n\n\n\n\n  \n    \n      \n      MaxEStateIndex\n      MinEStateIndex\n      MaxAbsEStateIndex\n      MinAbsEStateIndex\n      qed\n      MolWt\n      HeavyAtomMolWt\n      ExactMolWt\n      NumValenceElectrons\n      NumRadicalElectrons\n      ...\n      fr_sulfide\n      fr_sulfonamd\n      fr_sulfone\n      fr_term_acetylene\n      fr_tetrazole\n      fr_thiazole\n      fr_thiocyan\n      fr_thiophene\n      fr_unbrch_alkane\n      fr_urea\n    \n  \n  \n    \n      0\n      13.787943\n      -4.120373\n      13.787943\n      0.074317\n      0.759946\n      419.469\n      395.277\n      419.149047\n      156\n      0\n      ...\n      0\n      1\n      0\n      0\n      0\n      0\n      0\n      0\n      0\n      0\n    \n    \n      1\n      12.032152\n      -0.232407\n      12.032152\n      0.186944\n      0.777429\n      228.361\n      208.201\n      228.129634\n      86\n      0\n      ...\n      1\n      0\n      0\n      0\n      0\n      0\n      0\n      0\n      0\n      0\n    \n    \n      2\n      13.255664\n      -1.036185\n      13.255664\n      0.017845\n      0.835147\n      383.464\n      360.280\n      383.147904\n      142\n      0\n      ...\n      1\n      0\n      0\n      0\n      0\n      0\n      0\n      0\n      0\n      0\n    \n    \n      3\n      13.787093\n      -4.072560\n      13.787093\n      0.015196\n      0.786287\n      401.479\n      376.279\n      401.158469\n      150\n      0\n      ...\n      0\n      1\n      0\n      0\n      0\n      0\n      0\n      0\n      0\n      0\n    \n    \n      4\n      13.326286\n      -4.859254\n      13.326286\n      0.063966\n      0.625645\n      467.485\n      442.285\n      467.150190\n      174\n      0\n      ...\n      0\n      1\n      0\n      0\n      0\n      0\n      0\n      0\n      0\n      0\n    \n  \n\n5 rows × 208 columns\n\n\n\nAnd now we have something that we could use to build models, filter, etc."
  },
  {
    "objectID": "posts/2022-03-14-rgd-and-molzip.html",
    "href": "posts/2022-03-14-rgd-and-molzip.html",
    "title": "R-group decomposition and molzip",
    "section": "",
    "text": "Recently a couple of customers have asked questions along the lines of: “How do I do an R-group decomposition and then recombine the cores and R groups to create new molecules?” That’s an interesting and useful task which the RDKit has some built-in tools to help with, so I figured I’d do a blog post.\nNote: Though I’m doing this blog post using a local build from RDKit master all of the functionality which I demonstrate here is already available in the 2021.09 release series."
  },
  {
    "objectID": "posts/2022-03-14-rgd-and-molzip.html#quick-intro-to-molzip",
    "href": "posts/2022-03-14-rgd-and-molzip.html#quick-intro-to-molzip",
    "title": "R-group decomposition and molzip",
    "section": "Quick intro to molzip",
    "text": "Quick intro to molzip\nWe’ll use the RDKit’s molzip() function to recombine the cores with the side chains.\nmolzip lets you take a molecule containing multiple fragments and “zip” them together. The atoms which should be bonded in the final molecule are labelled by connecting them to dummy atoms. The code identifies matching dummy atoms (by default this means dummies with the same isotopic label) in the fragments, adds bonds between the atoms connected to the dummies, and then removes the dummies.\nHere’s a simple example using a molecule with three fragments:\n\nsample = Chem.MolFromSmiles('[*:1]c1nc([*:2])ncc1.CO[*:1].[*:2]N(C)C')\nsample\n\n\n\n\nAnd this is what happens when we zip those together:\n\nChem.molzip(sample)"
  },
  {
    "objectID": "posts/2022-03-14-rgd-and-molzip.html#using-molzip-with-rgd-output",
    "href": "posts/2022-03-14-rgd-and-molzip.html#using-molzip-with-rgd-output",
    "title": "R-group decomposition and molzip",
    "section": "Using molzip with RGD output",
    "text": "Using molzip with RGD output\nThe molzip function is perfect for working with the output from an R-group decomposition.\nHere I’ll define the function we’re going to use to enumerate all of the products:\n\nimport random\ndef enumerate_all_products(core,*rgroups,randomOrder=False):\n    # preserve the positions of the non-dummy core atoms, \n    # we will use these to make sure the cores are drawn\n    # the same way in each molecule we generate\n    corePos = {}\n    conf = core.GetConformer()\n    for i in range(conf.GetNumAtoms()):\n        corePos[i] = Geometry.Point2D(conf.GetAtomPosition(i))\n        \n    # Python's itertools handles doing the combinatorics of generating\n    # every possible combination of R groups:\n    order = itertools.product(*rgroups)\n    if randomOrder:\n        order = list(order)\n        random.shuffle(order)\n        \n    # now we just loop over each combination, copy all the pieces into\n    # one molecule, and zip it. That's our product\n    for tpl in order:\n        tm = Chem.RWMol(core)\n        for r in tpl:\n            tm.InsertMol(r)\n        prod = Chem.molzip(tm)\n        if prod is not None:\n            # generate 2d coordinates with the core fixed in place\n            rdDepictor.Compute2DCoords(prod,canonOrient=False,coordMap=corePos)\n            \n            # and finally yield the product molecule\n            yield prod\n\nWe’re going to use the core which came from the RGD since it’s labelled in the same way as the sidechains\n\nrgd_core = rgd['Core'][0]\nrgd_core\n\n\n\nscaffold1\n\n\nLet’s try it out:\n\n# this returns a generator which produces products:\nprod_gen = enumerate_all_products(rgd_core,r1s,r2s,r3s)\n\n# now get the first unique products \nprods = []\nseen = set()\nfor prod in prod_gen:\n    if prod is not None:\n        Chem.SanitizeMol(prod)\n        smi = Chem.MolToSmiles(prod)\n        if smi not in seen:\n            prods.append(prod)\n            seen.add(smi)\n        if len(prods)>=12:\n            break\nDraw.MolsToGridImage(prods,molsPerRow=4)\n\n\n\n\nThose come back ordered by the R groups (i.e. all products created using the first value of R1, then all products created using the second value of R1, etc.). This is fine if we’re planning on enumerating all the molecules, but if we only need a subset we can tell enumerate_all_products() to return the results in a random order:\n\n# set a random seed so that we get reproducible results\nrandom.seed(0xbaff7ed)\nprod_gen = enumerate_all_products(rgd_core,r1s,r2s,r3s,randomOrder=True)\nprods = []\nseen = set()\nfor prod in prod_gen:\n    if prod is not None:\n        Chem.SanitizeMol(prod)\n        smi = Chem.MolToSmiles(prod)\n        if smi not in seen:\n            prods.append(prod)\n            seen.add(smi)\n        if len(prods)>=12:\n            break\nDraw.MolsToGridImage(prods,molsPerRow=4)\n\n\n\n\nHopefully this brief post is useful!"
  }
]